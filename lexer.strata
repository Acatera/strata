`
%include 'inc/std.inc'

%define SOURCE_CODE_SIZE 1048576
section .bss
    inFileHandle resq 1
    outFileHandle resq 1
    buffer1 resb 256
    buffer2 resb 256
    buffer3 resb 256

section .data
    cStrSourceFile db "v2.strata", 0
    cStrOutputFile db "v2.asm", 0
    cStrObjectFile db "v2.o", 0
    cStrLinkerFile db "v2.exe", 0

section .text
    global _start
    extern CreateFileA
    extern ReadFile
    extern CloseHandle
    extern GetLastError

_start:
    InitStandardOutput()
    `
array sourceCode = uint8 [ 1048576 ] ;
uint64 bytesRead = 0 ;

proc OpenSourceFile ( ) `
    ; print input and output file names
    printf(`"; Input file '%s'\r\n"`, cStrSourceFile)

    ; Preparing the parameters for CreateFileA to open a file for reading
    mov rcx, cStrSourceFile                       ; First parameter: Pointer to the filename (LPCSTR)
    mov rdx, GENERIC_READ                       ; Second parameter: Access to the file (DWORD), for reading use GENERIC_READ
    mov r8, 1                                   ; Third parameter: File sharing mode (DWORD)
    mov r9, 0                                   ; Fourth parameter: Pointer to security attributes (LPSECURITY_ATTRIBUTES)
    sub rsp, 4*8 + 3*8                          ; Shadow space for 4 register parameters + 3 additional stack parameters
    mov [rsp+4*8], dword 3                      ; Fifth parameter: Action to take on files that exist or do not exist (DWORD)
    mov [rsp+5*8], dword FILE_ATTRIBUTE_NORMAL  ; Sixth parameter: File attributes and flags (DWORD)
    mov [rsp+6*8], dword 0                      ; Seventh parameter: Handle to a template file (HANDLE)
    call CreateFileA
    add rsp, 4*8 + 3*8 
    mov [inFileHandle], rax
    
    mov rcx, [inFileHandle]      ; Handle to the file (HANDLE)
    mov rdx, sourceCode        ; Pointer to the buffer that receives the data read from the file (LPVOID)
    mov r8, dword SOURCE_CODE_SIZE   ; Number of bytes to be read from the file (DWORD)
    mov r9, bytesRead         ; Pointer to the variable that receives the number of bytes read (LPDWORD)
    sub rsp, 32
    push 0
    call ReadFile
    add rsp, 40`
endproc OpenSourceFile

proc CloseSourceFile ( ) `
    mov rcx, [inFileHandle]
    sub rsp, 32
    push 0
    call CloseHandle
    add rsp, 40`
endproc CloseSourceFile

proc CreateOutputFile ( ) `
    ; print input and output file names
    printf(`"; Output file '%s'\r\n"`, cStrOutputFile)

    ; Preparing the parameters for CreateFileA to open a file for reading
    mov rcx, cStrOutputFile                       ; First parameter: Pointer to the filename (LPCSTR)
    mov rdx, GENERIC_WRITE                       ; Second parameter: Access to the file (DWORD), for reading use GENERIC_READ
    mov r8, 2                                   ; Third parameter: File sharing mode (DWORD)
    mov r9, 0                                   ; Fourth parameter: Pointer to security attributes (LPSECURITY_ATTRIBUTES)
    sub rsp, 4*8 + 3*8                          ; Shadow space for 4 register parameters + 3 additional stack parameters
    mov [rsp+4*8], dword 2                      ; Fifth parameter: Action to take on files that exist or do not exist (DWORD)
    mov [rsp+5*8], dword FILE_ATTRIBUTE_NORMAL  ; Sixth parameter: File attributes and flags (DWORD)
    mov [rsp+6*8], dword 0                      ; Seventh parameter: Handle to a template file (HANDLE)
    call CreateFileA
    add rsp, 4*8 + 3*8 
    mov [outFileHandle], rax
    SetOutputFile(outFileHandle)`
endproc CreateOutputFile

proc CloseOutputFile ( ) `
    mov rcx, [outFileHandle]
    sub rsp, 32
    push 0
    call CloseHandle
    add rsp, 40`
endproc CloseOutputFile

proc WriteFileHeader ( ) `
    WriteToFile(`"; Generated by Strata v2.0\n"`)
    WriteToFile(`"\n"`)
    WriteToFile(`"bits 64\n"`)
    WriteToFile(`"default rel\n"`)
    WriteToFile(`"\n"`)
    WriteToFile(`"section .text\n"`)
    WriteToFile(`"    extern ExitProcess\n"`)
    WriteToFile(`"    global _start\n"`)
    WriteToFile(`"_start:\n"`)`
endproc WriteFileHeader

uint64 handle = 0 ; 
handle = OpenSourceFile ( ) ;

if handle < 0 then `
    printf(`"[\#27[91mERROR\#27[0m] Failed to open input file '%s'\n"`, cStrSourceFile)
    ExitProcess(1) `
else `
    printf(`"; Successfully opened input file '%s'\n"`, cStrSourceFile) 
    printf(`"; Read %d bytes from input file\n"`, [bytesRead])`
end 

CloseSourceFile ( ) ;

CreateOutputFile ( ) ;
WriteFileHeader ( ) ;

uint64 _ = 0 ;
uint64 true = 1 ;

uint8 c = 0 ;
uint64 scIndex = 0 ;
array token = uint8 [ 512 ] ;
uint64 tokenIndex = 0 ;
uint64 isSep = 0 ;

uint64 line = 1 ;
uint64 line_start = 1 ;
uint64 col = 1 ;

array tokens = uint64 [ 10000 ] ;
uint64 tokenCount = 0 ;
uint64 tokenSize = 4 ;

uint64 pt_ = 0 ;
proc push_token ( tokenType value line col )
    pt_ = tokenType ;
    tokens [ tokenCount ] = pt_ ;
    _ = tokenCount + 1 ;
    pt_ = value ;
    tokens [ _ ] = pt_ ;
    _ = tokenCount + 2 ;
    pt_ = line ;
    tokens [ _ ] = pt_ ;
    _ = tokenCount + 3 ;
    pt_ = col ;
    tokens [ _ ] = pt_ ;
    tokenCount = tokenCount + tokenSize ; `
    ;printf(`"[Trace] Pushed token: %d %d"`, [rbp+16], [rbp+24])
    ;printf(`" %d %d\n"`, [rbp+32], [rbp+40])`
endproc push_token

array stringBuffer = uint8 [ 100000 ] ;
uint64 sbIndex = 0 ;
uint64 stringBufferTop = 0 ;
array stringPointers = uint64 [ 5000 ] ;
uint64 stringPointersTop = 0 ;

array stringToPush = uint8 [ 256 ] ;
uint64 freeStringIndex = 0 ;
uint8 freeChar = 0 ;
proc push_identifier ( ) 
    freeStringIndex = 0 ;
    freeChar = token [ freeStringIndex ] ;
    stringPointers [ stringPointersTop ] = stringBufferTop ;

    while freeChar != 0 do 
        stringBuffer [ stringBufferTop ] = freeChar ;
        stringBufferTop = stringBufferTop + 1 ;
        freeStringIndex = freeStringIndex + 1 ;
        freeChar = token [ freeStringIndex ] ;
    end
    
    stringBuffer [ stringBufferTop ] = 0 ;
    stringBufferTop = stringBufferTop + 1 ; 
    `
    ;printf(`"[Trace] Pushed string: #%d with length %d.\n"`, [stringPointersTop], [freeStringIndex])
    `
    stringPointersTop = stringPointersTop + 1 ; 
endproc push_identifier 

uint64 TOKEN_UINT8                    =  1 ;
uint64 TOKEN_UINT64                   =  2 ;
uint64 TOKEN_POINTER                  =  3 ;
uint64 TOKEN_IDENTIFIER               =  4 ;
uint64 TOKEN_ASSIGNMENT               =  5 ;

uint64 TOKEN_CONSTANT_INTEGER         =  6 ;
uint64 TOKEN_CONSTANT_STRING          =  7 ;

uint64 TOKEN_SEMICOLON                =  8 ;
uint64 TOKEN_COMMA                    =  9 ;

uint64 TOKEN_LEFT_PARENTHESIS         = 10 ;
uint64 TOKEN_RIGHT_PARENTHESIS        = 11 ;

uint64 TOKEN_LEFT_BRACKET             = 12 ;
uint64 TOKEN_RIGHT_BRACKET            = 13 ;

uint64 TOKEN_PLUS                     = 14 ;
uint64 TOKEN_MINUS                    = 15 ;
uint64 TOKEN_MULTIPLY                 = 16 ;
uint64 TOKEN_DIVIDE                   = 17 ;
uint64 TOKEN_MODULO                   = 18 ;

uint64 TOKEN_LESS_THAN                = 19 ;
uint64 TOKEN_LESS_THAN_OR_EQUAL_TO    = 20 ;
uint64 TOKEN_GREATER_THAN             = 21 ;
uint64 TOKEN_GREATER_THAN_OR_EQUAL_TO = 22 ;
uint64 TOKEN_EQUALS                   = 23 ;
uint64 TOKEN_NOT_EQUALS               = 24 ;

uint64 TOKEN_LOGICAL_AND              = 25 ;
uint64 TOKEN_LOGICAL_OR               = 26 ;

uint64 TOKEN_IF                       = 27 ;
uint64 TOKEN_THEN                     = 28 ;
uint64 TOKEN_ELSE                     = 29 ;
uint64 TOKEN_END                      = 30 ;

uint64 TOKEN_WHILE                    = 31 ;
uint64 TOKEN_DO                       = 32 ;
uint64 TOKEN_BREAK                    = 33 ;
uint64 TOKEN_CONTINUE                 = 34 ;

uint64 TOKEN_EXTERN                   = 35 ;

uint64 TOKEN_PROC                     = 36 ;
uint64 TOKEN_ARROW_RIGHT              = 37 ;
uint64 TOKEN_VARS                     = 38 ;
uint64 TOKEN_CODE                     = 39 ;
uint64 TOKEN_RETURN                   = 40 ;

uint64 TOKEN_STRUCT                   = 41 ;
uint64 TOKEN_DOT                      = 42 ;

uint64 TOKEN_EXIT                     = 43 ;

uint64 TYPE_UINT8                  = 1 ;
uint64 TYPE_UINT64                 = 2 ;
uint64 TYPE_POINTER                = 3 ;
uint64 TYPE_ARRAY                  = 4 ;
uint64 TYPE_STRING                 = 5 ;
uint64 TYPE_PROCEDURE              = 6 ;
uint64 TYPE_EXTERNAL_PROCEDURE     = 7 ;
uint64 TYPE_USER_DEFINED           = 8 ;

uint64 VARIABLE_SCOPE_GLOBAL       = 0 ;

uint64 VARTYPE_PARAMETER           = 1 ;
uint64 VARTYPE_LOCAL               = 2 ;

uint64 VAR_KIND_PRIMITIVE          = 1 ;
uint64 VAR_KIND_USER_DEFINED       = 2 ;

uint64 i = 0 ;

array token_dictionary = uint8 [ 5000 ] ;
uint64 token_dictionary_top = 0 ;
array token_dictionary_pointers = uint64 [ 500 ] ;
uint64 token_dictionary_pointers_top = 0 ;

proc register_token_type ( token_type ) 
    freeStringIndex = 0 ;
    freeChar = stringToPush [ freeStringIndex ] ;
    token_dictionary_pointers [ token_dictionary_pointers_top ] = token_dictionary_top ;

    while freeChar != 0 do 
        token_dictionary [ token_dictionary_top ] = freeChar ;
        token_dictionary_top = token_dictionary_top + 1 ;
        freeStringIndex = freeStringIndex + 1 ;
        freeChar = stringToPush [ freeStringIndex ] ;
    end
    
    token_dictionary [ token_dictionary_top ] = 0 ;
    token_dictionary_top = token_dictionary_top + 1 ; 
    `
    ;printf(`"[Trace] Pushed string: #%d with length %d.\n"`, [token_dictionary_pointers_top], [freeStringIndex])
    `
    token_dictionary_pointers_top = token_dictionary_pointers_top + 1 ; 
    _ = token_type ;
    token_dictionary_pointers [ token_dictionary_pointers_top ] = _ ;
    token_dictionary_pointers_top = token_dictionary_pointers_top + 1 ;
endproc register_token_type 

array token_at_pointer = uint8 [ 256 ] ;
proc read_token ( index )
    freeStringIndex = 0 ;
    _ = index ;
    _ = _ * 2 ;
    sbIndex = token_dictionary_pointers [ _ ] ;
    _ = sbIndex ;
    freeChar = token_dictionary [ sbIndex ] ;

    while freeChar != 0 do 
        token_at_pointer [ freeStringIndex ] = freeChar ;
        freeStringIndex = freeStringIndex + 1 ;
        sbIndex = sbIndex + 1 ;
        freeChar = token_dictionary [ sbIndex ] ;
    end 
    token_at_pointer [ freeStringIndex ] = 0 ; `
    ;printf(`"[Trace] Read string: #%d with length %d.\n"`, [rbp + 16], [freeStringIndex])
    mov rax, [_]`
endproc read_token

proc token_equals ( a ) `
    mov rsi, token
    `
    _ = read_token ( a ) ; `
    mov rdi, token_at_pointer

    ;printf(`"[Trace] Comparing strings: %s and %s\n"`, rsi, rdi)
.loop:
    mov al, byte [rdi]
    mov bl, byte [rsi]
    cmp al, bl
    jne .str_neq
    cmp al, 0
    je .str1_null
    cmp bl, 0
    je .str2_null
    inc rdi
    inc rsi
    jmp .loop

.str1_null:
    cmp bl, 0
    je .str_eq
    jmp .str_neq

.str2_null:
    cmp al, 0
    je .str_eq
    jmp .str_neq    

.str_neq:
    xor rax, rax
    jmp .end

.str_eq:
    mov rax, 1
.end: `
endproc token_equals

uint64 gttCount = 0 ;
uint64 gttIndex = 0 ;
uint64 gttEqual = 0 ;
proc get_token_type ( )
    gttCount = 0 ;
    gttIndex = 0 ;
    gttEqual = 0 ;
    while gttCount < [token_dictionary_pointers_top] do
        gttEqual = token_equals ( gttIndex ) ;

        if gttEqual != 0 then
            break ;
        end

        gttCount = gttCount + 2 ;
        gttIndex = gttIndex + 1 ;
    end

    if gttEqual == [true] then 
        _ = 1 + gttCount ;
        _ = token_dictionary_pointers [ _ ] ; `
        mov rax, [_]` 
    else `
        mov rax, 0`
    end
endproc get_token_type

uint64 tnNumber = 0 ;
uint64 tnDigit = 0 ;
uint8 tnChar = 0 ;
uint64 tnIndex = 0 ;
uint64 tnSuccess = 0 ;
uint64 tnIsHex = 0 ;
uint64 tnBase = 10 ;
proc to_number ( )
    tnNumber = 0 ;
    tnIsHex = 0 ;
    tnIndex = 0 ;
    tnBase = 10 ;
    tnSuccess = 1 ;
    tnChar = token [ tnIndex ] ;
    if tnChar != 0 then
        _ = tnIndex + 1 ;
        _ = token [ _ ] ;
        if _ == 88 then 
            tnIsHex = 1 ;
        end
        if _ == 120 then
            tnIsHex = 1 ;
        end
    end
    if tnIsHex == 1 then
        tnBase = 16 ;
        tnIndex = 2 ;
        tnChar = token [ tnIndex ] ;
    end
    while tnChar != 0 do 
        tnNumber = tnNumber * tnBase ; 
        tnDigit = token [ tnIndex ] ;
        if tnDigit > 96 then
            if tnDigit < 103 then
                tnDigit = tnDigit - 87 ;
            else
                tnSuccess = 0 ;
                break ;
            end
        else if tnDigit > 64 then
            if tnDigit < 71 then
                tnDigit = tnDigit - 55 ;
            else
                tnSuccess = 0 ;
                break ;
            end
        else if tnDigit > 47 then
            if tnDigit < 58 then
                tnDigit = tnDigit - 48 ;
            else
                tnSuccess = 0 ;
                break ;
            end 
        end end end 
        tnNumber = tnNumber + tnDigit ;
        tnIndex = tnIndex + 1 ;
        tnChar = token [ tnIndex ] ;
    end `
    mov rax, [tnSuccess]`
endproc to_number

proc isSpace ( )
    if c == 32 then `
        mov rax, 1`
    else if c == 10 then `
        mov rax, 1`
    else if c == 13 then `
        mov rax, 1`
    else if c == 9 then `
        mov rax, 1`
    else `
        mov rax, 0`
    end end end end
endproc isSpace

proc isSeparator ( )
    if c == 59 then `
        mov rax, 1`
    else if c == 44 then `
        mov rax, 1`
    else if c == 40 then `
        mov rax, 1`
    else if c == 41 then `
        mov rax, 1`
    else if c == 91 then `
        mov rax, 1`
    else if c == 93 then `
        mov rax, 1`
    else if c == 46 then `
        mov rax, 1`
    else `
        mov rax, 0`
    end end end end end end end
endproc isSeparator

stringToPush [ 0 ] = 117 ;
stringToPush [ 1 ] = 105 ;
stringToPush [ 2 ] = 110 ;
stringToPush [ 3 ] = 116 ;
stringToPush [ 4 ] = 56 ;
stringToPush [ 5 ] = 0 ;
_ = register_token_type ( TOKEN_UINT8 ) ;

stringToPush [ 0 ] = 117 ;
stringToPush [ 1 ] = 105 ;
stringToPush [ 2 ] = 110 ;
stringToPush [ 3 ] = 116 ;
stringToPush [ 4 ] = 54 ;
stringToPush [ 5 ] = 52 ;
stringToPush [ 6 ] = 0 ;
_ = register_token_type ( TOKEN_UINT64 ) ;

stringToPush [ 0 ] = 112 ;
stringToPush [ 1 ] = 111 ;
stringToPush [ 2 ] = 105 ;
stringToPush [ 3 ] = 110 ;
stringToPush [ 4 ] = 116 ;
stringToPush [ 5 ] = 101 ;
stringToPush [ 6 ] = 114 ;
stringToPush [ 7 ] = 0 ;
_ = register_token_type ( TOKEN_POINTER ) ;

stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 110 ;
stringToPush [ 2 ] = 100 ;
stringToPush [ 3 ] = 0 ;
_ = register_token_type ( TOKEN_LOGICAL_AND ) ;

stringToPush [ 0 ] = 111 ;
stringToPush [ 1 ] = 114 ;
stringToPush [ 2 ] = 0 ;
_ = register_token_type ( TOKEN_LOGICAL_OR ) ;

stringToPush [ 0 ] = 105 ;
stringToPush [ 1 ] = 102 ;
stringToPush [ 2 ] = 0 ;
_ = register_token_type ( TOKEN_IF ) ;

stringToPush [ 0 ] = 116 ;
stringToPush [ 1 ] = 104 ;
stringToPush [ 2 ] = 101 ;
stringToPush [ 3 ] = 110 ;
stringToPush [ 4 ] = 0 ;
_ = register_token_type ( TOKEN_THEN ) ;

stringToPush [ 0 ] = 101 ;
stringToPush [ 1 ] = 108 ;
stringToPush [ 2 ] = 115 ;
stringToPush [ 3 ] = 101 ;
stringToPush [ 4 ] = 0 ;
_ = register_token_type ( TOKEN_ELSE ) ;

stringToPush [ 0 ] = 101 ;
stringToPush [ 1 ] = 110 ;
stringToPush [ 2 ] = 100 ;
stringToPush [ 3 ] = 0 ;
_ = register_token_type ( TOKEN_END ) ;

stringToPush [ 0 ] = 119 ;
stringToPush [ 1 ] = 104 ;
stringToPush [ 2 ] = 105 ;
stringToPush [ 3 ] = 108 ;
stringToPush [ 4 ] = 101 ;
stringToPush [ 5 ] = 0 ;
_ = register_token_type ( TOKEN_WHILE ) ;

stringToPush [ 0 ] = 100 ;
stringToPush [ 1 ] = 111 ;
stringToPush [ 2 ] = 0 ;
_ = register_token_type ( TOKEN_DO ) ;

stringToPush [ 0 ] = 98 ;
stringToPush [ 1 ] = 114 ;
stringToPush [ 2 ] = 101 ;
stringToPush [ 3 ] = 97 ;
stringToPush [ 4 ] = 107 ;
stringToPush [ 5 ] = 0 ;
_ = register_token_type ( TOKEN_BREAK ) ;

stringToPush [ 0 ] = 99 ;
stringToPush [ 1 ] = 111 ;
stringToPush [ 2 ] = 110 ;
stringToPush [ 3 ] = 116 ;
stringToPush [ 4 ] = 105 ;
stringToPush [ 5 ] = 110 ;
stringToPush [ 6 ] = 117 ;
stringToPush [ 7 ] = 101 ;
stringToPush [ 8 ] = 0 ;
_ = register_token_type ( TOKEN_CONTINUE ) ;

stringToPush [ 0 ] = 101 ;
stringToPush [ 1 ] = 120 ;
stringToPush [ 2 ] = 116 ;
stringToPush [ 3 ] = 101 ;
stringToPush [ 4 ] = 114 ;
stringToPush [ 5 ] = 110 ;
stringToPush [ 6 ] = 0 ;
_ = register_token_type ( TOKEN_EXTERN ) ;

stringToPush [ 0 ] = 112 ;
stringToPush [ 1 ] = 114 ;
stringToPush [ 2 ] = 111 ;
stringToPush [ 3 ] = 99 ;
stringToPush [ 4 ] = 0 ;
_ = register_token_type ( TOKEN_PROC ) ;

stringToPush [ 0 ] = 118 ;
stringToPush [ 1 ] = 97 ;
stringToPush [ 2 ] = 114 ;
stringToPush [ 3 ] = 115 ;
stringToPush [ 4 ] = 0 ;
_ = register_token_type ( TOKEN_VARS ) ;

stringToPush [ 0 ] = 99 ;
stringToPush [ 1 ] = 111 ;
stringToPush [ 2 ] = 100 ;
stringToPush [ 3 ] = 101 ;
stringToPush [ 4 ] = 0 ;
_ = register_token_type ( TOKEN_CODE ) ;

stringToPush [ 0 ] = 114 ;
stringToPush [ 1 ] = 101 ;
stringToPush [ 2 ] = 116 ;
stringToPush [ 3 ] = 117 ;
stringToPush [ 4 ] = 114 ;
stringToPush [ 5 ] = 110 ;
stringToPush [ 6 ] = 0 ;
_ = register_token_type ( TOKEN_RETURN ) ;

stringToPush [ 0 ] = 115 ;
stringToPush [ 1 ] = 116 ;
stringToPush [ 2 ] = 114 ;
stringToPush [ 3 ] = 117 ;
stringToPush [ 4 ] = 99 ;
stringToPush [ 5 ] = 116 ;
stringToPush [ 6 ] = 0 ;
_ = register_token_type ( TOKEN_STRUCT ) ;

stringToPush [ 0 ] = 101 ;
stringToPush [ 1 ] = 120 ;
stringToPush [ 2 ] = 105 ;
stringToPush [ 3 ] = 116 ;
stringToPush [ 4 ] = 0 ;
_ = register_token_type ( TOKEN_EXIT ) ;

`
;printf(`"Token dictionary count: %d\n"`, [token_dictionary_pointers_top])
`
uint64 token_type = 0 ;
proc push_and_print_token ( ) `
    ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'; "`, token)
    `
    _ = to_number ( ) ;
    if _ == 1 then 
        _ = push_token ( TOKEN_CONSTANT_INTEGER tnNumber line col ) ;
    else
        token_type = get_token_type ( ) ;
        if token_type == 0 then 
            _ = push_token ( TOKEN_IDENTIFIER stringPointersTop line col ) ;
            push_identifier ( ) ;
        else
            _ = push_token ( token_type 0 line col ) ;
        end 
    end 
endproc push_and_print_token

while scIndex < [bytesRead] do 
    c = sourceCode [ scIndex ] ; 
    _ = isSpace ( ) ;
    isSep = isSeparator ( ) ;
    if _ == 1 then 
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ;
            push_and_print_token ( ) ;
        end

        if c == 10 then 
            line = line + 1 ;
            line_start = scIndex + 1 ; 
        end
        tokenIndex = 0 ;
        c = sourceCode [ scIndex ] ;
        while true == 1 do
            _ = isSpace ( c ) ;
            if _ == 1 then
                if c == 10 then 
                    line = line + 1 ;
                    line_start = scIndex + 1 ; 
                end
                scIndex = scIndex + 1 ;
                c = sourceCode [ scIndex ] ;
            else
                scIndex = scIndex - 1 ;
                c = sourceCode [ scIndex ] ;
                break ;
            end
            
        end
        col = 1 + scIndex - line_start - 1 ; `
        ;printf(`"---------------SCIndex: %d, col: %d\n"`, [scIndex], [col])
        `
    else if c == 34 then 
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        `
        ;token [ tokenIndex ] = c ;
        ;tokenIndex = tokenIndex + 1 ;
        `
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;    
        while scIndex < [bytesRead] do 
            if c == 92 then
                scIndex = scIndex + 1 ;
                c = sourceCode [ scIndex ] ;
                if c == 34 then
                    token [ tokenIndex ] = c ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else if c == 92 then
                    token [ tokenIndex ] = c ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else if c == 110 then
                    token [ tokenIndex ] = 10 ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else if c == 114 then
                    token [ tokenIndex ] = 13 ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else if c == 116 then
                    token [ tokenIndex ] = 9 ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else if c == 48 then
                    token [ tokenIndex ] = 0 ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else if c == 39 then
                    token [ tokenIndex ] = 39 ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else if c == 92 then
                    token [ tokenIndex ] = 92 ;
                    tokenIndex = tokenIndex + 1 ;
                    scIndex = scIndex + 1 ;
                    c = sourceCode [ scIndex ] ;
                else `
                    printf(`"[\#27[91mERROR\#27[0m] Invalid escape sequence\n"`)
                    ExitProcess(1)`
                end end end end end end end end 
            else if c == 34 then
                break ;
            else
                token [ tokenIndex ] = c ;
                tokenIndex = tokenIndex + 1 ;
                scIndex = scIndex + 1 ;
                c = sourceCode [ scIndex ] ;
            end end 
        end
        `
        ;token [ tokenIndex ] = c ; 
        ;tokenIndex = tokenIndex + 1 ;
        `
        token [ tokenIndex ] = 0 ; `
        ;printf(`"[\#27[92mINFO\#27[0m] Token: [!] '%s'\n"`, token)
        `
        _ = push_token ( TOKEN_CONSTANT_STRING stringPointersTop line col ) ;
        push_identifier ( ) ;
        col = 2 + scIndex - line_start - 1 ;
        tokenIndex = 0 ;
    else if isSep == 1 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        col = scIndex - line_start - 1 ; 
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        token [ tokenIndex ] = 0 ; `
        ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
        `
        if c == 59 then
            _ = push_token ( TOKEN_SEMICOLON 0 line col ) ;
        else if c == 44 then
            _ = push_token ( TOKEN_COMMA 0 line col ) ;
        else if c == 40 then
            _ = push_token ( TOKEN_LEFT_PARENTHESIS 0 line col ) ;
        else if c == 41 then
            _ = push_token ( TOKEN_RIGHT_PARENTHESIS 0 line col ) ;
        else if c == 91 then
            _ = push_token ( TOKEN_LEFT_BRACKET 0 line col ) ;
        else if c == 93 then
            _ = push_token ( TOKEN_RIGHT_BRACKET 0 line col ) ;
        else if c == 46 then
            _ = push_token ( TOKEN_DOT 0 line col ) ;
        end end end end end end end 
        tokenIndex = 0 ;
        col = 1 + scIndex - line_start - 1 ;
    else if c == 61 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
            col = scIndex - line_start - 1 ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_EQUALS 0 line col ) ;
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_ASSIGNMENT 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end
    else if c == 33 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_NOT_EQUALS 0 line col ) ;
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: '%s'\n"`, token)
            `
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end
    else if c == 60 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_LESS_THAN_OR_EQUAL_TO 0 line col ) ;
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_LESS_THAN 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end
    else if c == 62 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ;
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_GREATER_THAN_OR_EQUAL_TO 0 line col ) ;
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_GREATER_THAN 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end
    else if c == 43 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: '%s'\n"`, token)
            `
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_PLUS 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end
    else if c == 42 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ;
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: '%s'\n"`, token)
            `
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_MULTIPLY 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end 
    else if c == 45 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: '%s'\n"`, token)
            `
            tokenIndex = 0 ;
        else if c == 62 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_ARROW_RIGHT 0 line col ) ;
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_MINUS 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end end
    else if c == 47 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: '%s'\n"`, token)
            `
            tokenIndex = 0 ;
        else if c == 47 then
            tokenIndex = 0 ;
            scIndex = scIndex + 1 ;
            while c != 10 do
                scIndex = scIndex + 1 ;
                c = sourceCode [ scIndex ] ;
            end
            line = line + 1 ;
            line_start = scIndex + 1 ;
            col = 1 + scIndex - line_start - 1 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_DIVIDE 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end end  
    else if c == 37 then
        if tokenIndex > 0 then 
            token [ tokenIndex ] = 0 ; 
            push_and_print_token ( ) ;
        end
        tokenIndex = 0 ;
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
        scIndex = scIndex + 1 ;
        c = sourceCode [ scIndex ] ;
        if c == 61 then
            token [ tokenIndex ] = c ;
            tokenIndex = tokenIndex + 1 ;
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: '%s'\n"`, token)
            `
            tokenIndex = 0 ;
        else 
            token [ tokenIndex ] = 0 ; `
            ;printf(`"[\#27[92mINFO\#27[0m] Token: [x] '%s'\n"`, token)
            `
            _ = push_token ( TOKEN_MODULO 0 line col ) ;
            tokenIndex = 0 ;
            scIndex = scIndex - 1 ;
        end  
    else            
        token [ tokenIndex ] = c ;
        tokenIndex = tokenIndex + 1 ;
    end end end end end end end end end end end end

    scIndex = scIndex + 1 ;
end

`
printf(`"; token count: %d\n"`, [tokenCount])
`

uint64 globalBlockId = 0 ;
uint64 globalProcedureId = 1 ;
uint64 globalUserTypeId = 1 ;
uint64 globalBoolParsingProcedure = 0 ;
uint64 globalAllowVariableDeclaration = 1 ;
uint64 ppdLocalVariableCount = 0 ;

uint64 ppdRbpOffset = 0 ;

array globalVariables = uint64 [ 10000 ] ;
uint64 globalVariableCount = 0 ;
uint64 globalVariableSize = 6 ;

uint64 gvTypeOffset     = 0 ;
uint64 gvSubTypeOffset  = 1 ;
uint64 gvKindOffset     = 2 ;
uint64 gvNameOffset     = 3 ;
uint64 gvValueOffset    = 4 ;
uint64 gvScopeOffset    = 5 ;

uint64 gvType        = 0 ;
uint64 gvSubType     = 0 ;
uint64 gvKind        = 0 ;
uint64 gvNamePointer = 0 ;
uint64 gvValue       = 0 ;
uint64 gvScope       = 0 ;

proc forward readString

uint64 _av = 0 ;
proc addVariable ( type subType kind namePointer value scope )
    _ = gvTypeOffset + globalVariableCount * globalVariableSize ;
    _av = type ;
    globalVariables [ _ ] = _av ;
    _ = gvSubTypeOffset + globalVariableCount * globalVariableSize ;
    _av = subType ;
    globalVariables [ _ ] = _av ;
    _ = gvKindOffset + globalVariableCount * globalVariableSize ;
    _av = kind ;
    globalVariables [ _ ] = _av ;
    _ = gvNameOffset + globalVariableCount * globalVariableSize ;
    _av = namePointer ;
    globalVariables [ _ ] = _av ;
    _ = gvValueOffset + globalVariableCount * globalVariableSize ;
    _av = value ;
    globalVariables [ _ ] = _av ; 
    _ = gvScopeOffset + globalVariableCount * globalVariableSize ;
    _av = scope ;
    globalVariables [ _ ] = _av ;
    globalVariableCount = globalVariableCount + 1 ;
endproc addVariable

array globalSymbolTable = uint64 [ 10000 ] ;
uint64 globalSymbolsCount = 0 ;
uint64 globalSymbolSize = 6 ;

uint64 gsType        = 0 ;
uint64 gsSubType     = 0 ;
uint64 gsKind        = 0 ;
uint64 gsNamePointer = 0 ;
uint64 gsValue       = 0 ;
uint64 gsScope       = 0 ;

uint64 gsTypeOffset     = 0 ;
uint64 gsSubTypeOffset  = 1 ;
uint64 gsKindOffset     = 2 ;
uint64 gsNameOffset     = 3 ;
uint64 gsValueOffset    = 4 ;
uint64 gsScopeOffset    = 5 ;

uint64 _as = 0 ;
proc addSymbol ( type subType kind namePointer value scope )
    _ = gvTypeOffset + globalSymbolsCount * globalSymbolSize ;
    _as = type ;
    globalSymbolTable [ _ ] = _as ;
    _ = gvSubTypeOffset + globalSymbolsCount * globalSymbolSize ;
    _as = subType ;
    globalSymbolTable [ _ ] = _as ;
    _ = gvKindOffset + globalSymbolsCount * globalSymbolSize ;
    _as = kind ;
    globalSymbolTable [ _ ] = _as ;
    _ = gvNameOffset + globalSymbolsCount * globalSymbolSize ;
    _as = namePointer ;
    globalSymbolTable [ _ ] = _as ;
    _ = gvValueOffset + globalSymbolsCount * globalSymbolSize ;
    _as = value ;
    globalSymbolTable [ _ ] = _as ; 
    _ = gvScopeOffset + globalSymbolsCount * globalSymbolSize ;
    _as = scope ;
    globalSymbolTable [ _ ] = _as ;
    globalSymbolsCount = globalSymbolsCount + 1 ;
endproc addSymbol

proc stringsEqual ( a b ) 
    _ = readString ( a ) ; `
    mov rsi, rax
    mov rax, stringBuffer
    add rsi, rax
    `
    _ = readString ( b ) ; `
    mov rdi, rax
    mov rax, stringBuffer
    add rdi, rax
.t:
    ;printf(`"[Trace] Comparing strings: %s and %s\n"`, rsi, rdi)
.loop:
    mov al, byte [rdi]
    mov bl, byte [rsi]
    cmp al, bl
    jne .str_neq
    cmp al, 0
    je .str1_null
    cmp bl, 0
    je .str2_null
    inc rdi
    inc rsi
    jmp .loop

.str1_null:
    cmp bl, 0
    je .str_eq
    jmp .str_neq

.str2_null:
    cmp al, 0
    je .str_eq
    jmp .str_neq    

.str_neq:
    xor rax, rax
    jmp .end

.str_eq:
    mov rax, 1
.end: `
endproc stringsEqual

uint64 fgsIndex = 0 ;
uint64 fgsNamePointer = 0 ;
uint64 fgsScope = 0 ;
uint64 fgsEqual = 0 ;
proc findSymbol ( namePointer )
    fgsIndex = globalSymbolsCount - 1 ;
    while fgsIndex >= 0 do
        _ = gvNameOffset + fgsIndex * globalSymbolSize ;
        fgsNamePointer = globalSymbolTable [ _ ] ;
        if globalBoolParsingProcedure == 1 then
            _ = gvScopeOffset + fgsIndex * globalSymbolSize ;
            fgsScope = globalSymbolTable [ _ ] ;
            if fgsScope != [globalProcedureId] then
                if fgsScope != [VARIABLE_SCOPE_GLOBAL] then
                    fgsIndex = fgsIndex - 1 ;
                    continue ;
                end
            end
        end
        fgsEqual = stringsEqual ( namePointer fgsNamePointer ) ;

        if fgsEqual != 0 then
            break ;
        end

        fgsIndex = fgsIndex - 1 ;
    end

    if fgsEqual == [true] then
        _ = gsTypeOffset + fgsIndex * globalSymbolSize ;
        gsType = globalSymbolTable [ _ ] ;
        _ = gsSubTypeOffset + fgsIndex * globalSymbolSize ;
        gsSubType = globalSymbolTable [ _ ] ;
        _ = gsKindOffset + fgsIndex * globalSymbolSize ;
        gsKind = globalSymbolTable [ _ ] ;
        _ = gsNameOffset + fgsIndex * globalSymbolSize ;
        gsNamePointer = globalSymbolTable [ _ ] ;
        _ = gsValueOffset + fgsIndex * globalSymbolSize ;
        gsValue = globalSymbolTable [ _ ] ;
        _ = gsScopeOffset + fgsIndex * globalSymbolSize ;
        gsScope = globalSymbolTable [ _ ] ;
        
        _ = gvValueOffset + fgsIndex * globalSymbolSize ;
        `
        ;printf(`"[Trace] Found global symbol: #%d with value %d.\n"`, [fgsIndex], [_])
        mov rax, [_] `
    else
        gsType = 0 ;
        gsSubType = 0 ;
        gsNamePointer = 0 ;
        gsValue = 0 ;
        gsScope = 0 ;

        `
        ;printf(`"[Trace] Did not find global symbol.\n"`)
        mov rax, -1 `
    end
endproc findSymbol

uint64 futUserType = 0 ;
proc findUserType ( userType )
    fgsIndex = 0 ;
    fgsEqual = 0 ;
    while fgsIndex < [globalSymbolsCount] do
        _ = gsTypeOffset + fgsIndex * globalSymbolSize ;
        _ = globalSymbolTable [ _ ] ;
        if _ != [TYPE_USER_DEFINED] then
            fgsIndex = fgsIndex + 1 ;
            continue ;
        end

        _ = gsSubTypeOffset + fgsIndex * globalSymbolSize ;
        _ = globalSymbolTable [ _ ] ;
        futUserType = userType ;
        if _ == [futUserType] then
            fgsEqual = 1 ;
            break ;
        end

        fgsIndex = fgsIndex + 1 ;
    end

    if fgsEqual == [true] then
        _ = gsTypeOffset + fgsIndex * globalSymbolSize ;
        gsType = globalSymbolTable [ _ ] ;
        _ = gsSubTypeOffset + fgsIndex * globalSymbolSize ;
        gsSubType = globalSymbolTable [ _ ] ;
        _ = gsKindOffset + fgsIndex * globalSymbolSize ;
        gsKind = globalSymbolTable [ _ ] ;
        _ = gsNameOffset + fgsIndex * globalSymbolSize ;
        gsNamePointer = globalSymbolTable [ _ ] ;
        _ = gsValueOffset + fgsIndex * globalSymbolSize ;
        gsValue = globalSymbolTable [ _ ] ;
        _ = gsScopeOffset + fgsIndex * globalSymbolSize ;
        gsScope = globalSymbolTable [ _ ] ;
        
        _ = gvValueOffset + fgsIndex * globalSymbolSize ;
        _ = globalSymbolTable [ _ ] ;
        `
        ;printf(`"[Trace] Found user type: #%d with value %d.\n"`, [fgsIndex], [_])
        mov rax, [_] `
    else
        gsType = 0 ;
        gsSubType = 0 ;
        gsNamePointer = 0 ;
        gsValue = 0 ;
        gsScope = 0 ;

        `
        ;printf(`"[Trace] Did not find user type.\n"`)
        mov rax, -1 `
    end
endproc findUserType

uint64 currentToken = 0 ;
uint64 expectedToken = 0 ;
uint64 nextToken = 0 ;

array userTypes = uint64 [ 10000 ] ;
uint64 userTypeCount = 0 ;
uint64 userTypeSize = 4 ;

uint64 utParentOffset   = 0 ;
uint64 utTypeOffset     = 1 ;
uint64 utNameOffset     = 2 ;
uint64 utOffsetOffset   = 3 ;

uint64 utParent   = 0 ;
uint64 utType     = 0 ;
uint64 utNamePointer = 0 ;
uint64 utOffset   = 0 ;

proc addUserTypeField ( parent type namePointer offset )
    _ = utParentOffset + userTypeCount * userTypeSize ;
    utParent = parent ;
    userTypes [ _ ] = utParent ;

    _ = utTypeOffset + userTypeCount * userTypeSize ;
    utType = type ;
    userTypes [ _ ] = utType ;

    _ = utNameOffset + userTypeCount * userTypeSize ;
    utNamePointer = namePointer ;
    userTypes [ _ ] = utNamePointer ;

    _ = utOffsetOffset + userTypeCount * userTypeSize ;
    utOffset = offset ;
    userTypes [ _ ] = utOffset ;

    userTypeCount = userTypeCount + 1 ;
endproc addUserTypeField


proc findUserTypeField ( parent fieldNamePointer )
    fgsIndex = globalSymbolsCount - 1 ;
    while userTypeCount >= 0 do
        _ = utParentOffset + fgsIndex * userTypeSize ;
        utParent = userTypes [ _ ] ;
    
        _ = parent ;
        if utParent != [_] then
            fgsIndex = fgsIndex - 1 ;
            continue ;
        end
        
        _ = utNameOffset + fgsIndex * userTypeSize ;
        utNamePointer = userTypes [ _ ] ;
        fgsEqual = stringsEqual ( fieldNamePointer utNamePointer ) ;

        if fgsEqual != 0 then
            break ;
        end

        fgsIndex = fgsIndex - 1 ;
    end

    if fgsEqual == [true] then
        _ = utParentOffset + fgsIndex * userTypeSize ;
        utParent = userTypes [ _ ] ;
        _ = utTypeOffset + fgsIndex * userTypeSize ;
        utType = userTypes [ _ ] ;
        _ = utNameOffset + fgsIndex * userTypeSize ;
        utNamePointer = userTypes [ _ ] ;
        _ = utOffsetOffset + fgsIndex * userTypeSize ;
        utOffset = userTypes [ _ ] ;
        
        _ = utOffsetOffset + fgsIndex * userTypeSize ;
        _ = userTypes [ _ ] ;
        `
        ;printf(`"[Trace] Found user type field: #%d with offset %d.\n"`, [fgsIndex], [_])
        mov rax, [_] `
    else
        utParent = 0 ;
        utType = 0 ;
        utNamePointer = 0 ;
        utOffset = 0 ;
        `
        ;printf(`"[Trace] Did not find user type field.\n"`)
        mov rax, -1 `
    end
endproc findUserTypeField

proc pushString ( ) 
    freeStringIndex = 0 ;
    freeChar = stringToPush [ freeStringIndex ] ;
    stringPointers [ stringPointersTop ] = stringBufferTop ;

    while freeChar != 0 do 
        stringBuffer [ stringBufferTop ] = freeChar ;
        stringBufferTop = stringBufferTop + 1 ;
        freeStringIndex = freeStringIndex + 1 ;
        freeChar = stringToPush [ freeStringIndex ] ;
    end
    
    stringBuffer [ stringBufferTop ] = 0 ;
    stringBufferTop = stringBufferTop + 1 ; 
    `
    ;printf(`"[Trace] Pushed string: #%d with length %d.\n"`, [stringPointersTop], [freeStringIndex])
    `
    stringPointersTop = stringPointersTop + 1 ; 
endproc pushString 

array stringAtPointer = uint8 [ 256 ] ;
proc readString ( index )
    freeStringIndex = 0 ;
    _ = index ;
    sbIndex = stringPointers [ _ ] ;
    _ = sbIndex ;
    freeChar = stringBuffer [ sbIndex ] ;

    while freeChar != 0 do 
        stringAtPointer [ freeStringIndex ] = freeChar ;
        freeStringIndex = freeStringIndex + 1 ;
        sbIndex = sbIndex + 1 ;
        freeChar = stringBuffer [ sbIndex ] ;
    end 
    stringAtPointer [ freeStringIndex ] = 0 ; `
    ;printf(`"[Trace] Read string: #%d with length %d.\n"`, [rbp + 16], [freeStringIndex])
    mov rax, [_]`
endproc readString


uint64 errorAtLine = 0 ;
uint64 errorAtColumn = 0 ;
proc consumeToken ( )
    if currentToken == [expectedToken] then
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
        i = i + tokenSize ;
        nextToken = tokens [ i ] ;
        i = i - tokenSize ;
    else 
        _ = i + 2 ;
        errorAtLine = tokens [ _ ] ;
        _ = i + 3 ;
        errorAtColumn = tokens [ _ ] ;
        `
        printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
        printf(`"expected token %d but got %d\n"`, [expectedToken], [currentToken])
        ExitProcess(1) `
    end
endproc consumeToken

proc indentifierRedeclared ( namePointer )
    _ = i - tokenSize ;
    _ = _ + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i - tokenSize ;
    _ = _ + 3 ;
    errorAtColumn = tokens [ _ ] ;
    _ = readString ( namePointer ) ; ` 
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"identifier redeclared: %s\n"`, stringAtPointer) ;
    ExitProcess(1)`
endproc indentifierRedeclared

proc identifierUnknown ( namePointer )
    _ = i - tokenSize ;
    _ = _ + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i - tokenSize ;
    _ = _ + 3 ;
    errorAtColumn = tokens [ _ ] ;
    _ = readString ( namePointer ) ; ` 
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"unknown identifier: %s\n"`, stringAtPointer) ;
    ExitProcess(1)`
endproc identifierUnknown

proc unexpectedToken ( ) 
    _ = i + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i + 3 ;
    errorAtColumn = tokens [ _ ] ;
    `
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"unexpected token %d\n"`, [currentToken])
    ExitProcess(1)`
endproc unexpectedToken

proc parseNumber ( )
    expectedToken = TOKEN_CONSTANT_INTEGER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    ;printf(`"[Trace] Number: %d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseNumber

proc parseIdentifier ( )
    expectedToken = TOKEN_IDENTIFIER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    ;printf(`"[Trace] Identifier: #%d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseIdentifier

proc parseType ( )
    if currentToken == [TOKEN_UINT8] then
        _ = TYPE_UINT8 ;
         i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else if currentToken == [TOKEN_UINT64] then
        _ = TYPE_UINT64 ;
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else if currentToken == [TOKEN_POINTER] then
        _ = TYPE_POINTER ;
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else
        unexpectedToken ( ) ;
    end end end
    `
    ; set result
    mov rax, [_]`
endproc parseType

proc parseString ( )
    expectedToken = TOKEN_CONSTANT_STRING ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    ;printf(`"[Trace] Identifier: #%d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseString

proc parseArrayDeclaration ( )
    if globalBoolParsingProcedure != 0 then 
        _ = i + 2 ;
        errorAtLine = tokens [ _ ] ;
        _ = i + 3 ;
        errorAtColumn = tokens [ _ ] ;
        `
        printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
        printf(`"arrays declarations are not allowed in procedures\n"`)`
    end

    expectedToken = TOKEN_LEFT_BRACKET ;
    consumeToken ( ) ;

    if currentToken == [TOKEN_CONSTANT_INTEGER] then
        gvValue = parseNumber ( ) ; `
        ;printf(`"gvValue: %d\n"`, [gvValue])
        `

        expectedToken = TOKEN_RIGHT_BRACKET ;
        consumeToken ( ) ;

        gvNamePointer = parseIdentifier ( ) ;

        gvSubType = gvType ;
        gvType = TYPE_ARRAY ;

        `
        ;printf(`"[Trace] Array declaration: type %d, subtype %d\n"`, [gvType], [gvSubType])
        `
        _ = addVariable ( gvType gvSubType VAR_KIND_PRIMITIVE gvNamePointer gvValue VARIABLE_SCOPE_GLOBAL ) ;
        _ = addSymbol ( gvType gvSubType VAR_KIND_PRIMITIVE gvNamePointer gvValue VARIABLE_SCOPE_GLOBAL ) ; `
        ;printf(`"[Trace] Array declaration: type %d, value %d\n"`, [gvType], [gvValue])`
    else 
        expectedToken = TOKEN_RIGHT_BRACKET ;
        consumeToken ( ) ;

        gvNamePointer = parseIdentifier ( ) ;

        gvSubType = TYPE_STRING ;
        gvType = TYPE_ARRAY ;

        expectedToken = TOKEN_ASSIGNMENT ;
        consumeToken ( ) ;

        gvValue = parseString ( ) ; `
        ;printf(`"[Trace] String declaration: type %d, subtype %d\n"`, [gvType], [gvSubType])
        `
        _ = addVariable ( gvType gvSubType VAR_KIND_PRIMITIVE gvNamePointer gvValue VARIABLE_SCOPE_GLOBAL ) ;
        _ = addSymbol ( gvType gvSubType VAR_KIND_PRIMITIVE gvNamePointer gvValue VARIABLE_SCOPE_GLOBAL ) ; `
        ;printf(`"[Trace] String declaration: type %d, value %d\n"`, [gvType], [gvValue])`
    end
endproc parseArrayDeclaration

proc parseIntegerDeclaration ( )
    gvNamePointer = parseIdentifier ( ) ;

    fgsIndex = findSymbol ( gvNamePointer ) ;

    if fgsIndex != -1 then
        _ = indentifierRedeclared ( gvNamePointer ) ;
    end

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    gvValue = parseNumber ( ) ;
    
    if globalBoolParsingProcedure == 0 then
        _ = addVariable ( gvType 0 VAR_KIND_PRIMITIVE gvNamePointer gvValue VARIABLE_SCOPE_GLOBAL ) ;
        _ = addSymbol ( gvType 0 VAR_KIND_PRIMITIVE gvNamePointer 0 VARIABLE_SCOPE_GLOBAL ) ; 
    else 
        _ = addVariable ( gvType VARTYPE_LOCAL VAR_KIND_PRIMITIVE gvNamePointer gvValue globalProcedureId ) ;
        _ = addSymbol ( gvType VARTYPE_LOCAL VAR_KIND_PRIMITIVE gvNamePointer ppdRbpOffset globalProcedureId ) ; 
        ppdRbpOffset = ppdRbpOffset + 8 ;
    end `
    ;printf(`"[Trace] Variable declaration: type %d, value %d\n"`, [gvType], [gvValue])`
endproc parseIntegerDeclaration 
    

proc parseVariableDeclaration ( )
    if globalAllowVariableDeclaration == 0 then
        _ = i + 2 ;
        errorAtLine = tokens [ _ ] ;
        _ = i + 3 ;
        errorAtColumn = tokens [ _ ] ;
        `
        printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
        printf(`"variable declarations are not allowed in procedure code section\n"`)`
    end

    ppdLocalVariableCount = ppdLocalVariableCount + 1 ;

    gvType = parseType ( ) ;

    if currentToken == [TOKEN_LEFT_BRACKET] then
        parseArrayDeclaration ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        parseIntegerDeclaration ( ) ;
    else
        unexpectedToken ( ) ;
    end end

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 
endproc parseVariableDeclaration

proc forward parseAdditiveExpression
proc forward parseStatements
proc forward parseArrayAccess
proc forward parseProcedureCall
proc forward parseStructAccess

uint64 pfStructFieldIdentifier = 0 ;
uint64 pfType = 0 ;
uint64 fpIdentifier = 0 ;
proc parseFactor ( ) 
    if currentToken == [TOKEN_CONSTANT_INTEGER] then
        _ = parseNumber ( ) ;
        if _ > 2147483647 then `
            WriteToFile(`"\tmov rax, %d\n\tpush rax\n"`, [_])`
        else `
            WriteToFile(`"\tpush %d\n"`, [_])`
        end
    else if currentToken == [TOKEN_LEFT_PARENTHESIS] then
        expectedToken = TOKEN_LEFT_PARENTHESIS ;
        consumeToken ( ) ;

        parseAdditiveExpression ( ) ;
 
        expectedToken = TOKEN_RIGHT_PARENTHESIS ;
        consumeToken ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        if nextToken == [TOKEN_LEFT_BRACKET] then 
            fpIdentifier = parseArrayAccess ( ) ; 
            
            fgsIndex = findSymbol ( fpIdentifier ) ;

            if fgsIndex == -1 then
                _ = identifierUnknown ( fpIdentifier ) ;
            end 
           
            if gsKind == [VAR_KIND_PRIMITIVE] then 
                _ = readString ( fpIdentifier ) ; 
                if gsSubType == [TYPE_UINT8] then `
                    WriteToFile(`"; -- uint8[] access\n"`)
                    WriteToFile(`"\tpop rax\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush qword [rax]\n"`, stringAtPointer)`
                else if gsSubType == [TYPE_UINT64] then `
                    WriteToFile(`"; -- uint64[] access\n"`)
                    WriteToFile(`"\tpop rax\n\tshl rax, 3\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush qword [rax]\n"`, stringAtPointer)`
                else if gsSubType == [TYPE_POINTER] then `
                    WriteToFile(`"; -- pointer[] access\n"`)
                    WriteToFile(`"\tpop rax\n\tshl rax, 3\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush qword [rax]\n"`, stringAtPointer)`
                else if gsSubType == [TYPE_STRING] then `
                    WriteToFile(`"; -- string access\n"`)
                    WriteToFile(`"\tpop rax\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush qword [rax]\n"`, stringAtPointer)`
                else ` 
                    printf(`"[Error] Error: unknown array type %d\n"`, [gsSubType])
                    ExitProcess(1)`
                end end end end
            else 
                pfType = gsSubType ;
                _ = findUserType ( gsSubType ) ;
                if _ == -1 then `
                    printf(`"Error: unknown user type %d\n"`, [gsSubType])
                    ExitProcess(1)`
                end 
                _ = readString ( fpIdentifier ) ; `
                WriteToFile(`"; -- indexing struct[] array --\n"`)
                WriteToFile(`"\tpop rax\n\tmov rdx, %d\n\tmul rdx\n\tmov rbx, %s\n\tadd rax, rbx\n"`, [gsValue], stringAtPointer)
                `
                if currentToken == [TOKEN_DOT] then
                    expectedToken = TOKEN_DOT ;
                    consumeToken ( ) ;

                    pfStructFieldIdentifier = parseIdentifier ( ) ; 

                    fgsIndex = findUserTypeField ( pfType pfStructFieldIdentifier ) ; `
                    WriteToFile(`"; -- accessing struct field value --\n"`)
                    WriteToFile(`"\tadd rax, %d\n\tpush qword [rax]\n"`, [utOffset])`
                else `
                    printf(`"\tpush qword [rax]\n"`)`
                end
            end `
            ;printf(`"[Trace] Factor: array\n"`)`
        else if nextToken == [TOKEN_LEFT_PARENTHESIS] then
            parseProcedureCall ( ) ; `
            ;printf(`"[Trace] Factor: procedure call\n"`)
            WriteToFile(`"\tpush rax\n"`)`
        else if nextToken == [TOKEN_DOT] then
            fpIdentifier = parseIdentifier ( ) ; 

            fgsIndex = findSymbol ( fpIdentifier ) ;

            if fgsIndex == -1 then
                _ = identifierUnknown ( fpIdentifier ) ;
            end 

            pfType = gsSubType ;

            _ = readString ( fpIdentifier ) ; `
            WriteToFile(`"; -- accessing struct field value --\n"`)
            WriteToFile(`"\tmov rax, %s\n"`, stringAtPointer)
            `
            expectedToken = TOKEN_DOT ;
            consumeToken ( ) ;

            pfStructFieldIdentifier = parseIdentifier ( ) ; 

            fgsIndex = findUserTypeField ( pfType pfStructFieldIdentifier ) ; `
            WriteToFile(`"\tadd rax, %d\n\tpush qword [rax]\n"`, [utOffset])`
        else `
            ; procedure stuff
            `
            _ = i + 1 ;
            _ = tokens [ _ ] ;
            `
            ;printf(`"[Trace] Factor: variable #%d\n"`, [_])
            `

            fpIdentifier = parseIdentifier ( ) ;

            fgsIndex = findSymbol ( fpIdentifier ) ;

            if fgsIndex == -1 then
                _ = identifierUnknown ( fpIdentifier ) ;
            end 

            _ = readString ( fpIdentifier ) ; 
            if gsScope == [VARIABLE_SCOPE_GLOBAL] then
                if gsType == [TYPE_UINT8] then ` 
                    WriteToFile(`"\tmovzx rax, byte [%s]\n\tpush rax\n"`, stringAtPointer)`
                else if gsType == [TYPE_UINT64] then ` 
                    WriteToFile(`"\tpush qword [%s]\n"`, stringAtPointer)`
                else if gsType == [TYPE_POINTER] then ` 
                    WriteToFile(`"\tpush qword [%s]\n"`, stringAtPointer)`
                else if gsType == [TYPE_ARRAY] then ` 
                    WriteToFile(`"\tmov rax, %s\n\tpush rax\n"`, stringAtPointer)`
                else ` 
                    printf(`"[Error] Error: unknown type %d in 'parseFactor'\n"`, [gsType])
                    ExitProcess(1)`
                end end end end
            else 
                if gsSubType == [VARTYPE_PARAMETER] then ` 
                    WriteToFile(`"\tpush qword [rbp + %d]\n"`, [gsValue])`
                else if gsSubType == [VARTYPE_LOCAL] then ` 
                    WriteToFile(`"\tpush qword [rbp - %d]\n"`, [gsValue])`
                else ` 
                    printf(`"[Error] Error: unknown subtype %d\n"`, [gsType])
                    ExitProcess(1)`
                end end
            end
        end end end
    else
        unexpectedToken ( ) ;
    end end end
endproc parseFactor

proc parseMultiplicativeExpression ( ) 
    parseFactor ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_MULTIPLY] then
            expectedToken = TOKEN_MULTIPLY ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            WriteToFile(`"; -- * --\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tmul rbx\n\tpush rax\n"`)`
        else if currentToken == [TOKEN_DIVIDE] then
            expectedToken = TOKEN_DIVIDE ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            WriteToFile(`"; -- / --\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tdiv rbx\n\tpush rax\n"`)`
        else if currentToken == [TOKEN_MODULO] then
            expectedToken = TOKEN_MODULO ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            WriteToFile(`"; -- %% --\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tdiv rbx\n\tpush rdx\n"`)`
        else
            break 
        end end end
    end
endproc parseMultiplicativeExpression

proc parseAdditiveExpression ( ) 
    parseMultiplicativeExpression ( ) ; 
    while true == 1 do 
        if currentToken == [TOKEN_PLUS] then
            expectedToken = TOKEN_PLUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            WriteToFile(`"; -- + --\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tadd rax, rbx\n\tpush rax\n"`)`
        else if currentToken == [TOKEN_MINUS] then
            expectedToken = TOKEN_MINUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            WriteToFile(`"; -- - --\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tsub rax, rbx\n\tpush rax\n"`)`
        else
            break ;
        end end
    end
endproc parseAdditiveExpression 

uint64 preIndex = 0 ;
proc parseRelationalExpression ( )
    parseAdditiveExpression ( ) ;
    if currentToken == [TOKEN_LESS_THAN] then
        expectedToken = TOKEN_LESS_THAN ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        WriteToFile(`"; -- < --\n"`)
        WriteToFile(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjl .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        WriteToFile(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_LESS_THAN_OR_EQUAL_TO] then
        expectedToken = TOKEN_LESS_THAN_OR_EQUAL_TO ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        WriteToFile(`"; -- <= --\n"`)
        WriteToFile(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjle .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        WriteToFile(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_GREATER_THAN] then
        expectedToken = TOKEN_GREATER_THAN ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        WriteToFile(`"; -- > --\n"`)
        WriteToFile(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjg .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        WriteToFile(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_GREATER_THAN_OR_EQUAL_TO] then
        expectedToken = TOKEN_GREATER_THAN_OR_EQUAL_TO ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        WriteToFile(`"; -- >= --\n"`)
        WriteToFile(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjge .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        WriteToFile(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_EQUALS] then 
        expectedToken = TOKEN_EQUALS ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        WriteToFile(`"; -- == --\n"`)
        WriteToFile(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tje .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        WriteToFile(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_NOT_EQUALS] then
        expectedToken = TOKEN_NOT_EQUALS ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        WriteToFile(`"; -- != --\n"`)
        WriteToFile(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjne .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        WriteToFile(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    end end end end end end
endproc parseRelationalExpression

proc parseLogicalAndExpression ( )
    parseRelationalExpression ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_LOGICAL_AND] then
            expectedToken = TOKEN_LOGICAL_AND ;
            consumeToken ( ) ;
            parseRelationalExpression ( ) ; `
            WriteToFile(`"; -- && --\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tand rax, rbx\n\tpush rax\n"`)`
        else
            break ;
        end
    end
endproc parseLogicalAndExpression

proc parseLogicalOrExpression ( ) `
    WriteToFile(`"; -- eval expression --\n"`)
    `
    parseLogicalAndExpression ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_LOGICAL_OR] then
            expectedToken = TOKEN_LOGICAL_OR ;
            consumeToken ( ) ;
            parseLogicalAndExpression ( ) ; `
            WriteToFile(`"; -- || --\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tor rax, rbx\n\tpush rax\n"`)`
        else
            break ;
        end
    end
endproc parseLogicalOrExpression

uint64 paaIdentifier = 0 ;
proc parseArrayAccess ( ) 
    paaIdentifier = parseIdentifier ( ) ; 

    expectedToken = TOKEN_LEFT_BRACKET ;
    consumeToken ( ) ;

    parseAdditiveExpression ( ) ;

    expectedToken = TOKEN_RIGHT_BRACKET ;
    consumeToken ( ) ; `
    mov rax, [paaIdentifier]`
endproc parseArrayAccess

uint64 psaType = 0 ;
uint64 psaIdentifier = 0 ;
uint64 psaStructFieldIdentifier = 0 ;
proc parseStructAccess ( )
    psaIdentifier = parseIdentifier ( ) ; 

    fgsIndex = findSymbol ( psaIdentifier ) ;

    if fgsIndex == -1 then
        _ = identifierUnknown ( psaIdentifier ) ;
    end 

    psaType = gsSubType ;

    _ = readString ( psaIdentifier ) ; `
    WriteToFile(`"; -- accessing struct field --\n"`)
    WriteToFile(`"\tmov rax, %s\n"`, stringAtPointer)
    `
    expectedToken = TOKEN_DOT ;
    consumeToken ( ) ;

    psaStructFieldIdentifier = parseIdentifier ( ) ; 

    fgsIndex = findUserTypeField ( psaType psaStructFieldIdentifier ) ; `
    WriteToFile(`"\tadd rax, %d\n\tpush rax\n"`, [utOffset])
    mov rax, [psaIdentifier]`
endproc parseStructAccess

uint64 paIdentifier = 0 ;
uint64 paUTFieldIdentifier = 0 ;
uint64 paType = 0 ;
uint64 paStructFieldIdentifier = 0 ;
proc parseAssignable ( )
    if nextToken == [TOKEN_LEFT_BRACKET] then 
        paIdentifier = parseArrayAccess ( ) ; 

        fgsIndex = findSymbol ( paIdentifier ) ;

        if fgsIndex == -1 then
            _ = identifierUnknown ( paIdentifier ) ;
        end 
        if gsKind == [VAR_KIND_PRIMITIVE] then
            _ = readString ( paIdentifier ) ;
            if gsSubType == [TYPE_UINT8] then `
                WriteToFile(`"; -- indexing n-th element of array --\n"`)
                WriteToFile(`"\tpop rax\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush rax\n"`, stringAtPointer)`
            else if gsSubType == [TYPE_UINT64] then `
                WriteToFile(`"; -- indexing n-th element of array --\n"`)
                WriteToFile(`"\tpop rax\n\tshl rax, 3\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush rax\n"`, stringAtPointer)`
            else if gsSubType == [TYPE_POINTER] then `
                WriteToFile(`"; -- indexing n-th element of array --\n"`)
                WriteToFile(`"\tpop rax\n\tshl rax, 3\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush rax\n"`, stringAtPointer)`            
            else if gsSubType == [TYPE_STRING] then `
                WriteToFile(`"; -- indexing n-th element of array --\n"`)
                WriteToFile(`"\tpop rax\n\tmov rbx, %s\n\tshl rax, 3\n\tadd rax, rbx\n\tpush rax\n"`, stringAtPointer)`                            
            else ` 
                printf(`"[Error] Error: unknown array type %d\n"`, [gsSubType])
                ExitProcess(1)`
            end end end end `
            ;printf(`"[Trace] Assignable: array, ct %d\n"`, [currentToken])`
        else 
            paType = gsSubType ;
            _ = findUserType ( gsSubType ) ;
            if _ == -1 then `
                printf(`"Error: unknown user type %d\n"`, [gsSubType])
                ExitProcess(1)`
            end 
            _ = readString ( paIdentifier ) ; `
            WriteToFile(`"; -- indexing n-th element of struct array --\n"`)
            WriteToFile(`"\tpop rax\n\tmov rdx, %d\n\tmul rdx\n\tmov rbx, %s\n\tadd rax, rbx\n"`, [gsValue], stringAtPointer)
            `
            if currentToken == [TOKEN_DOT] then
                expectedToken = TOKEN_DOT ;
                consumeToken ( ) ;

                paStructFieldIdentifier = parseIdentifier ( ) ; 

                fgsIndex = findUserTypeField ( paType paStructFieldIdentifier ) ; `
                WriteToFile(`"; -- accessing struct field --\n"`)
                WriteToFile(`"\tadd rax, %d\n\tpush rax\n"`, [utOffset])`
            else `
                printf(`"\tpush rax\n"`)`
            end
        end
    else if nextToken == [TOKEN_DOT] then
        paIdentifier = parseStructAccess ( ) ;
    else
        paIdentifier = parseIdentifier ( ) ; 
        
        fgsIndex = findSymbol ( paIdentifier ) ;

        if fgsIndex == -1 then
            _ = identifierUnknown ( paIdentifier ) ;
        end `
        ;printf(`"[Trace] Assignable: variable\n"`)`
    end end `
    mov rax, [paIdentifier]`
endproc parseAssignable

uint64 pasIdentifier = 0 ;
proc parseAssignmentStatement ( ) `
    WriteToFile(`"; -- assignment statement --\n"`)
    `
    pasIdentifier = parseAssignable ( ) ;

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 

    fgsIndex = findSymbol ( pasIdentifier ) ;

    if fgsIndex == -1 then
        _ = identifierUnknown ( pasIdentifier ) ;
    end
    _ = readString ( pasIdentifier ) ;
    
    if gsType == [TYPE_UINT8] then 
        if gsScope == [VARIABLE_SCOPE_GLOBAL] then `
            WriteToFile(`"; -- (uint8) set value of '%s' --\n"`, stringAtPointer)
            WriteToFile(`"\tpop rax\n\tmov byte [%s], al\n\n"`, stringAtPointer)`
        else if gsSubType == [VARTYPE_LOCAL] then `
            WriteToFile(`"; assigning value to a local uint8\n"`)
            WriteToFile(`"\tpop rax\n\tmov qword [rbp - %d], rax\n\n"`, [gsValue])`
        else if gsSubType == [VARTYPE_PARAMETER] then `
            printf(`"Cannot assign to a parameter\n"`)`
        end end end
    else if gsType == [TYPE_UINT64] then 
        if gsScope == [VARIABLE_SCOPE_GLOBAL] then `
            WriteToFile(`"; -- (uint64) set value of '%s' --\n"`, stringAtPointer)
            WriteToFile(`"\tpop rax\n\tmov qword [%s], rax\n\n"`, stringAtPointer)`
        else if gsSubType == [VARTYPE_LOCAL] then `
            WriteToFile(`"; assigning value to a local uint64\n"`)
            WriteToFile(`"\tpop rax\n\tmov qword [rbp - %d], rax\n\n"`, [gsValue])`
        else if gsSubType == [VARTYPE_PARAMETER] then `
            printf(`"Cannot assign to a parameter\n"`)`
        end end end
    else if gsType == [TYPE_POINTER] then 
        if gsScope == [VARIABLE_SCOPE_GLOBAL] then `
            WriteToFile(`"; -- (pointer) set value of '%s' --\n"`, stringAtPointer)
            WriteToFile(`"\tpop rax\n\tmov qword [%s], rax\n\n"`, stringAtPointer)`
        else if gsSubType == [VARTYPE_LOCAL] then `
            WriteToFile(`"; assigning value to a local pointer\n"`)
            WriteToFile(`"\tpop rax\n\tmov qword [rbp - %d], rax\n\n"`, [gsValue])`
        else if gsSubType == [VARTYPE_PARAMETER] then `
            printf(`"Cannot assign to a parameter\n"`)`
        end end end
    else if gsType == [TYPE_ARRAY] then
        if gsKind == [VAR_KIND_PRIMITIVE] then
            if gsSubType == [TYPE_UINT8] then `
                WriteToFile(`"; -- (uint8[]) set value --\n"`)
                WriteToFile(`"\tpop rbx\n\tpop rax\n\tmov byte [rax], bl\n\n"`)`
            else if gsSubType == [TYPE_UINT64] then `
                WriteToFile(`"; -- (uint64[]) set value --\n"`)
                WriteToFile(`"\tpop rbx\n\tpop rax\n\tmov qword [rax], rbx\n\n"`)`
            else if gsSubType == [TYPE_POINTER] then `
                WriteToFile(`"; -- (pointer[]) set value --\n"`)
                WriteToFile(`"\tpop rbx\n\tpop rax\n\tmov qword [rax], rbx\n\n"`)`
            else if gsSubType == [TYPE_STRING] then `
                WriteToFile(`"; -- (string) set value --\n"`)
                WriteToFile(`"\tpop rbx\n\tpop rax\n\tmov byte [rax], bl\n\n"`)`
            else ` 
                printf(`"[Error] Error: unknown array type %d\n"`, [gsType])
                ExitProcess(1)`
            end end end end
        else if gsKind == [VAR_KIND_USER_DEFINED] then `
            WriteToFile(`"; assigning value to a struct array element\n"`)
            WriteToFile(`"\tpop rbx\n\tpop rax\n\tmov qword [rax], rbx\n\n"`)`
        else ` 
            printf(`"[Error] Error: unknown array kind %d\n"`, [gsKind])
            ExitProcess(1)`
        end end
    else if gsType == [TYPE_USER_DEFINED] then `
        WriteToFile(`"; assigning value to a struct field\n"`)
        WriteToFile(`"\tpop rbx\n\tpop rax\n\tmov qword [rax], rbx\n\n"`)`
    else `
        printf(`"[Error] Error: unknown type %d in 'parseAssignmentStatement'\n"`, [gsType])
        ExitProcess(1)`
    end end end end end `
    ;printf(`"[Trace] Assignment statement for: '%s'\n"`, stringAtPointer)`
endproc parseAssignmentStatement

proc parseIfStatement ( blockId hasElse )
    globalBlockId = globalBlockId + 1 ;
    expectedToken = TOKEN_IF ;
    consumeToken ( ) ; `
    ;printf(`"[Trace] If statement: IF\n"`)
    WriteToFile(`"; if statement block id: %d\n"`, [rbp + 16])
    `
    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_THEN ;
    consumeToken ( ) ;
    `
    ;printf(`"[Trace] If statement: THEN\n"`)
    WriteToFile(`"\tpop rax\n\tcmp rax, 0\n\tjz condition_false_%d\n; then statement block id %d\n"`, [rbp + 16], [rbp + 16])
    `
    parseStatements ( ) ;

    if currentToken == [TOKEN_ELSE] then 
        hasElse = 1 ;
        expectedToken = TOKEN_ELSE ;
        consumeToken ( ) ; `
        WriteToFile(`"\tjmp end_if_%d\n"`, [rbp + 16])
        WriteToFile(`"condition_false_%d:\n; else statement block id %d\n"`, [rbp + 16], [rbp + 16])
        ;printf(`"[Trace] If statement: ELSE\n"`)
        `
        parseStatements ( ) ; 
    end

    expectedToken = TOKEN_END ;
    consumeToken ( ) ; 
    _ = hasElse ;
    if _ == 1 then `
        WriteToFile(`"end_if_%d:\n"`, [rbp + 16])`
    else `
        WriteToFile(`"condition_false_%d:\n"`, [rbp + 16])`
    end `
    ;printf(`"[Trace] If statement: END\n"`)`
endproc parseIfStatement

uint64 wsBlockId = 0 ;
proc parseWhileStatement ( blockId )
    wsBlockId = blockId ;
    _ = i + 1 ;
    tokens [ _ ] = wsBlockId ;
    globalBlockId = globalBlockId + 1 ;
    expectedToken = TOKEN_WHILE ;
    consumeToken ( ) ; `
    ;printf(`"[Trace] While statement: WHILE\n"`)
    WriteToFile(`"while_%d:\n"`, [rbp + 16])
    `
    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_DO ;
    consumeToken ( ) ; `
    ;printf(`"[Trace] While statement: DO\n"`)
    WriteToFile(`"\tpop rax\n\tcmp rax, 0\n\tjz end_while_%d\n; do statement %d\n"`, [rbp + 16], [rbp + 16])
    `
    parseStatements ( ) ;

    expectedToken = TOKEN_END ;
    consumeToken ( ) ; `
    ;printf(`"[Trace] While statement: END\n"`)
    WriteToFile(`"\tjmp while_%d\n"`, [rbp + 16])
    WriteToFile(`"end_while_%d:\n"`, [rbp + 16])`
endproc parseWhileStatement

uint64 pbsBlockId = 0 ;
uint64 pbsIndex = 0 ;
uint64 pbsCurrentToken = 0 ;
proc parseBreakStatement ( )
    expectedToken = TOKEN_BREAK ;
    consumeToken ( ) ; 
    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 
    
    pbsIndex = i - tokenSize - tokenSize ;
    while pbsIndex >= 0 do
        pbsCurrentToken = tokens [ pbsIndex ] ;
        if pbsCurrentToken == [TOKEN_WHILE] then
            pbsIndex = pbsIndex + 1 ;
            pbsBlockId = tokens [ pbsIndex ] ; `
            WriteToFile(`"; -- break --\n"`)
            WriteToFile(`"\tjmp end_while_%d\n"`, [pbsBlockId])`
            break ;
        end
        pbsIndex = pbsIndex - tokenSize ;
    end 
endproc parseBreakStatement

uint64 pcsBlockId = 0 ;
uint64 pcsIndex = 0 ;
uint64 pcsCurrentToken = 0 ;
proc parseContinueStatement ( )
    expectedToken = TOKEN_CONTINUE ;
    consumeToken ( ) ;
    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 
    pcsIndex = i - tokenSize - tokenSize ;
    while pcsIndex >= 0 do
        pcsCurrentToken = tokens [ pcsIndex ] ;
        if pcsCurrentToken == [TOKEN_WHILE] then
            pcsIndex = pcsIndex + 1 ;
            pcsBlockId = tokens [ pcsIndex ] ; `
            WriteToFile(`"; -- continue --\n"`)
            WriteToFile(`"\tjmp while_%d\n"`, [pcsBlockId])`
            break ;
        end
        pcsIndex = pcsIndex - tokenSize ;
    end 
endproc parseContinueStatement

uint64 paProArgumentCount = 0 ;
proc parseArguments ( )
    paProArgumentCount = 0 ;
    gvType = parseType ( ) ;
    gvNamePointer = parseIdentifier ( ) ;
    _ = addVariable ( gvType VARTYPE_PARAMETER VAR_KIND_PRIMITIVE gvNamePointer ppdRbpOffset globalProcedureId ) ;
    _ = addSymbol ( gvType VARTYPE_PARAMETER VAR_KIND_PRIMITIVE gvNamePointer ppdRbpOffset globalProcedureId ) ;
    ppdRbpOffset = ppdRbpOffset + 8 ;
    paProArgumentCount = paProArgumentCount + 1 ;
    while true == 1 do
        if currentToken == [TOKEN_COMMA] then
            expectedToken = TOKEN_COMMA ;
            consumeToken ( ) ;

            gvType = parseType ( ) ;
            gvNamePointer = parseIdentifier ( ) ;
            _ = addVariable ( gvType VARTYPE_PARAMETER VAR_KIND_PRIMITIVE gvNamePointer ppdRbpOffset globalProcedureId ) ;
            _ = addSymbol ( gvType VARTYPE_PARAMETER VAR_KIND_PRIMITIVE gvNamePointer ppdRbpOffset globalProcedureId ) ;
            ppdRbpOffset = ppdRbpOffset + 8 ;
            paProArgumentCount = paProArgumentCount + 1 ;
        else 
            break ;
        end
    end `
    mov rax, [paProArgumentCount]`
endproc parseArguments

uint64 ppdIdentifier = 0 ;

uint64 ppdHasReturnValue = 0 ;
uint64 ppdReturnStatementCount = 0 ;
proc parseProcedureDeclaration ( )
    if globalBoolParsingProcedure == 1 then 
        _ = i - tokenSize ;
        _ = _ + 2 ;
        errorAtLine = tokens [ _ ] ;
        _ = i - tokenSize ;
        _ = _ + 3 ;
        errorAtColumn = tokens [ _ ] ; ` 
        printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
        printf(`"nested procedure declaration is not allowed\n"`)
        ExitProcess(1)`
        
    end

    expectedToken = TOKEN_PROC ;
    consumeToken ( ) ; 

    ppdIdentifier = parseIdentifier ( ) ;

    fgsIndex = findSymbol ( ppdIdentifier ) ;

    if fgsIndex != -1 then
        _ = indentifierRedeclared ( ppdIdentifier ) ;
    end

    expectedToken = TOKEN_LEFT_PARENTHESIS ;
    consumeToken ( ) ; 

    paProArgumentCount = 0 ;
    if currentToken != [TOKEN_RIGHT_PARENTHESIS] then
        ppdRbpOffset = 16 ;
        parseArguments ( ) ;
    end

    expectedToken = TOKEN_RIGHT_PARENTHESIS ;
    consumeToken ( ) ;

    ppdHasReturnValue = 0 ;
    if currentToken == [TOKEN_ARROW_RIGHT] then
        expectedToken = TOKEN_ARROW_RIGHT ;
        consumeToken ( ) ;
        gvType = parseType ( ) ;
        ppdHasReturnValue = 1 ;
    end

    globalBoolParsingProcedure = 1 ;
    ppdRbpOffset = 8 ;
    ppdLocalVariableCount = 0 ;

    if currentToken == [TOKEN_VARS] then
        expectedToken = TOKEN_VARS ;
        consumeToken ( ) ;
        while true == 1 do 
            parseVariableDeclaration ( ) ;
            if currentToken == [TOKEN_CODE] then
                break ;
            end 
        end
    end

    ppdLocalVariableCount = ppdLocalVariableCount * 8 ;
    _ = readString ( ppdIdentifier ) ; `
    ;printf(`"[Trace] Procedure declaration: %s\n"`, stringAtPointer)
    WriteToFile(`";==== proc %s ====\n"`, stringAtPointer)
    WriteToFile(`"\tjmp %s_end\n%s:\n"`, stringAtPointer, stringAtPointer)
    WriteToFile(`"\tpush rbp\n\tmov rbp, rsp\n"`)
    WriteToFile(`"\tsub rsp, %d\n\n"`, [ppdLocalVariableCount])
    `

    expectedToken = TOKEN_CODE ;
    consumeToken ( ) ;

    globalAllowVariableDeclaration = 0 ;
    ppdReturnStatementCount = 0 ;
    parseStatements ( ) ;

    globalAllowVariableDeclaration = 1 ;
    globalBoolParsingProcedure = 0 ;
    globalProcedureId = globalProcedureId + 1 ;

    expectedToken = TOKEN_END ;
    consumeToken ( ) ;

    if ppdReturnStatementCount == 0 then 
        if ppdHasReturnValue == 1 then 
            _ = readString ( ppdIdentifier ) ; `
            printf(`"Error: procedure %s has no return statement\n"`, stringAtPointer)
            ExitProcess(1)`
        end `
        WriteToFile(`"\tmov rsp, rbp\n\tpop rbp\n\tret\n"`)`
    end

    _ = addSymbol ( TYPE_PROCEDURE gvType VAR_KIND_USER_DEFINED ppdIdentifier paProArgumentCount VARIABLE_SCOPE_GLOBAL ) ;

    _ = readString ( ppdIdentifier ) ; `
    ;printf(`"[Trace] Procedure declaration: %s with %d parameters\n"`, stringAtPointer, [paProArgumentCount])
    WriteToFile(`"%s_end:\n"`, stringAtPointer)
    WriteToFile(`";==== end proc %s ====\n\n"`, stringAtPointer)`
endproc parseProcedureDeclaration

uint64 prsIsEmptyResult = 0 ;
proc parseReturnStatement ( )
    expectedToken = TOKEN_RETURN ;
    consumeToken ( ) ;

    ppdReturnStatementCount = ppdReturnStatementCount + 1 ;

    prsIsEmptyResult = 1 ;
    if currentToken != [TOKEN_SEMICOLON] then
        prsIsEmptyResult = 0 ;
        parseLogicalOrExpression ( ) ;
    end

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    WriteToFile(`"; -- return --\n"`)
    `
    if prsIsEmptyResult == 0 then `
        ; has result
        WriteToFile(`"\tpop rax\n\tmov rsp, rbp\n\tpop rbp\n\tret\n"`)`
    else `
        ; no result
        WriteToFile(`"\tmov rsp, rbp\n\tpop rbp\n\tret\n"`)`
    end 
endproc parseReturnStatement

uint64 ppcIdentifier = 0 ;
uint64 ppcPrcArgumentCount = 0 ;
uint64 ppcPrcCallArgumentCount = 0 ;
uint64 ppcShadowSpace = 0 ;
uint64 ppcIndex = 0 ;
uint64 ppcCallCounter = 0 ;
proc parseProcedureCall ( )
    ppcCallCounter = ppcCallCounter + 1 ;
    ppcIdentifier = parseIdentifier ( ) ;

    fgsIndex = findSymbol ( ppcIdentifier ) ;
    _ = readString ( ppcIdentifier ) ; `
    printf(`"[Trace] Procedure call: %s\n"`, stringAtPointer)
    `

    if fgsIndex == -1 then
        _ = identifierUnknown ( ppcIdentifier ) ;
    end

    if gsType == [TYPE_PROCEDURE] then 
        ppcPrcArgumentCount = gsValue ;
        ppcShadowSpace = ppcPrcArgumentCount * 8 ;
        ppdRbpOffset = 8 ;

        expectedToken = TOKEN_LEFT_PARENTHESIS ;
        consumeToken ( ) ;

        if currentToken != [TOKEN_RIGHT_PARENTHESIS] then `
            WriteToFile(`"; -- procedure call --\n"`)
            WriteToFile(`"\tsub rsp, %d\n\tpush rbp\n\tmov rbp, rsp\n"`, [ppcShadowSpace])`
        end

        ppcPrcCallArgumentCount = 0 ;
        while currentToken != [TOKEN_RIGHT_PARENTHESIS] do
            parseLogicalOrExpression ( ) ; `
            WriteToFile(`"\tpop qword [rbp + %d]\n"`, [ppdRbpOffset])
            `
            ppcPrcCallArgumentCount = ppcPrcCallArgumentCount + 1 ;
            ppdRbpOffset = ppdRbpOffset + 8 ;
            if currentToken == [TOKEN_COMMA] then
                expectedToken = TOKEN_COMMA ;
                consumeToken ( ) ;
            end
        end

        expectedToken = TOKEN_RIGHT_PARENTHESIS ;
        consumeToken ( ) ; 
        
        if ppcPrcArgumentCount != [ppcPrcCallArgumentCount] then 
            _ = i - tokenSize ;
            _ = _ + 2 ;
            errorAtLine = tokens [ _ ] ;
            _ = i - tokenSize ;
            _ = _ + 3 ;
            errorAtColumn = tokens [ _ ] ; ` 
            printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
            printf(`"procedure requires %d arguments, but %d arguments are provided\n"`, [ppcPrcArgumentCount], [ppcPrcCallArgumentCount])
            ExitProcess(1)`
        end

        _ = readString ( ppcIdentifier ) ; 

        if ppcPrcArgumentCount != 0 then `
            WriteToFile(`"\tmov rsp, rbp\n\tpop rbp\n\tcall %s\n\tadd rsp, %d\n"`, stringAtPointer, [ppcShadowSpace])`
        else `
            WriteToFile(`"\tcall %s\n\tadd rsp, %d\n"`, stringAtPointer, [ppcShadowSpace])`
        end `
        WriteToFile(`"; procedure call: %s with %d arguments\n\n"`, stringAtPointer, [ppcPrcArgumentCount])`
    else if gsType == [TYPE_EXTERNAL_PROCEDURE] then
        ppcPrcArgumentCount = gsValue ;
        ppcShadowSpace = ppcPrcArgumentCount * 8 ;
        if ppcShadowSpace < 32 then
            ppcShadowSpace = 32 ;
        end 
        expectedToken = TOKEN_LEFT_PARENTHESIS ;
        consumeToken ( ) ;

        `
        WriteToFile(`"; -- external procedure call --\n"`)
        WriteToFile(`"\tsub rsp, %d\n\tpush rbp\n\tmov rbp, rsp\n"`, [ppcShadowSpace])
        `

        ppcPrcCallArgumentCount = 0 ;
        ppdRbpOffset = 8 ;
        while currentToken != [TOKEN_RIGHT_PARENTHESIS] do
            parseLogicalOrExpression ( ) ; `
            ;WriteToFile(`"\tpop qword [rbp + %d]\n"`, [ppdRbpOffset])
            `
            ppcPrcCallArgumentCount = ppcPrcCallArgumentCount + 1 ;
            ppdRbpOffset = ppdRbpOffset + 8 ;
            if currentToken == [TOKEN_COMMA] then
                expectedToken = TOKEN_COMMA ;
                consumeToken ( ) ;
            end
        end

        ppcIndex = ppcPrcCallArgumentCount ;
        ppdRbpOffset = ppdRbpOffset - 8 ;
        
        while ppcIndex >= 0 do 
            if ppcIndex > 4 then `
                WriteToFile(`"\tpop qword [rbp + %d]\n"`, [ppdRbpOffset])`
            else if ppcIndex == 4 then `
                WriteToFile(`"\tpop r9\n"`, [ppdRbpOffset])`
            else if ppcIndex == 3 then `
                WriteToFile(`"\tpop r8\n"`, [ppdRbpOffset])`
            else if ppcIndex == 2 then `
                WriteToFile(`"\tpop rdx\n"`, [ppdRbpOffset])`
            else if ppcIndex == 1 then `
                WriteToFile(`"\tpop rcx\n"`, [ppdRbpOffset])`
            end end end end end
            ppcIndex = ppcIndex - 1 ;
            ppdRbpOffset = ppdRbpOffset - 8 ;
        end 

        expectedToken = TOKEN_RIGHT_PARENTHESIS ;
        consumeToken ( ) ; 

        if ppcPrcArgumentCount != [ppcPrcCallArgumentCount] then 
            _ = i - tokenSize ;
            _ = _ + 2 ;
            errorAtLine = tokens [ _ ] ;
            _ = i - tokenSize ;
            _ = _ + 3 ;
            errorAtColumn = tokens [ _ ] ; ` 
            printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
            printf(`"external procedure requires %d arguments, but %d arguments are provided\n"`, [ppcPrcArgumentCount], [ppcPrcCallArgumentCount])
            ExitProcess(1)`
        end

        _ = readString ( ppcIdentifier ) ; `
        WriteToFile(`"external_%s_%d:\n"`, stringAtPointer, [ppcCallCounter])
        WriteToFile(`"\tmov rsp, rbp\n\tpop rbp\n\tcall %s\n\tadd rsp, %d\n"`, stringAtPointer, [ppcShadowSpace])
        WriteToFile(`"; external procedure call: %s with %d arguments\n\n"`, stringAtPointer, [ppcPrcArgumentCount])`
    else `
        printf(`"NOT A PROCEDURE\n"`)
        ExitProcess(1)`
    end end
endproc parseProcedureCall

proc parseProcedureCallStatement ( )
    parseProcedureCall ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 
endproc parseProcedureCallStatement

uint64 psbType = 0 ;
uint64 psbIdentifier = 0 ;
uint64 psbSizeOfStruct = 0 ;
uint64 psbCurrentOffset = 0 ;
proc parseStructBody ( )
    psbSizeOfStruct = 0 ;
    psbCurrentOffset = 0 ;
    while true == 1 do 
        if currentToken == [TOKEN_UINT8] then 
                _ = i - tokenSize ;
            _ = _ + 2 ;
            errorAtLine = tokens [ _ ] ;
            _ = i - tokenSize ;
            _ = _ + 3 ;
            errorAtColumn = tokens [ _ ] ; ` 
            printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
            printf(`"valid struct member types are 'uint64' and 'pointer'\n"`)
            ExitProcess(1)`
        else if currentToken == [TOKEN_UINT64] then
            psbType = parseType ( ) ;
            psbSizeOfStruct = psbSizeOfStruct + 8 ;
        else if currentToken == [TOKEN_POINTER] then
            psbType = parseType ( ) ;
            psbSizeOfStruct = psbSizeOfStruct + 8 ;
        else
            break ;
        end end end

        psbIdentifier = parseIdentifier ( ) ;

        expectedToken = TOKEN_SEMICOLON ;
        consumeToken ( ) ;

        _ = addUserTypeField ( globalUserTypeId psbType psbIdentifier psbCurrentOffset ) ;

        _ = readString ( psbIdentifier ) ; 

        psbCurrentOffset = psbCurrentOffset + 8 ; `
        ;printf(`"[Trace] Struct field: %s of type %d\n"`, stringAtPointer, [psbType])`
    end
endproc parseStructBody

uint64 psdIdentifier = 0 ;
proc parseStructDefinition ( )
    expectedToken = TOKEN_STRUCT ;
    consumeToken ( ) ;

    psdIdentifier = parseIdentifier ( ) ;

    fgsIndex = findSymbol ( psdIdentifier ) ;

    if fgsIndex != -1 then
        _ = indentifierRedeclared ( psdIdentifier ) ;
    end

    parseStructBody ( ) ;

    expectedToken = TOKEN_END ;
    consumeToken ( ) ;

    _ = addSymbol ( TYPE_USER_DEFINED globalUserTypeId VAR_KIND_PRIMITIVE psdIdentifier psbSizeOfStruct VARIABLE_SCOPE_GLOBAL ) ; 

    _ = readString ( psdIdentifier ) ; `
    ;printf(`"[Trace] Struct definition: %s with %d bytes\n"`, stringAtPointer, [psbSizeOfStruct])
    `
    globalUserTypeId = globalUserTypeId + 1 ;
endproc parseStructDefinition

uint64 putvdTypeIdentifier = 0 ;
uint64 putvdIdentifier = 0 ;
proc parseUserTypeVariableDeclaration ( ) 
    expectedToken = TOKEN_IDENTIFIER ;
     _ = i + 1 ;
    putvdTypeIdentifier = tokens [ _ ] ;
    consumeToken ( ) ;

    fgsIndex = findSymbol ( putvdTypeIdentifier ) ;

    if fgsIndex == -1 then
        _ = identifierUnknown ( putvdTypeIdentifier ) ;
    end
    putvdTypeIdentifier = gsSubType ;

    if currentToken == [TOKEN_LEFT_BRACKET] then
        expectedToken = TOKEN_LEFT_BRACKET ;
        consumeToken ( ) ;

        gvValue = parseNumber ( ) ;

        expectedToken = TOKEN_RIGHT_BRACKET ;
        consumeToken ( ) ;

        putvdIdentifier = parseIdentifier ( ) ;

        fgsIndex = findSymbol ( putvdIdentifier ) ;

        if fgsIndex != -1 then
            _ = indentifierRedeclared ( putvdIdentifier ) ;
        end

        expectedToken = TOKEN_SEMICOLON ;
        consumeToken ( ) ;

        _ = addVariable ( TYPE_ARRAY putvdTypeIdentifier VAR_KIND_USER_DEFINED putvdIdentifier gvValue VARIABLE_SCOPE_GLOBAL ) ;
        _ = addSymbol ( TYPE_ARRAY putvdTypeIdentifier VAR_KIND_USER_DEFINED putvdIdentifier gvValue VARIABLE_SCOPE_GLOBAL ) ;

        _ = readString ( putvdIdentifier ) ; `
        ;printf(`"[Trace] Variable definition for user type array: %s\n"`, stringAtPointer)`
    else
        putvdIdentifier = parseIdentifier ( ) ;

        fgsIndex = findSymbol ( putvdIdentifier ) ;

        if fgsIndex != -1 then
            _ = indentifierRedeclared ( putvdIdentifier ) ;
        end

        expectedToken = TOKEN_SEMICOLON ;
        consumeToken ( ) ;

        _ = addVariable ( TYPE_USER_DEFINED putvdTypeIdentifier VAR_KIND_PRIMITIVE putvdIdentifier 0 VARIABLE_SCOPE_GLOBAL ) ;
        _ = addSymbol ( TYPE_USER_DEFINED putvdTypeIdentifier VAR_KIND_PRIMITIVE putvdIdentifier 0 VARIABLE_SCOPE_GLOBAL ) ;

        _ = readString ( putvdIdentifier ) ; `
        ;printf(`"[Trace] Variable definition for user type: %s\n"`, stringAtPointer)`
    end
endproc parseUserTypeVariableDeclaration

uint64 pedIdentifier = 0 ;
proc parseExternDeclaration ( )
    expectedToken = TOKEN_EXTERN ;
    consumeToken ( ) ;

    expectedToken = TOKEN_PROC ;
    consumeToken ( ) ;

    pedIdentifier = parseIdentifier ( ) ;

    fgsIndex = findSymbol ( pedIdentifier ) ;

    if fgsIndex != -1 then
        _ = indentifierRedeclared ( pedIdentifier ) ;
    end

    expectedToken = TOKEN_LEFT_PARENTHESIS ;
    consumeToken ( ) ;

    paProArgumentCount = 0 ;
    if currentToken != [TOKEN_RIGHT_PARENTHESIS] then
        ppdRbpOffset = 16 ;
        parseArguments ( ) ;
    end

    expectedToken = TOKEN_RIGHT_PARENTHESIS ;
    consumeToken ( ) ;

    if currentToken == [TOKEN_ARROW_RIGHT] then
        expectedToken = TOKEN_ARROW_RIGHT ;
        consumeToken ( ) ;
        gvType = parseType ( ) ;
    end

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ;

    _ = addSymbol ( TYPE_EXTERNAL_PROCEDURE gvType VAR_KIND_USER_DEFINED pedIdentifier paProArgumentCount VARIABLE_SCOPE_GLOBAL ) ; 
    _ = readString ( pedIdentifier ) ; `
    WriteToFile(`"section .text\n\textern %s\n"`, stringAtPointer)`
endproc parseExternDeclaration

uint64 pesNumber = 0 ;
proc parseExitStatement ( )
    expectedToken = TOKEN_EXIT ;
    consumeToken ( ) ;

    expectedToken = TOKEN_LEFT_PARENTHESIS ;
    consumeToken ( ) ;

    pesNumber = parseNumber ( ) ;

    expectedToken = TOKEN_RIGHT_PARENTHESIS ;
    consumeToken ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    WriteToFile(`"; -- exit process -- \n"`)
    WriteToFile(`"\tmov rcx, %d\n"`, [pesNumber])
    WriteToFile(`"\tcall ExitProcess\n\n"`)`
endproc parseExitStatement

uint64 psIdentifier = 0 ;
proc parseStatement ( )
    if currentToken == [TOKEN_UINT8] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_UINT64] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_POINTER] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        _ = i + 1 ;
        psIdentifier = tokens [ _ ] ;

        fgsIndex = findSymbol ( psIdentifier ) ;
        _ = readString ( psIdentifier ) ;

        if fgsIndex != -1 then
            if nextToken == [TOKEN_DOT] then
                parseAssignmentStatement ( ) ;
            else
                if gsType == [TYPE_USER_DEFINED] then 
                    parseUserTypeVariableDeclaration ( ) ;
                else if nextToken == [TOKEN_LEFT_PARENTHESIS] then
                    parseProcedureCallStatement ( ) ;
                else
                    parseAssignmentStatement ( ) ;
                end end
            end
        else 
            _ = identifierUnknown ( psIdentifier ) ;
        end
    else if currentToken == [TOKEN_IF] then
        _ = parseIfStatement ( globalBlockId 0 0 ) ;
    else if currentToken == [TOKEN_WHILE] then
        _ = parseWhileStatement ( globalBlockId ) ;
    else if currentToken == [TOKEN_BREAK] then
        parseBreakStatement ( ) ;
    else if currentToken == [TOKEN_CONTINUE] then
        parseContinueStatement ( ) ;
    else if currentToken == [TOKEN_PROC] then
        parseProcedureDeclaration ( ) ;
    else if currentToken == [TOKEN_RETURN] then
        parseReturnStatement ( ) ;
    else if currentToken == [TOKEN_STRUCT] then
        parseStructDefinition ( ) ;
    else if currentToken == [TOKEN_EXTERN] then
        parseExternDeclaration ( ) ;
    else if currentToken == [TOKEN_EXIT] then
        parseExitStatement ( ) ;
    else
        unexpectedToken ( ) ;
    end end end end end end end end end end end end end
endproc parseStatement

proc parseStatements ( )
    while true == 1 do 
        if currentToken == [TOKEN_END] then
            break ;
        else if currentToken == [TOKEN_ELSE] then
            break ;
        else
            parseStatement ( ) ;
        end end 
    end
endproc parseStatements

i = 0 ;

while i < [tokenCount] do
    currentToken = tokens [ i ] ;
    parseStatement ( ) ;
end

i = 0 ;

`
WriteToFile(`"; -- exit process -- \n"`)
WriteToFile(`"\tmov rcx, 0\n"`)
WriteToFile(`"\tcall ExitProcess\n\n"`)
WriteToFile(`";==== global variables ====\n"`)
`

array encodedString = uint8 [ 512 ] ;
uint64 esIndex = 0 ;
uint64 esDestIndex = 0 ;
uint8 esChar = 0 ;
proc encodeString ( )
    esIndex = 0 ;
    esDestIndex = 0 ;
    encodedString [ esDestIndex ] = 34 ;
    esDestIndex = esDestIndex + 1 ;
    esChar = stringAtPointer [ esIndex ] ;
    while esChar > 0 do
        if esChar >= 32 then
            encodedString [ esDestIndex ] = esChar ;
            esDestIndex = esDestIndex + 1 ;
        else 
            encodedString [ esDestIndex ] = 34 ;
            esDestIndex = esDestIndex + 1 ;
            encodedString [ esDestIndex ] = 44 ;
            esDestIndex = esDestIndex + 1 ;
            if esChar == 13 then
                encodedString [ esDestIndex ] = 49 ;
                esDestIndex = esDestIndex + 1 ;
                encodedString [ esDestIndex ] = 51 ;
                esDestIndex = esDestIndex + 1 ;
            else if esChar == 10 then
                encodedString [ esDestIndex ] = 49 ;
                esDestIndex = esDestIndex + 1 ;
                encodedString [ esDestIndex ] = 48 ;
                esDestIndex = esDestIndex + 1 ;
            else if esChar == 9 then
                encodedString [ esDestIndex ] = 57 ;
                esDestIndex = esDestIndex + 1 ;
            end end end
            encodedString [ esDestIndex ] = 44 ;
            esDestIndex = esDestIndex + 1 ;
            encodedString [ esDestIndex ] = 34 ;
            esDestIndex = esDestIndex + 1 ;
        end
        esIndex = esIndex + 1 ;
        esChar = stringAtPointer [ esIndex ] ;
    end
    encodedString [ esDestIndex ] = 34 ;
    esDestIndex = esDestIndex + 1 ;
    encodedString [ esDestIndex ] = 0 ;
endproc encodeString

uint64 wsdIdentifier = 0 ;
while i < [globalVariableCount] do
    _ = gvTypeOffset + i * globalVariableSize ;
    gvType = globalVariables [ _ ] ;
    _ = gvSubTypeOffset + i * globalVariableSize ;
    gvSubType = globalVariables [ _ ] ;
    _ = gvKindOffset + i * globalVariableSize ;
    gvKind = globalVariables [ _ ] ;
    _ = gvNameOffset + i * globalVariableSize ;
    gvNamePointer = globalVariables [ _ ] ;
    _ = gvValueOffset + i * globalVariableSize ;
    gvValue = globalVariables [ _ ] ;
    _ = gvScopeOffset + i * globalVariableSize ;
    gvScope = globalVariables [ _ ] ;

    if gvScope != [VARIABLE_SCOPE_GLOBAL] then
        i = i + 1 ;
        continue ;
    end

    _ = readString ( gvNamePointer ) ; 
    
    if gvType == [TYPE_UINT8] then `
        WriteToFile(`"section .data\r\n\t%s db %d\n"`, stringAtPointer, [gvValue])`
    else if gvType == [TYPE_UINT64] then `
        WriteToFile(`"section .data\r\n\t%s dq %d\n"`, stringAtPointer, [gvValue])`
    else if gvType == [TYPE_POINTER] then `
        WriteToFile(`"section .data\r\n\t%s dq %d\n"`, stringAtPointer, [gvValue])`
    else if gvType == [TYPE_ARRAY] then 
        if gvKind == [VAR_KIND_PRIMITIVE] then
            if gvSubType == [TYPE_UINT8] then `
                WriteToFile(`"section .bss\r\n\t%s resb %d\n"`, stringAtPointer, [gvValue])`
            else if gvSubType == [TYPE_UINT64] then `
                WriteToFile(`"section .bss\r\n\t%s resq %d\n"`, stringAtPointer, [gvValue])`
            else if gvSubType == [TYPE_POINTER] then `
                WriteToFile(`"section .bss\r\n\t%s resq %d\n"`, stringAtPointer, [gvValue])`
            else if gvSubType == [TYPE_STRING] then `
                WriteToFile(`"section .data\r\n\t%s"`, stringAtPointer)
                `
                _ = readString ( gvValue ) ; 
                encodeString ( ) ; `
                WriteToFile(`" db %s,0\n"`, encodedString)`
            else `
                printf(`"Error: unknown array type %d\n"`, [gvType])
                ExitProcess(1)`
            end end end end
        else 

            wsdIdentifier = gvNamePointer ;

            _ = findUserType ( gvSubType ) ;
            if _ == -1 then `
                printf(`"Error: unknown user type %d\n"`, [gvSubType])
                ExitProcess(1)`
            end 

            gvValue = gvValue * gsValue ;
            _ = readString ( wsdIdentifier ) ; `
            WriteToFile(`"section .bss\r\n\t%s resb %d\n"`, stringAtPointer, [gvValue])`
        end
    else if gvType == [TYPE_USER_DEFINED] then 
        wsdIdentifier = gvNamePointer ;

        _ = findUserType ( gvSubType ) ;
        if _ == -1 then `
            printf(`"Error: unknown user type %d\n"`, [gvSubType])
            ExitProcess(1)`
        end 

        _ = readString ( wsdIdentifier ) ; `
        WriteToFile(`"section .bss\r\n\t%s resb %d\n"`, stringAtPointer, [gsValue])`
    else `
        printf(`"Error: unknown type %d\n in 'parseStatement'"`, [gvType])
        ExitProcess(1)`
    end end end end end

    i = i + 1 ;
end

CloseOutputFile ( ) ;
`
section .bss
    lpStartupInfo: resb 104
    lpProcessInformation: resb 24
    lpExitCode: resq 1

section .text    
    extern CreateProcessA
    extern WaitForSingleObject
    extern GetExitCodeProcess

    sprintf(buffer1, `"nasm.exe -f win64 %s -o %s -w+all -w+error"`, cStrOutputFile, cStrObjectFile)
    printf(`"[\#27[92mINFO\#27[0m] Assembling using 'nasm':\r\n\t%s\r\n"`, buffer1)

    memset(lpProcessInformation, 0, 24)
    memset(lpStartupInfo, 0, 104)

    mov rax, STARTUPINFOA.size
    mov [lpStartupInfo], rax

    mov rax, lpProcessInformation
    mov rbx, lpStartupInfo
    mov [rbx], dword 104
    and rsp, 0xfffffffffffffff0
    push     rax                        ; lpProcessInformation   
    push     rbx                        ; lpStartupInfo  
    push     NULL                       ; lpCurrentDirectory
    push     NULL                       ; lpEnvironment
    push     0x00000000                 ; dwCreationFlags
    push     0x00000001                 ; bInheritHandles
    sub rsp, 0x20
    mov r9,  NULL                       ; lpThreadAttributes
    mov r8,  NULL                       ; lpProcessAttributes
    mov rdx, buffer1                       ; lpCommandLine
    mov rcx, NULL
    call CreateProcessA
    add rsp, 0x20 + 7 * 0x8 `

    if rax == 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Assembling failed."`)
        ExitProcess(1)`
    end `

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , 0xFFFFFFFF
    call WaitForSingleObject

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , lpExitCode
    call GetExitCodeProcess 
    
    ; printf(`"[DEBUG] Exit code: %d.\r\n"`, [lpExitCode])
    mov rax, [lpExitCode]
    `

    if rax != 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Assembling failed."`)
        ExitProcess(1)`
    end `

    sprintf(buffer1, `"ld -e _start %s -o %s -lkernel32 -Llib"`, cStrObjectFile, cStrLinkerFile)
    printf(`"[\#27[92mINFO\#27[0m] Linking using 'ld':\r\n\t%s\r\n"`, buffer1)
    
    memset(lpProcessInformation, 0, 24)
    memset(lpStartupInfo, 0, 104)

    mov rax, STARTUPINFOA.size
    mov [lpStartupInfo], rax

    mov rax, lpProcessInformation
    mov rbx, lpStartupInfo
    mov [rbx], dword 104
    and rsp, 0xfffffffffffffff0
    push     rax                        ; lpProcessInformation   
    push     rbx                        ; lpStartupInfo  
    push     NULL                       ; lpCurrentDirectory
    push     NULL                       ; lpEnvironment
    push     0x00000000                 ; dwCreationFlags
    push     0x00000001                 ; bInheritHandles
    sub rsp, 0x20
    mov r9,  NULL                       ; lpThreadAttributes
    mov r8,  NULL                       ; lpProcessAttributes
    mov rdx, buffer1                       ; lpCommandLine
    mov rcx, NULL
    call CreateProcessA
    add rsp, 0x20 + 7 * 0x8`

    if rax == 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Linking failed."`)
        ExitProcess(1)`
    end `

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , 0xFFFFFFFF
    call WaitForSingleObject

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , lpExitCode
    call GetExitCodeProcess 
    mov rax, [lpExitCode]
    `

    if rax != 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Linking failed."`)
        ExitProcess(1)`
    end `

    printf(`"[\#27[92mINFO\#27[0m] Generated %s\r\n"`, cStrLinkerFile)

    ExitProcess(0)`