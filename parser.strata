`
%include "inc/std.inc"

section .text   
    global _start

_start:
    InitStandardOutput()
`
uint64 _ = 0 ;
uint64 true = 1 ;

array globalVariables = uint64 [ 10000 ] ;
uint64 globalVariableCount = 0 ;
uint64 globalVariableSize = 3 ;

uint64 gvTypeOffset  = 0 ;
uint64 gvNameOffset  = 1 ;
uint64 gvValueOffset = 2 ;

uint64 gvType        = 0 ;
uint64 gvNamePointer = 0 ;
uint64 gvValue       = 0 ;

uint64 currentToken = 0 ;
uint64 expectedToken = 0 ;

array stringBuffer = uint8 [ 100000 ] ;
uint64 sbIndex = 0 ;
uint64 stringBufferTop = 0 ;
array stringPointers = uint64 [ 5000 ] ;
uint64 stringPointersTop = 0 ;

array stringToPush = uint8 [ 256 ] ;
uint64 freeStringIndex = 0 ;
uint8 freeChar = 0 ;
proc pushString ( ) 
    freeStringIndex = 0 ;
    freeChar = stringToPush [ freeStringIndex ] ;
    stringPointers [ stringPointersTop ] = stringBufferTop ;

    while freeChar != 0 do 
        stringBuffer [ stringBufferTop ] = freeChar ;
        stringBufferTop = stringBufferTop + 1 ;
        freeStringIndex = freeStringIndex + 1 ;
        freeChar = stringToPush [ freeStringIndex ] ;
    end
    
    stringBuffer [ stringBufferTop ] = 0 ;
    stringBufferTop = stringBufferTop + 1 ; 
    `
    printf(`"[Trace] Pushed string: #%d with length %d.\n"`, [stringPointersTop], [freeStringIndex])
    `
    stringPointersTop = stringPointersTop + 1 ; 
endproc pushString 

array stringAtPointer = uint8 [ 256 ] ;
proc readString ( index )
    freeStringIndex = 0 ;
    _ = index ;
    sbIndex = stringPointers [ _ ] ;
    freeChar = stringBuffer [ sbIndex ] ;

    while freeChar != 0 do 
        stringAtPointer [ freeStringIndex ] = freeChar ;
        freeStringIndex = freeStringIndex + 1 ;
        sbIndex = sbIndex + 1 ;
        freeChar = stringBuffer [ sbIndex ] ;
    end 
    stringAtPointer [ freeStringIndex ] = 0 ; `
    printf(`"[Trace] Read string: #%d with length %d.\n"`, [rbp + 16], [freeStringIndex])
    `
endproc readString

array tokens = uint64 [ 1000 ] ;
uint64 tokenCount = 0 ;
uint64 tokenSize = 4 ;

array output = uint8 [ 1000000 ] ;
uint64 outputCount = 0 ;

uint64 TOKEN_UINT8                    =  1 ;
uint64 TOKEN_UINT64                   =  2 ;
uint64 TOKEN_IDENTIFIER               =  3 ;
uint64 TOKEN_ASSIGNMENT               =  4 ;
uint64 TOKEN_CONSTANT_INTEGER         =  5 ;
uint64 TOKEN_SEMICOLON                =  6 ;

uint64 TOKEN_PLUS                     =  7 ;
uint64 TOKEN_MINUS                    =  8 ;
uint64 TOKEN_MULTIPLY                 =  9 ;
uint64 TOKEN_DIVIDE                   = 10 ;
uint64 TOKEN_MODULO                   = 11 ;

uint64 TOKEN_LEFT_PARENTHESIS         = 12 ;
uint64 TOKEN_RIGHT_PARENTHESIS        = 13 ;

uint64 TOKEN_LESS_THAN                = 14 ;
uint64 TOKEN_LESS_THAN_OR_EQUAL_TO    = 15 ;
uint64 TOKEN_GREATER_THAN             = 16 ;
uint64 TOKEN_GREATER_THAN_OR_EQUAL_TO = 17 ;
uint64 TOKEN_EQUALS                   = 18 ;
uint64 TOKEN_NOT_EQUALS               = 19 ;

uint64 TOKEN_LOGICAL_AND              = 20 ;
uint64 TOKEN_LOGICAL_OR               = 21 ;

uint64 TOKEN_IF                       = 22 ;
uint64 TOKEN_THEN                     = 23 ;
uint64 TOKEN_ELSE                     = 24 ;
uint64 TOKEN_END                      = 25 ;

uint64 TOKEN_WHILE                    = 26 ;
uint64 TOKEN_DO                       = 27 ;
uint64 TOKEN_BREAK                    = 28 ;
uint64 TOKEN_CONTINUE                 = 29 ;

uint64 TYPE_UINT8                  = 1 ;
uint64 TYPE_UINT64                 = 2 ;

uint64 i = 0 ;

tokens [ 0 ] = TOKEN_UINT64 ; tokens [ 1 ] = 0 ; tokens [ 2 ] = 1 ; tokens [ 3 ] = 1 ;
tokens [ 4 ] = TOKEN_IDENTIFIER ; tokens [ 5 ] = 0 ; tokens [ 6 ] = 1 ; tokens [ 7 ] = 8 ;
tokens [ 8 ] = TOKEN_ASSIGNMENT ; tokens [ 9 ] = 0 ; tokens [ 10 ] = 1 ; tokens [ 11 ] = 10 ;
tokens [ 12 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 13 ] = 0 ; tokens [ 14 ] = 1 ; tokens [ 15 ] = 12 ;
tokens [ 16 ] = TOKEN_SEMICOLON ; tokens [ 17 ] = 0 ; tokens [ 18 ] = 1 ; tokens [ 19 ] = 13 ;
tokens [ 20 ] = TOKEN_WHILE ; tokens [ 21 ] = 0 ; tokens [ 22 ] = 3 ; tokens [ 23 ] = 1 ;
tokens [ 24 ] = TOKEN_IDENTIFIER ; tokens [ 25 ] = 1 ; tokens [ 26 ] = 3 ; tokens [ 27 ] = 7 ;
tokens [ 28 ] = TOKEN_LESS_THAN ; tokens [ 29 ] = 0 ; tokens [ 30 ] = 3 ; tokens [ 31 ] = 9 ;
tokens [ 32 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 33 ] = 10 ; tokens [ 34 ] = 3 ; tokens [ 35 ] = 11 ;
tokens [ 36 ] = TOKEN_DO ; tokens [ 37 ] = 0 ; tokens [ 38 ] = 3 ; tokens [ 39 ] = 14 ;
tokens [ 40 ] = TOKEN_IF ; tokens [ 41 ] = 0 ; tokens [ 42 ] = 4 ; tokens [ 43 ] = 5 ;
tokens [ 44 ] = TOKEN_IDENTIFIER ; tokens [ 45 ] = 2 ; tokens [ 46 ] = 4 ; tokens [ 47 ] = 8 ;
tokens [ 48 ] = TOKEN_EQUALS ; tokens [ 49 ] = 0 ; tokens [ 50 ] = 4 ; tokens [ 51 ] = 10 ;
tokens [ 52 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 53 ] = 5 ; tokens [ 54 ] = 4 ; tokens [ 55 ] = 13 ;
tokens [ 56 ] = TOKEN_THEN ; tokens [ 57 ] = 0 ; tokens [ 58 ] = 4 ; tokens [ 59 ] = 15 ;
tokens [ 60 ] = TOKEN_BREAK ; tokens [ 61 ] = 0 ; tokens [ 62 ] = 5 ; tokens [ 63 ] = 9 ;
tokens [ 64 ] = TOKEN_SEMICOLON ; tokens [ 65 ] = 0 ; tokens [ 66 ] = 5 ; tokens [ 67 ] = 14 ;
tokens [ 68 ] = TOKEN_ELSE ; tokens [ 69 ] = 0 ; tokens [ 70 ] = 6 ; tokens [ 71 ] = 5 ;
tokens [ 72 ] = TOKEN_CONTINUE ; tokens [ 73 ] = 0 ; tokens [ 74 ] = 7 ; tokens [ 75 ] = 9 ;
tokens [ 76 ] = TOKEN_SEMICOLON ; tokens [ 77 ] = 0 ; tokens [ 78 ] = 7 ; tokens [ 79 ] = 17 ;
tokens [ 80 ] = TOKEN_END ; tokens [ 81 ] = 0 ; tokens [ 82 ] = 8 ; tokens [ 83 ] = 5 ;
tokens [ 84 ] = TOKEN_IDENTIFIER ; tokens [ 85 ] = 3 ; tokens [ 86 ] = 9 ; tokens [ 87 ] = 5 ;
tokens [ 88 ] = TOKEN_ASSIGNMENT ; tokens [ 89 ] = 0 ; tokens [ 90 ] = 9 ; tokens [ 91 ] = 7 ;
tokens [ 92 ] = TOKEN_IDENTIFIER ; tokens [ 93 ] = 4 ; tokens [ 94 ] = 9 ; tokens [ 95 ] = 9 ;
tokens [ 96 ] = TOKEN_PLUS ; tokens [ 97 ] = 0 ; tokens [ 98 ] = 9 ; tokens [ 99 ] = 11 ;
tokens [ 100 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 101 ] = 1 ; tokens [ 102 ] = 9 ; tokens [ 103 ] = 13 ;
tokens [ 104 ] = TOKEN_SEMICOLON ; tokens [ 105 ] = 0 ; tokens [ 106 ] = 9 ; tokens [ 107 ] = 14 ;
tokens [ 108 ] = TOKEN_END ; tokens [ 109 ] = 0 ; tokens [ 110 ] = 10 ; tokens [ 111 ] = 1 ;
tokenCount = 112 ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

i = 0 ;

uint64 errorAtLine = 0 ;
uint64 errorAtColumn = 0 ;
proc consumeToken ( )
    if currentToken == [expectedToken] then
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else 
        _ = i + 2 ;
        errorAtLine = tokens [ _ ] ;
        _ = i + 3 ;
        errorAtColumn = tokens [ _ ] ;
        `
        printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
        printf(`"expected token %d but got %d\n"`, [expectedToken], [currentToken])
        ExitProcess(1) `
    end
endproc consumeToken

proc unexpectedToken ( ) 
    _ = i + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i + 3 ;
    errorAtColumn = tokens [ _ ] ;
    `
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"unexpected token %d\n"`, [currentToken])
    ExitProcess(1)`
endproc unexpectedToken

proc parseNumber ( )
    expectedToken = TOKEN_CONSTANT_INTEGER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    printf(`"[Trace] Number: %d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseNumber

proc parseIdentifier ( )
    expectedToken = TOKEN_IDENTIFIER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    printf(`"[Trace] Identifier: #%d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseIdentifier

proc parseUIntType ( )
    if currentToken == [TOKEN_UINT8] then
        _ = TYPE_UINT8 ;
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else if currentToken == [TOKEN_UINT64] then
        _ = TYPE_UINT64 ;
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else
        unexpectedToken ( ) ;
    end end 
    `
    ; set result
    mov rax, [_]`
endproc parseUIntType

proc parseVariableDeclaration ( )
    gvType = parseUIntType ( ) ;
    gvNamePointer = parseIdentifier ( ) ;

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    gvValue = parseNumber ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 
    
    _ = gvTypeOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = gvType ;
    _ = gvNameOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = gvNamePointer ;
    _ = gvValueOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = gvValue ; 
    globalVariableCount = globalVariableCount + 1 ; `
    printf(`"[Trace] Variable declaration: type %d, value %d\n"`, [gvType], [gvValue])`
endproc parseVariableDeclaration

proc forward parseAdditiveExpression
proc forward parseStatements

proc parseFactor ( ) 
    if currentToken == [TOKEN_CONSTANT_INTEGER] then
        parseNumber ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        parseIdentifier ( ) ;
    else if currentToken == [TOKEN_LEFT_PARENTHESIS] then
        expectedToken = TOKEN_LEFT_PARENTHESIS ;
        consumeToken ( ) ;

        parseAdditiveExpression ( ) ;
 
        expectedToken = TOKEN_RIGHT_PARENTHESIS ;
        consumeToken ( ) ;
    else
        unexpectedToken ( ) ;
    end end end
endproc parseFactor

proc parseMultiplicativeExpression ( ) 
    parseFactor ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_MULTIPLY] then
            expectedToken = TOKEN_MULTIPLY ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] MULTIPLY *\n"`)`
        else if currentToken == [TOKEN_DIVIDE] then
            expectedToken = TOKEN_DIVIDE ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] DIVIDE /\n"`)`
        else if currentToken == [TOKEN_MODULO] then
            expectedToken = TOKEN_MODULO ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] MODULO %%\n"`)`
        else
            break 
        end end end
    end
endproc parseMultiplicativeExpression

proc parseAdditiveExpression ( ) 
    parseMultiplicativeExpression ( ) ; 
    while true == 1 do 
        if currentToken == [TOKEN_PLUS] then
            expectedToken = TOKEN_PLUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            printf(`"[Trace] PLUS +\n"`)`
        else if currentToken == [TOKEN_MINUS] then
            expectedToken = TOKEN_MINUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            printf(`"[Trace] MINUS -\n"`)`
        else
            break ;
        end end
    end
endproc parseAdditiveExpression 

proc parseRelationalExpression ( )
    parseAdditiveExpression ( ) ;
    if currentToken == [TOKEN_LESS_THAN] then
        expectedToken = TOKEN_LESS_THAN ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] LESS_THAN <\n"`)`
    else if currentToken == [TOKEN_LESS_THAN_OR_EQUAL_TO] then
        expectedToken = TOKEN_LESS_THAN_OR_EQUAL_TO ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] LESS_THAN_OR_EQUAL_TO <=\n"`)`
    else if currentToken == [TOKEN_GREATER_THAN] then
        expectedToken = TOKEN_GREATER_THAN ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] GREATER_THAN >\n"`)`
    else if currentToken == [TOKEN_GREATER_THAN_OR_EQUAL_TO] then
        expectedToken = TOKEN_GREATER_THAN_OR_EQUAL_TO ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] GREATER_THAN_OR_EQUAL_TO >=\n"`)`
    else if currentToken == [TOKEN_EQUALS] then 
        expectedToken = TOKEN_EQUALS ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] EQUALS ==\n"`)`
    else if currentToken == [TOKEN_NOT_EQUALS] then
        expectedToken = TOKEN_NOT_EQUALS ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] NOT_EQUALS !=\n"`)`
    end end end end end end
endproc parseRelationalExpression

proc parseLogicalAndExpression ( )
    parseRelationalExpression ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_LOGICAL_AND] then
            expectedToken = TOKEN_LOGICAL_AND ;
            consumeToken ( ) ;
            parseRelationalExpression ( ) ; `
            printf(`"[Trace] LOGICAL_AND &&\n"`)`
        else
            break ;
        end
    end
endproc parseLogicalAndExpression

proc parseLogicalOrExpression ( )
    parseLogicalAndExpression ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_LOGICAL_OR] then
            expectedToken = TOKEN_LOGICAL_OR ;
            consumeToken ( ) ;
            parseLogicalAndExpression ( ) ; `
            printf(`"[Trace] LOGICAL_OR ||\n"`)`
        else
            break ;
        end
    end
endproc parseLogicalOrExpression

proc parseAssignmentStatement ( )
    gvNamePointer = parseIdentifier ( ) ;

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    printf(`"[Trace] Assignment statement: %d\n"`, [gvNamePointer])`
endproc parseAssignmentStatement

proc parseIfStatement ( )
    expectedToken = TOKEN_IF ;
    consumeToken ( ) ; `
    printf(`"[Trace] If statement: IF\n"`)
    `

    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_THEN ;
    consumeToken ( ) ;
    `
    printf(`"[Trace] If statement: THEN\n"`)
    `
    parseStatements ( ) ;

    while true == 1 do
        if currentToken == [TOKEN_ELSE] then 
            expectedToken = TOKEN_ELSE ;
            consumeToken ( ) ; 
            `
            printf(`"[Trace] If statement: ELSE\n"`)
            `
            if currentToken == [TOKEN_IF] then
                expectedToken = TOKEN_IF ;
                consumeToken ( ) ; `
                printf(`"[Trace] If statement: IF\n"`)
                `
                parseLogicalOrExpression ( ) ;

                expectedToken = TOKEN_THEN ;
                consumeToken ( ) ; `
                printf(`"[Trace] If statement: THEN\n"`)
                `
            end
            parseStatements ( ) ; 
        else 
            break ;
        end 
    end

    expectedToken = TOKEN_END ;
    consumeToken ( ) ; `
    printf(`"[Trace] If statement: END\n"`)`
endproc parseIfStatement

proc parseWhileStatement ( )
    expectedToken = TOKEN_WHILE ;
    consumeToken ( ) ; `
    printf(`"[Trace] While statement: WHILE\n"`)
    `
    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_DO ;
    consumeToken ( ) ; `
    printf(`"[Trace] While statement: DO\n"`)
    `
    parseStatements ( ) ;

    expectedToken = TOKEN_END ;
    consumeToken ( ) ; `
    printf(`"[Trace] While statement: END\n"`)`
endproc parseWhileStatement

proc parseBreakStatement ( )
    expectedToken = TOKEN_BREAK ;
    consumeToken ( ) ; 
    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    printf(`"[Trace] Break statement: BREAK\n"`)`
endproc parseBreakStatement

proc parseContinueStatement ( )
    expectedToken = TOKEN_CONTINUE ;
    consumeToken ( ) ;
    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    printf(`"[Trace] Continue statement: CONTINUE\n"`)`
endproc parseContinueStatement

proc parseStatement ( )
    if currentToken == [TOKEN_UINT64] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_UINT8] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        parseAssignmentStatement ( ) ;
    else if currentToken == [TOKEN_IF] then
        parseIfStatement ( ) ;
    else if currentToken == [TOKEN_WHILE] then
        parseWhileStatement ( ) ;
    else if currentToken == [TOKEN_BREAK] then
        parseBreakStatement ( ) ;
    else if currentToken == [TOKEN_CONTINUE] then
        parseContinueStatement ( ) ;
    else
        unexpectedToken ( ) ;
    end end end end end end end
endproc parseStatement

proc parseStatements ( )
    while true == 1 do 
        if currentToken == [TOKEN_END] then
            break ;
        else if currentToken == [TOKEN_ELSE] then
            break ;
        else
            parseStatement ( ) ;
        end end
    end
endproc parseStatements

i = 0 ;

while i < [tokenCount] do
    currentToken = tokens [ i ] ;
    parseStatement ( ) ;
end

i = 0 ;

while i < [globalVariableCount] do
    _ = gvTypeOffset + i * globalVariableSize ;
    gvType = globalVariables [ _ ] ;
    _ = gvNameOffset + i * globalVariableSize ;
    gvNamePointer = globalVariables [ _ ] ;
    _ = gvValueOffset + i * globalVariableSize ;
    gvValue = globalVariables [ _ ] ;
    _ = readString ( gvNamePointer ) ; 
    
    if gvType == [TYPE_UINT8] then `
        printf(`"\t%s db %d\n"`, stringAtPointer, [gvValue])`
    else if gvType == [TYPE_UINT64] then `
        printf(`"\t%s dq %d\n"`, stringAtPointer, [gvValue])`
    else `
        printf(`"Error: unknown type %d\n"`, [gvType])
        ExitProcess(1)`
    end end

    i = i + 1 ;
end

`
ExitProcess(0)
`