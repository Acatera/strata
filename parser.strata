`
%include "inc/std.inc"

section .text   
    global _start

_start:
    InitStandardOutput()
`
uint64 _ = 0 ;
uint64 true = 1 ;

array globalVariables = uint64 [ 10000 ] ;
uint64 globalVariableCount = 0 ;
uint64 globalVariableSize = 3 ;

uint64 gvTypeOffset  = 0 ;
uint64 gvNameOffset  = 1 ;
uint64 gvValueOffset = 2 ;

uint64 gvType        = 0 ;
uint64 gvNamePointer = 0 ;
uint64 gvValue       = 0 ;

uint64 currentToken = 0 ;
uint64 expectedToken = 0 ;

array stringBuffer = uint8 [ 100000 ] ;
uint64 sbIndex = 0 ;
uint64 stringBufferTop = 0 ;
array stringPointers = uint64 [ 5000 ] ;
uint64 stringPointersTop = 0 ;

array stringToPush = uint8 [ 256 ] ;
uint64 freeStringIndex = 0 ;
uint8 freeChar = 0 ;
proc pushString ( ) 
    freeStringIndex = 0 ;
    freeChar = stringToPush [ freeStringIndex ] ;
    stringPointers [ stringPointersTop ] = stringBufferTop ;

    while freeChar != 0 do 
        stringBuffer [ stringBufferTop ] = freeChar ;
        stringBufferTop = stringBufferTop + 1 ;
        freeStringIndex = freeStringIndex + 1 ;
        freeChar = stringToPush [ freeStringIndex ] ;
    end
    
    stringBuffer [ stringBufferTop ] = 0 ;
    stringBufferTop = stringBufferTop + 1 ; 
    `
    printf(`"[Trace] Pushed string: #%d with length %d.\n"`, [stringPointersTop], [freeStringIndex])
    `
    stringPointersTop = stringPointersTop + 1 ; 
endproc pushString 

array stringAtPointer = uint8 [ 256 ] ;
proc readString ( index )
    freeStringIndex = 0 ;
    _ = index ;
    sbIndex = stringPointers [ _ ] ;
    freeChar = stringBuffer [ sbIndex ] ;

    while freeChar != 0 do 
        stringAtPointer [ freeStringIndex ] = freeChar ;
        freeStringIndex = freeStringIndex + 1 ;
        sbIndex = sbIndex + 1 ;
        freeChar = stringBuffer [ sbIndex ] ;
    end 
    stringAtPointer [ freeStringIndex ] = 0 ; `
    printf(`"[Trace] Read string: #%d with length %d.\n"`, [rbp + 16], [freeStringIndex])
    `
endproc readString

array tokens = uint64 [ 1000 ] ;
uint64 tokenCount = 0 ;
uint64 tokenSize = 4 ;

array output = uint8 [ 1000000 ] ;
uint64 outputCount = 0 ;

uint64 TOKEN_UINT8                 =  1 ;
uint64 TOKEN_UINT64                =  2 ;
uint64 TOKEN_IDENTIFIER            =  3 ;
uint64 TOKEN_ASSIGNMENT            =  4 ;
uint64 TOKEN_CONSTANT_INTEGER      =  5 ;
uint64 TOKEN_SEMICOLON             =  6 ;
uint64 TOKEN_PLUS                  =  7 ;
uint64 TOKEN_MINUS                 =  8 ;
uint64 TOKEN_MULTIPLY              =  9 ;
uint64 TOKEN_DIVIDE                = 10 ;
uint64 TOKEN_MODULO                = 11 ;
uint64 TOKEN_LEFT_PARENTHESIS      = 12 ;
uint64 TOKEN_RIGHT_PARENTHESIS     = 13 ;
uint64 TOKEN_LESS_THAN             = 14 ;

uint64 TYPE_UINT8                  = 1 ;
uint64 TYPE_UINT64                 = 2 ;

uint64 i = 0 ;

tokens [ 0 ] = TOKEN_UINT64 ; tokens [ 1 ] = 0 ; tokens [ 2 ] = 1 ; tokens [ 3 ] = 1 ;
tokens [ 4 ] = TOKEN_IDENTIFIER ; tokens [ 5 ] = 0 ; tokens [ 6 ] = 1 ; tokens [ 7 ] = 8 ;
tokens [ 8 ] = TOKEN_ASSIGNMENT ; tokens [ 9 ] = 0 ; tokens [ 10 ] = 1 ; tokens [ 11 ] = 10 ;
tokens [ 12 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 13 ] = 0 ; tokens [ 14 ] = 1 ; tokens [ 15 ] = 12 ;
tokens [ 16 ] = TOKEN_SEMICOLON ; tokens [ 17 ] = 0 ; tokens [ 18 ] = 1 ; tokens [ 19 ] = 13 ;
tokens [ 20 ] = TOKEN_IDENTIFIER ; tokens [ 21 ] = 1 ; tokens [ 22 ] = 2 ; tokens [ 23 ] = 1 ;
tokens [ 24 ] = TOKEN_ASSIGNMENT ; tokens [ 25 ] = 0 ; tokens [ 26 ] = 2 ; tokens [ 27 ] = 3 ;
tokens [ 28 ] = TOKEN_IDENTIFIER ; tokens [ 29 ] = 2 ; tokens [ 30 ] = 2 ; tokens [ 31 ] = 5 ;
tokens [ 32 ] = TOKEN_LESS_THAN ; tokens [ 33 ] = 0 ; tokens [ 34 ] = 2 ; tokens [ 35 ] = 7 ;
tokens [ 36 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 37 ] = 2 ; tokens [ 38 ] = 2 ; tokens [ 39 ] = 9 ;
tokens [ 40 ] = TOKEN_SEMICOLON ; tokens [ 41 ] = 0 ; tokens [ 42 ] = 2 ; tokens [ 43 ] = 10 ;
tokenCount = 44 ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

i = 0 ;

uint64 errorAtLine = 0 ;
uint64 errorAtColumn = 0 ;
proc consumeToken ( )
    if currentToken == [expectedToken] then
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else 
        _ = i + 2 ;
        errorAtLine = tokens [ _ ] ;
        _ = i + 3 ;
        errorAtColumn = tokens [ _ ] ;
        `
        printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
        printf(`"expected token %d but got %d\n"`, [expectedToken], [currentToken])
        ExitProcess(1) `
    end
endproc consumeToken

proc unexpectedToken ( ) 
    _ = i + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i + 3 ;
    errorAtColumn = tokens [ _ ] ;
    `
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"unexpected token %d\n"`, [currentToken])
    ExitProcess(1)`
endproc unexpectedToken

proc parseNumber ( )
    expectedToken = TOKEN_CONSTANT_INTEGER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    printf(`"[Trace] Number: %d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseNumber

proc parseIdentifier ( )
    expectedToken = TOKEN_IDENTIFIER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    printf(`"[Trace] Identifier: #%d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseIdentifier

proc parseUIntType ( )
    if currentToken == [TOKEN_UINT8] then
        _ = TYPE_UINT8 ;
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else if currentToken == [TOKEN_UINT64] then
        _ = TYPE_UINT64 ;
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else
        unexpectedToken ( ) ;
    end end 
    `
    ; set result
    mov rax, [_]`
endproc parseUIntType

proc parseVariableDeclaration ( )
    gvType = parseUIntType ( ) ;
    gvNamePointer = parseIdentifier ( ) ;

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    gvValue = parseNumber ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 
    
    _ = gvTypeOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = gvType ;
    _ = gvNameOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = gvNamePointer ;
    _ = gvValueOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = gvValue ; 
    globalVariableCount = globalVariableCount + 1 ; `
    printf(`"[Trace] Variable declaration: type %d, value %d\n"`, [gvType], [gvValue])`
endproc parseVariableDeclaration

proc forward parseAdditiveExpression

proc parseFactor ( ) 
    if currentToken == [TOKEN_CONSTANT_INTEGER] then
        parseNumber ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        parseIdentifier ( ) ;
    else if currentToken == [TOKEN_LEFT_PARENTHESIS] then
        expectedToken = TOKEN_LEFT_PARENTHESIS ;
        consumeToken ( ) ;

        parseAdditiveExpression ( ) ;
 
        expectedToken = TOKEN_RIGHT_PARENTHESIS ;
        consumeToken ( ) ;
    else
        unexpectedToken ( ) ;
    end end end
endproc parseFactor

proc parseMultiplicativeExpression ( ) 
    parseFactor ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_MULTIPLY] then
            expectedToken = TOKEN_MULTIPLY ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] MULTIPLY *\n"`)`
        else if currentToken == [TOKEN_DIVIDE] then
            expectedToken = TOKEN_DIVIDE ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] DIVIDE /\n"`)`
        else if currentToken == [TOKEN_MODULO] then
            expectedToken = TOKEN_MODULO ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] MODULO %%\n"`)`
        else
            break 
        end end end
    end
endproc parseMultiplicativeExpression

proc parseAdditiveExpression ( ) 
    parseMultiplicativeExpression ( ) ; 
    while true == 1 do 
        if currentToken == [TOKEN_PLUS] then
            expectedToken = TOKEN_PLUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            printf(`"[Trace] PLUS +\n"`)`
        else if currentToken == [TOKEN_MINUS] then
            expectedToken = TOKEN_MINUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            printf(`"[Trace] MINUS -\n"`)`
        else
            break ;
        end end
    end
endproc parseAdditiveExpression 

proc parseRelationalExpression ( )
    parseAdditiveExpression ( ) ;
    if currentToken == [TOKEN_LESS_THAN] then
        expectedToken = TOKEN_LESS_THAN ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] LESS_THAN <\n"`)`
    end 
endproc parseRelationalExpression

proc parseAssignmentStatement ( )
    gvNamePointer = parseIdentifier ( ) ;

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    parseRelationalExpression ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    printf(`"[Trace] Assignment statement: %d\n"`, [gvNamePointer])`
endproc parseAssignmentStatement

i = 0 ;

while i < [tokenCount] do
    currentToken = tokens [ i ] ;
    
    if currentToken == [TOKEN_UINT64] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_UINT8] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        parseAssignmentStatement ( ) ;
    else
        unexpectedToken ( ) ;
    end end end
end

i = 0 ;

while i < [globalVariableCount] do
    _ = gvTypeOffset + i * globalVariableSize ;
    gvType = globalVariables [ _ ] ;
    _ = gvNameOffset + i * globalVariableSize ;
    gvNamePointer = globalVariables [ _ ] ;
    _ = gvValueOffset + i * globalVariableSize ;
    gvValue = globalVariables [ _ ] ;
    _ = readString ( gvNamePointer ) ; 
    
    if gvType == [TYPE_UINT8] then `
        printf(`"\t%s db %d\n"`, stringAtPointer, [gvValue])`
    else if gvType == [TYPE_UINT64] then `
        printf(`"\t%s dq %d\n"`, stringAtPointer, [gvValue])`
    else `
        printf(`"Error: unknown type %d\n"`, [gvType])
        ExitProcess(1)`
    end end

    i = i + 1 ;
end

`
ExitProcess(0)
`