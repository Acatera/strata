`
%include "inc/std.inc"

section .text   
    global _start

_start:
    InitStandardOutput()
`
uint64 _ = 0 ;
uint64 true = 1 ;

array globalVariables = uint64 [ 10000 ] ;
uint64 globalVariableCount = 0 ;
uint64 globalVariableSize = 4 ;

uint64 gvTypeOffset     = 0 ;
uint64 gvSubTypeOffset  = 1 ;
uint64 gvNameOffset     = 2 ;
uint64 gvValueOffset    = 3 ;

uint64 gvType        = 0 ;
uint64 gvSubType     = 0 ;
uint64 gvNamePointer = 0 ;
uint64 gvValue       = 0 ;

proc forward readString

proc addGlobalVariable ( type subType namePointer value )
    _ = gvTypeOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = type ;
    _ = gvSubTypeOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = subType ;
    _ = gvNameOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = namePointer ;
    _ = gvValueOffset + globalVariableCount * globalVariableSize ;
    globalVariables [ _ ] = value ; 
    globalVariableCount = globalVariableCount + 1 ;
endproc addGlobalVariable

array globalSymbolTable = uint64 [ 10000 ] ;
uint64 globalSymbolsCount = 0 ;
uint64 globalSymbolSize = 4 ;

uint64 gsType        = 0 ;
uint64 gsSubType     = 0 ;
uint64 gsNamePointer = 0 ;
uint64 gsValue       = 0 ;

uint64 gsTypeOffset     = 0 ;
uint64 gsSubTypeOffset  = 1 ;
uint64 gsNameOffset     = 2 ;
uint64 gsValueOffset    = 3 ;

proc addGlobalSymbol ( type subType namePointer value )
    _ = gvTypeOffset + globalSymbolsCount * globalSymbolSize ;
    globalSymbolTable [ _ ] = type ;
    _ = gvSubTypeOffset + globalSymbolsCount * globalSymbolSize ;
    globalSymbolTable [ _ ] = subType ;
    _ = gvNameOffset + globalSymbolsCount * globalSymbolSize ;
    globalSymbolTable [ _ ] = namePointer ;
    _ = gvValueOffset + globalSymbolsCount * globalSymbolSize ;
    globalSymbolTable [ _ ] = value ; 
    globalSymbolsCount = globalSymbolsCount + 1 ;
endproc addGlobalSymbol


proc stringsEqual ( a b ) 
    _ = readString ( a ) ; `
    mov rsi, rax
    mov rax, stringBuffer
    add rsi, rax
    `
    _ = readString ( b ) ; `
    mov rdi, rax
    mov rax, stringBuffer
    add rdi, rax
.t:
    printf(`"[Trace] Comparing strings: %s and %s\n"`, rsi, rdi)
.loop:
    mov al, byte [rdi]
    mov bl, byte [rsi]
    cmp al, bl
    jne .str_neq
    cmp al, 0
    je .str1_null
    cmp bl, 0
    je .str2_null
    inc rdi
    inc rsi
    jmp .loop

.str1_null:
    cmp bl, 0
    je .str_eq
    jmp .str_neq

.str2_null:
    cmp al, 0
    je .str_eq
    jmp .str_neq    

.str_neq:
    xor rax, rax
    jmp .end

.str_eq:
    mov rax, 1
.end: `
endproc stringsEqual

uint64 fgsIndex = 0 ;
uint64 fgsNamePointer = 0 ;
uint64 fgsEqual = 0 ;
proc findGlobalSymbol ( namePointer )
    fgsIndex = 0 ;
    while fgsIndex < [globalSymbolsCount] do
        _ = gvNameOffset + fgsIndex * globalSymbolSize ;
        fgsNamePointer = globalSymbolTable [ _ ] ;
        fgsEqual = stringsEqual ( namePointer fgsNamePointer ) ;

        if fgsEqual != 0 then
            break ;
        end

        fgsIndex = fgsIndex + 1 ;
    end

    if fgsEqual == [true] then
        _ = gsTypeOffset + fgsIndex * globalSymbolSize ;
        gsType = globalSymbolTable [ _ ] ;
        _ = gsSubTypeOffset + fgsIndex * globalSymbolSize ;
        gsSubType = globalSymbolTable [ _ ] ;
        _ = gsNameOffset + fgsIndex * globalSymbolSize ;
        gsNamePointer = globalSymbolTable [ _ ] ;
        _ = gsValueOffset + fgsIndex * globalSymbolSize ;
        gsValue = globalSymbolTable [ _ ] ;
        
        _ = gvValueOffset + fgsIndex * globalSymbolSize ;
        ` ; a
        printf(`"[Trace] Found global symbol: #%d with value %d.\n"`, [fgsIndex], [_])
         ; b
        mov rax, [_] `
    else
        gsType = 0 ;
        gsSubType = 0 ;
        gsNamePointer = 0 ;
        gsValue = 0 ;

        ` ; a
        printf(`"[Trace] Did not find global symbol.\n"`)
         ; b
        mov rax, -1 `
    end
endproc findGlobalSymbol

uint64 currentToken = 0 ;
uint64 expectedToken = 0 ;
uint64 nextToken = 0 ;

array stringBuffer = uint8 [ 100000 ] ;
uint64 sbIndex = 0 ;
uint64 stringBufferTop = 0 ;
array stringPointers = uint64 [ 5000 ] ;
uint64 stringPointersTop = 0 ;

array stringToPush = uint8 [ 256 ] ;
uint64 freeStringIndex = 0 ;
uint8 freeChar = 0 ;
proc pushString ( ) 
    freeStringIndex = 0 ;
    freeChar = stringToPush [ freeStringIndex ] ;
    stringPointers [ stringPointersTop ] = stringBufferTop ;

    while freeChar != 0 do 
        stringBuffer [ stringBufferTop ] = freeChar ;
        stringBufferTop = stringBufferTop + 1 ;
        freeStringIndex = freeStringIndex + 1 ;
        freeChar = stringToPush [ freeStringIndex ] ;
    end
    
    stringBuffer [ stringBufferTop ] = 0 ;
    stringBufferTop = stringBufferTop + 1 ; 
    `
    printf(`"[Trace] Pushed string: #%d with length %d.\n"`, [stringPointersTop], [freeStringIndex])
    `
    stringPointersTop = stringPointersTop + 1 ; 
endproc pushString 

array stringAtPointer = uint8 [ 256 ] ;
proc readString ( index )
    freeStringIndex = 0 ;
    _ = index ;
    sbIndex = stringPointers [ _ ] ;
    _ = sbIndex ;
    freeChar = stringBuffer [ sbIndex ] ;

    while freeChar != 0 do 
        stringAtPointer [ freeStringIndex ] = freeChar ;
        freeStringIndex = freeStringIndex + 1 ;
        sbIndex = sbIndex + 1 ;
        freeChar = stringBuffer [ sbIndex ] ;
    end 
    stringAtPointer [ freeStringIndex ] = 0 ; `
    printf(`"[Trace] Read string: #%d with length %d.\n"`, [rbp + 16], [freeStringIndex])
    mov rax, [_]`
endproc readString

array tokens = uint64 [ 1000 ] ;
uint64 tokenCount = 0 ;
uint64 tokenSize = 4 ;

array output = uint8 [ 1000000 ] ;
uint64 outputCount = 0 ;

uint64 TOKEN_UINT8                    =  1 ;
uint64 TOKEN_UINT64                   =  2 ;
uint64 TOKEN_IDENTIFIER               =  3 ;
uint64 TOKEN_ASSIGNMENT               =  4 ;
uint64 TOKEN_CONSTANT_INTEGER         =  5 ;
uint64 TOKEN_SEMICOLON                =  6 ;

uint64 TOKEN_PLUS                     =  7 ;
uint64 TOKEN_MINUS                    =  8 ;
uint64 TOKEN_MULTIPLY                 =  9 ;
uint64 TOKEN_DIVIDE                   = 10 ;
uint64 TOKEN_MODULO                   = 11 ;

uint64 TOKEN_LEFT_PARENTHESIS         = 12 ;
uint64 TOKEN_RIGHT_PARENTHESIS        = 13 ;

uint64 TOKEN_LEFT_BRACKET             = 14 ;
uint64 TOKEN_RIGHT_BRACKET            = 15 ;
uint64 TOKEN_LESS_THAN                = 16 ;
uint64 TOKEN_LESS_THAN_OR_EQUAL_TO    = 17 ;
uint64 TOKEN_GREATER_THAN             = 18 ;
uint64 TOKEN_GREATER_THAN_OR_EQUAL_TO = 19 ;
uint64 TOKEN_EQUALS                   = 20 ;
uint64 TOKEN_NOT_EQUALS               = 21 ;

uint64 TOKEN_LOGICAL_AND              = 22 ;
uint64 TOKEN_LOGICAL_OR               = 23 ;

uint64 TOKEN_IF                       = 24 ;
uint64 TOKEN_THEN                     = 25 ;
uint64 TOKEN_ELSE                     = 26 ;
uint64 TOKEN_END                      = 27 ;

uint64 TOKEN_WHILE                    = 28 ;
uint64 TOKEN_DO                       = 29 ;
uint64 TOKEN_BREAK                    = 30 ;
uint64 TOKEN_CONTINUE                 = 31 ;

uint64 TYPE_UINT8                  = 1 ;
uint64 TYPE_UINT64                 = 2 ;
uint64 TYPE_ARRAY                  = 3 ;

uint64 i = 0 ;

tokens [ 0 ] = TOKEN_UINT8 ; tokens [ 1 ] = 0 ; tokens [ 2 ] = 1 ; tokens [ 3 ] = 1 ;
tokens [ 4 ] = TOKEN_LEFT_BRACKET ; tokens [ 5 ] = 0 ; tokens [ 6 ] = 1 ; tokens [ 7 ] = 7 ;
tokens [ 8 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 9 ] = 100 ; tokens [ 10 ] = 1 ; tokens [ 11 ] = 9 ;
tokens [ 12 ] = TOKEN_RIGHT_BRACKET ; tokens [ 13 ] = 0 ; tokens [ 14 ] = 1 ; tokens [ 15 ] = 13 ;
tokens [ 16 ] = TOKEN_IDENTIFIER ; tokens [ 17 ] = 0 ; tokens [ 18 ] = 1 ; tokens [ 19 ] = 15 ;
tokens [ 20 ] = TOKEN_SEMICOLON ; tokens [ 21 ] = 0 ; tokens [ 22 ] = 1 ; tokens [ 23 ] = 16 ;
tokens [ 24 ] = TOKEN_UINT64 ; tokens [ 25 ] = 0 ; tokens [ 26 ] = 2 ; tokens [ 27 ] = 1 ;
tokens [ 28 ] = TOKEN_LEFT_BRACKET ; tokens [ 29 ] = 0 ; tokens [ 30 ] = 2 ; tokens [ 31 ] = 8 ;
tokens [ 32 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 33 ] = 50 ; tokens [ 34 ] = 2 ; tokens [ 35 ] = 10 ;
tokens [ 36 ] = TOKEN_RIGHT_BRACKET ; tokens [ 37 ] = 0 ; tokens [ 38 ] = 2 ; tokens [ 39 ] = 13 ;
tokens [ 40 ] = TOKEN_IDENTIFIER ; tokens [ 41 ] = 1 ; tokens [ 42 ] = 2 ; tokens [ 43 ] = 15 ;
tokens [ 44 ] = TOKEN_SEMICOLON ; tokens [ 45 ] = 0 ; tokens [ 46 ] = 2 ; tokens [ 47 ] = 16 ;
tokens [ 48 ] = TOKEN_UINT64 ; tokens [ 49 ] = 0 ; tokens [ 50 ] = 3 ; tokens [ 51 ] = 1 ;
tokens [ 52 ] = TOKEN_IDENTIFIER ; tokens [ 53 ] = 2 ; tokens [ 54 ] = 3 ; tokens [ 55 ] = 8 ;
tokens [ 56 ] = TOKEN_ASSIGNMENT ; tokens [ 57 ] = 0 ; tokens [ 58 ] = 3 ; tokens [ 59 ] = 10 ;
tokens [ 60 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 61 ] = 0 ; tokens [ 62 ] = 3 ; tokens [ 63 ] = 12 ;
tokens [ 64 ] = TOKEN_SEMICOLON ; tokens [ 65 ] = 0 ; tokens [ 66 ] = 3 ; tokens [ 67 ] = 13 ;
tokens [ 68 ] = TOKEN_IDENTIFIER ; tokens [ 69 ] = 3 ; tokens [ 70 ] = 4 ; tokens [ 71 ] = 1 ;
tokens [ 72 ] = TOKEN_LEFT_BRACKET ; tokens [ 73 ] = 0 ; tokens [ 74 ] = 4 ; tokens [ 75 ] = 3 ;
tokens [ 76 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 77 ] = 0 ; tokens [ 78 ] = 4 ; tokens [ 79 ] = 5 ;
tokens [ 80 ] = TOKEN_RIGHT_BRACKET ; tokens [ 81 ] = 0 ; tokens [ 82 ] = 4 ; tokens [ 83 ] = 7 ;
tokens [ 84 ] = TOKEN_ASSIGNMENT ; tokens [ 85 ] = 0 ; tokens [ 86 ] = 4 ; tokens [ 87 ] = 9 ;
tokens [ 88 ] = TOKEN_IDENTIFIER ; tokens [ 89 ] = 4 ; tokens [ 90 ] = 4 ; tokens [ 91 ] = 11 ;
tokens [ 92 ] = TOKEN_LEFT_BRACKET ; tokens [ 93 ] = 0 ; tokens [ 94 ] = 4 ; tokens [ 95 ] = 13 ;
tokens [ 96 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 97 ] = 1 ; tokens [ 98 ] = 4 ; tokens [ 99 ] = 15 ;
tokens [ 100 ] = TOKEN_RIGHT_BRACKET ; tokens [ 101 ] = 0 ; tokens [ 102 ] = 4 ; tokens [ 103 ] = 17 ;
tokens [ 104 ] = TOKEN_PLUS ; tokens [ 105 ] = 0 ; tokens [ 106 ] = 4 ; tokens [ 107 ] = 19 ;
tokens [ 108 ] = TOKEN_IDENTIFIER ; tokens [ 109 ] = 5 ; tokens [ 110 ] = 4 ; tokens [ 111 ] = 21 ;
tokens [ 112 ] = TOKEN_LEFT_BRACKET ; tokens [ 113 ] = 0 ; tokens [ 114 ] = 4 ; tokens [ 115 ] = 23 ;
tokens [ 116 ] = TOKEN_IDENTIFIER ; tokens [ 117 ] = 6 ; tokens [ 118 ] = 4 ; tokens [ 119 ] = 25 ;
tokens [ 120 ] = TOKEN_RIGHT_BRACKET ; tokens [ 121 ] = 0 ; tokens [ 122 ] = 4 ; tokens [ 123 ] = 27 ;
tokens [ 124 ] = TOKEN_PLUS ; tokens [ 125 ] = 0 ; tokens [ 126 ] = 4 ; tokens [ 127 ] = 29 ;
tokens [ 128 ] = TOKEN_IDENTIFIER ; tokens [ 129 ] = 7 ; tokens [ 130 ] = 4 ; tokens [ 131 ] = 31 ;
tokens [ 132 ] = TOKEN_LEFT_BRACKET ; tokens [ 133 ] = 0 ; tokens [ 134 ] = 4 ; tokens [ 135 ] = 33 ;
tokens [ 136 ] = TOKEN_IDENTIFIER ; tokens [ 137 ] = 8 ; tokens [ 138 ] = 4 ; tokens [ 139 ] = 35 ;
tokens [ 140 ] = TOKEN_PLUS ; tokens [ 141 ] = 0 ; tokens [ 142 ] = 4 ; tokens [ 143 ] = 37 ;
tokens [ 144 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 145 ] = 1 ; tokens [ 146 ] = 4 ; tokens [ 147 ] = 39 ;
tokens [ 148 ] = TOKEN_RIGHT_BRACKET ; tokens [ 149 ] = 0 ; tokens [ 150 ] = 4 ; tokens [ 151 ] = 41 ;
tokens [ 152 ] = TOKEN_SEMICOLON ; tokens [ 153 ] = 0 ; tokens [ 154 ] = 4 ; tokens [ 155 ] = 42 ;
tokens [ 156 ] = TOKEN_IDENTIFIER ; tokens [ 157 ] = 9 ; tokens [ 158 ] = 5 ; tokens [ 159 ] = 1 ;
tokens [ 160 ] = TOKEN_LEFT_BRACKET ; tokens [ 161 ] = 0 ; tokens [ 162 ] = 5 ; tokens [ 163 ] = 3 ;
tokens [ 164 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 165 ] = 0 ; tokens [ 166 ] = 5 ; tokens [ 167 ] = 5 ;
tokens [ 168 ] = TOKEN_RIGHT_BRACKET ; tokens [ 169 ] = 0 ; tokens [ 170 ] = 5 ; tokens [ 171 ] = 7 ;
tokens [ 172 ] = TOKEN_ASSIGNMENT ; tokens [ 173 ] = 0 ; tokens [ 174 ] = 5 ; tokens [ 175 ] = 9 ;
tokens [ 176 ] = TOKEN_IDENTIFIER ; tokens [ 177 ] = 10 ; tokens [ 178 ] = 5 ; tokens [ 179 ] = 11 ;
tokens [ 180 ] = TOKEN_LEFT_BRACKET ; tokens [ 181 ] = 0 ; tokens [ 182 ] = 5 ; tokens [ 183 ] = 13 ;
tokens [ 184 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 185 ] = 1 ; tokens [ 186 ] = 5 ; tokens [ 187 ] = 15 ;
tokens [ 188 ] = TOKEN_RIGHT_BRACKET ; tokens [ 189 ] = 0 ; tokens [ 190 ] = 5 ; tokens [ 191 ] = 17 ;
tokens [ 192 ] = TOKEN_PLUS ; tokens [ 193 ] = 0 ; tokens [ 194 ] = 5 ; tokens [ 195 ] = 19 ;
tokens [ 196 ] = TOKEN_IDENTIFIER ; tokens [ 197 ] = 11 ; tokens [ 198 ] = 5 ; tokens [ 199 ] = 21 ;
tokens [ 200 ] = TOKEN_LEFT_BRACKET ; tokens [ 201 ] = 0 ; tokens [ 202 ] = 5 ; tokens [ 203 ] = 23 ;
tokens [ 204 ] = TOKEN_IDENTIFIER ; tokens [ 205 ] = 12 ; tokens [ 206 ] = 5 ; tokens [ 207 ] = 25 ;
tokens [ 208 ] = TOKEN_RIGHT_BRACKET ; tokens [ 209 ] = 0 ; tokens [ 210 ] = 5 ; tokens [ 211 ] = 27 ;
tokens [ 212 ] = TOKEN_PLUS ; tokens [ 213 ] = 0 ; tokens [ 214 ] = 5 ; tokens [ 215 ] = 29 ;
tokens [ 216 ] = TOKEN_IDENTIFIER ; tokens [ 217 ] = 13 ; tokens [ 218 ] = 5 ; tokens [ 219 ] = 31 ;
tokens [ 220 ] = TOKEN_LEFT_BRACKET ; tokens [ 221 ] = 0 ; tokens [ 222 ] = 5 ; tokens [ 223 ] = 33 ;
tokens [ 224 ] = TOKEN_IDENTIFIER ; tokens [ 225 ] = 14 ; tokens [ 226 ] = 5 ; tokens [ 227 ] = 35 ;
tokens [ 228 ] = TOKEN_PLUS ; tokens [ 229 ] = 0 ; tokens [ 230 ] = 5 ; tokens [ 231 ] = 37 ;
tokens [ 232 ] = TOKEN_CONSTANT_INTEGER ; tokens [ 233 ] = 1 ; tokens [ 234 ] = 5 ; tokens [ 235 ] = 39 ;
tokens [ 236 ] = TOKEN_RIGHT_BRACKET ; tokens [ 237 ] = 0 ; tokens [ 238 ] = 5 ; tokens [ 239 ] = 41 ;
tokens [ 240 ] = TOKEN_SEMICOLON ; tokens [ 241 ] = 0 ; tokens [ 242 ] = 5 ; tokens [ 243 ] = 42 ;
tokenCount = 244 ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; b
`
stringToPush [ 0 ] = 98 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; c
`
stringToPush [ 0 ] = 99 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; c
`
stringToPush [ 0 ] = 99 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; a
`
stringToPush [ 0 ] = 97 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; c
`
stringToPush [ 0 ] = 99 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; b
`
stringToPush [ 0 ] = 98 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; b
`
stringToPush [ 0 ] = 98 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; b
`
stringToPush [ 0 ] = 98 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; c
`
stringToPush [ 0 ] = 99 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; b
`
stringToPush [ 0 ] = 98 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

` ; c
`
stringToPush [ 0 ] = 99 ;
stringToPush [ 1 ] = 0 ;
_ = pushString ( ) ;

i = 0 ;

uint64 errorAtLine = 0 ;
uint64 errorAtColumn = 0 ;
proc consumeToken ( )
    if currentToken == [expectedToken] then
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
        i = i + tokenSize ;
        nextToken = tokens [ i ] ;
        i = i - tokenSize ;
    else 
        _ = i + 2 ;
        errorAtLine = tokens [ _ ] ;
        _ = i + 3 ;
        errorAtColumn = tokens [ _ ] ;
        `
        printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
        printf(`"expected token %d but got %d\n"`, [expectedToken], [currentToken])
        ExitProcess(1) `
    end
endproc consumeToken

proc indentifierRedeclared ( namePointer )
    _ = i - tokenSize ;
    _ = _ + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i - tokenSize ;
    _ = _ + 3 ;
    errorAtColumn = tokens [ _ ] ;
    _ = readString ( namePointer ) ; ` 
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"identifier redeclared: %s\n"`, stringAtPointer) ;
    ExitProcess(1)`
endproc indentifierRedeclared

proc identifierUnknown ( namePointer )
    _ = i - tokenSize ;
    _ = _ + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i - tokenSize ;
    _ = _ + 3 ;
    errorAtColumn = tokens [ _ ] ;
    _ = readString ( namePointer ) ; ` 
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"unknown identifier: %s\n"`, stringAtPointer) ;
    ExitProcess(1)`
endproc identifierUnknown

proc unexpectedToken ( ) 
    _ = i + 2 ;
    errorAtLine = tokens [ _ ] ;
    _ = i + 3 ;
    errorAtColumn = tokens [ _ ] ;
    `
    printf(`"parser.strata:%d:%d: "`, [errorAtLine], [errorAtColumn])
    printf(`"unexpected token %d\n"`, [currentToken])
    ExitProcess(1)`
endproc unexpectedToken

proc parseNumber ( )
    expectedToken = TOKEN_CONSTANT_INTEGER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    printf(`"[Trace] Number: %d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseNumber

proc parseIdentifier ( )
    expectedToken = TOKEN_IDENTIFIER ;
    _ = i + 1 ;
    _ = tokens [ _ ] ;
    consumeToken ( ) ; `
    printf(`"[Trace] Identifier: #%d\n"`, [_])
    ; set result
    mov rax, [_]`
endproc parseIdentifier

proc parseType ( )
    if currentToken == [TOKEN_UINT8] then
        _ = TYPE_UINT8 ;
         i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else if currentToken == [TOKEN_UINT64] then
        _ = TYPE_UINT64 ;
        i = i + tokenSize ;
        currentToken = tokens [ i ] ;
    else
        unexpectedToken ( ) ;
    end end 
    `
    ; set result
    mov rax, [_]`
endproc parseType

proc parseArrayDeclaration ( )
    expectedToken = TOKEN_LEFT_BRACKET ;
    consumeToken ( ) ;

    gvValue = parseNumber ( ) ;

    expectedToken = TOKEN_RIGHT_BRACKET ;
    consumeToken ( ) ;

    gvNamePointer = parseIdentifier ( ) ;

    gvSubType = gvType ;
    gvType = TYPE_ARRAY ;

    `
    printf(`"[Trace] Array declaration: type %d, subtype %d\n"`, [gvType], [gvSubType])
    `
    _ = addGlobalVariable ( gvType gvSubType gvNamePointer gvValue ) ;
    _ = addGlobalSymbol ( gvType gvSubType gvNamePointer gvValue ) ; `
    printf(`"[Trace] Array declaration: type %d, value %d\n"`, [gvType], [gvValue])`
endproc parseArrayDeclaration

proc parseIntegerDeclaration ( )
    gvNamePointer = parseIdentifier ( ) ;

    fgsIndex = findGlobalSymbol ( gvNamePointer ) ;

    if fgsIndex != -1 then
        _ = indentifierRedeclared ( gvNamePointer ) ;
    end

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    gvValue = parseNumber ( ) ;
    
    _ = addGlobalVariable ( gvType 0 gvNamePointer gvValue ) ;
    _ = addGlobalSymbol ( gvType 0 gvNamePointer 0 ) ; `
    printf(`"[Trace] Variable declaration: type %d, value %d\n"`, [gvType], [gvValue])`
endproc parseIntegerDeclaration 
    

proc parseVariableDeclaration ( )
    gvType = parseType ( ) ;

    if currentToken == [TOKEN_LEFT_BRACKET] then
        parseArrayDeclaration ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        parseIntegerDeclaration ( ) ;
    else
        unexpectedToken ( ) ;
    end end

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 
endproc parseVariableDeclaration

proc forward parseAdditiveExpression
proc forward parseStatements
proc forward parseArrayAccess

uint64 fpIdentifier = 0 ;
proc parseFactor ( ) 
    if currentToken == [TOKEN_CONSTANT_INTEGER] then
        _ = parseNumber ( ) ; `
        printf(`"\tpush %d\n"`, [_])`
    else if currentToken == [TOKEN_LEFT_PARENTHESIS] then
        expectedToken = TOKEN_LEFT_PARENTHESIS ;
        consumeToken ( ) ;

        parseAdditiveExpression ( ) ;
 
        expectedToken = TOKEN_RIGHT_PARENTHESIS ;
        consumeToken ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        if nextToken == [TOKEN_LEFT_BRACKET] then 
            fpIdentifier = parseArrayAccess ( ) ; 
            
            fgsIndex = findGlobalSymbol ( fpIdentifier ) ;

            if fgsIndex == -1 then
                _ = identifierUnknown ( fpIdentifier ) ;
            end 
           
            _ = readString ( fpIdentifier ) ; 

            if gsSubType == [TYPE_UINT8] then `
                printf(`"\tpop rax\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush [rax]\n"`, stringAtPointer)`
            else if gsSubType == [TYPE_UINT64] then `
                printf(`"\tpop rax\n\tmov rbx, %s\n\tshl rax, 3\n\tadd rax, rbx\n\tpush [rax]\n"`, stringAtPointer)`
            else ` 
                printf(`"[Error] Error: unknown array type %d\n"`, [gsSubType])
                ExitProcess(1)`
            end end `
            printf(`"[Trace] Factor: array\n"`)`
        else
            _ = i + 1 ;
            _ = tokens [ _ ] ;
            `
            printf(`"[Trace] Factor: variable #%d\n"`, [_])
            `

            fpIdentifier = parseIdentifier ( ) ;

            fgsIndex = findGlobalSymbol ( fpIdentifier ) ;

            if fgsIndex == -1 then
                _ = identifierUnknown ( fpIdentifier ) ;
            end 

            _ = readString ( fpIdentifier ) ; 

            if gsType == [TYPE_UINT8] then ` 
                printf(`"\tpush byte [%s]\n"`, stringAtPointer)`
            else if gsType == [TYPE_UINT64] then ` 
                printf(`"\tpush qword [%s]\n"`, stringAtPointer)`
            else ` 
                printf(`"[Error] Error: unknown type %d\n"`, [gsType])
                ExitProcess(1)`
            end end
        end
    else
        unexpectedToken ( ) ;
    end end end
endproc parseFactor

proc parseMultiplicativeExpression ( ) 
    parseFactor ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_MULTIPLY] then
            expectedToken = TOKEN_MULTIPLY ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] MULTIPLY *\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tmul rbx\n\tpush rax\n"`)`
        else if currentToken == [TOKEN_DIVIDE] then
            expectedToken = TOKEN_DIVIDE ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] DIVIDE /\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tdiv rbx\n\tpush rax\n"`)`
        else if currentToken == [TOKEN_MODULO] then
            expectedToken = TOKEN_MODULO ;
            consumeToken ( ) ;
            parseFactor ( ) ; `
            printf(`"[Trace] MODULO %%\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tdiv rbx\n\tpush rdx\n"`)`
        else
            break 
        end end end
    end
endproc parseMultiplicativeExpression

proc parseAdditiveExpression ( ) 
    parseMultiplicativeExpression ( ) ; 
    while true == 1 do 
        if currentToken == [TOKEN_PLUS] then
            expectedToken = TOKEN_PLUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            printf(`"[Trace] PLUS +\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tadd rax, rbx\n\tpush rax\n"`)`
        else if currentToken == [TOKEN_MINUS] then
            expectedToken = TOKEN_MINUS ;
            consumeToken ( ) ;
            parseMultiplicativeExpression ( ) ; `
            printf(`"[Trace] MINUS -\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tsub rax, rbx\n\tpush rax\n"`)`
        else
            break ;
        end end
    end
endproc parseAdditiveExpression 

uint64 preIndex = 0 ;
proc parseRelationalExpression ( )
    parseAdditiveExpression ( ) ;
    if currentToken == [TOKEN_LESS_THAN] then
        expectedToken = TOKEN_LESS_THAN ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] LESS_THAN <\n"`)
        printf(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjl .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        printf(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_LESS_THAN_OR_EQUAL_TO] then
        expectedToken = TOKEN_LESS_THAN_OR_EQUAL_TO ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] LESS_THAN_OR_EQUAL_TO <=\n"`)
        printf(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjle .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        printf(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_GREATER_THAN] then
        expectedToken = TOKEN_GREATER_THAN ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] GREATER_THAN >\n"`)
        printf(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjg .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        printf(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_GREATER_THAN_OR_EQUAL_TO] then
        expectedToken = TOKEN_GREATER_THAN_OR_EQUAL_TO ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] GREATER_THAN_OR_EQUAL_TO >=\n"`)
        printf(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjge .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        printf(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_EQUALS] then 
        expectedToken = TOKEN_EQUALS ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] EQUALS ==\n"`)
        printf(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tje .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        printf(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    else if currentToken == [TOKEN_NOT_EQUALS] then
        expectedToken = TOKEN_NOT_EQUALS ;
        consumeToken ( ) ;
        parseAdditiveExpression ( ) ; `
        printf(`"[Trace] NOT_EQUALS !=\n"`)
        printf(`"\tpop rbx\n\tpop rax\n\tcmp rax, rbx\n\tjne .true_%d\n\tpush 0\n\tjmp .end_%d\n"`, [preIndex], [preIndex])
        printf(`".true_%d:\n\tpush 1\n.end_%d:\n"`, [preIndex], [preIndex])
        `
        preIndex = preIndex + 1 ;
    end end end end end end
endproc parseRelationalExpression

proc parseLogicalAndExpression ( )
    parseRelationalExpression ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_LOGICAL_AND] then
            expectedToken = TOKEN_LOGICAL_AND ;
            consumeToken ( ) ;
            parseRelationalExpression ( ) ; `
            printf(`"[Trace] LOGICAL_AND &&\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tand rax, rbx\n\tpush rax\n"`)`
        else
            break ;
        end
    end
endproc parseLogicalAndExpression

proc parseLogicalOrExpression ( )
    parseLogicalAndExpression ( ) ;
    while true == 1 do 
        if currentToken == [TOKEN_LOGICAL_OR] then
            expectedToken = TOKEN_LOGICAL_OR ;
            consumeToken ( ) ;
            parseLogicalAndExpression ( ) ; `
            printf(`"[Trace] LOGICAL_OR ||\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tor rax, rbx\n\tpush rax\n"`)`
        else
            break ;
        end
    end
endproc parseLogicalOrExpression

uint64 paaIdentifier = 0 ;
proc parseArrayAccess ( ) 
    paaIdentifier = parseIdentifier ( ) ; 
    expectedToken = TOKEN_LEFT_BRACKET ;
    consumeToken ( ) ;
    parseAdditiveExpression ( ) ;
    expectedToken = TOKEN_RIGHT_BRACKET ;
    consumeToken ( ) ; `
    mov rax, [paaIdentifier]`
endproc parseArrayAccess

uint64 paIdentifier = 0 ;
proc parseAssignable ( )
    if nextToken == [TOKEN_LEFT_BRACKET] then 
        paIdentifier = parseArrayAccess ( ) ; 

        fgsIndex = findGlobalSymbol ( paIdentifier ) ;

        if fgsIndex == -1 then
            _ = identifierUnknown ( paIdentifier ) ;
        end 
        _ = readString ( paIdentifier ) ; 

        if gsSubType == [TYPE_UINT8] then `
            printf(`"\tpop rax\n\tmov rbx, %s\n\tadd rax, rbx\n\tpush rax\n"`, stringAtPointer)`
        else if gsSubType == [TYPE_UINT64] then `
            printf(`"\tpop rax\n\tmov rbx, %s\n\tshl rax, 3\n\tadd rax, rbx\n\tpush rax\n"`, stringAtPointer)`
        else ` 
            printf(`"[Error] Error: unknown array type %d\n"`, [gsSubType])
            ExitProcess(1)`
        end end `
        printf(`"[Trace] Assignable: array, ct %d\n"`, [currentToken])`
    else
        paIdentifier = parseIdentifier ( ) ; 
        
        fgsIndex = findGlobalSymbol ( paIdentifier ) ;

        if fgsIndex == -1 then
            _ = identifierUnknown ( paIdentifier ) ;
        end `
        printf(`"[Trace] Assignable: variable\n"`)`
    end `
    mov rax, [paIdentifier]`
endproc parseAssignable

uint64 pasIdentifier = 0 ;
proc parseAssignmentStatement ( )
    pasIdentifier = parseAssignable ( ) ;

    expectedToken = TOKEN_ASSIGNMENT ;
    consumeToken ( ) ;

    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; 

    fgsIndex = findGlobalSymbol ( pasIdentifier ) ;

    if fgsIndex == -1 then
        _ = identifierUnknown ( pasIdentifier ) ;
    end
    _ = readString ( pasIdentifier ) ;
    
    if gsType == [TYPE_UINT8] then `
        printf(`"[Debug] Assigning value to a uint8\n"`)
        printf(`"\tpop rax\n\tmov byte [%s], al\n"`, stringAtPointer)`
    else if gsType == [TYPE_UINT64] then `
        printf(`"[Debug] Assigning value to a uint64\n"`)
        printf(`"\tpop rax\n\tmov qword [%s], rax\n"`, stringAtPointer)`
    else if gsType == [TYPE_ARRAY] then
        if gsSubType == [TYPE_UINT8] then `
            printf(`"[Debug] Assigning value to an array of uint8\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tmov byte [rax], bl\n"`, stringAtPointer)`
        else if gsSubType == [TYPE_UINT64] then `
            printf(`"[Debug] Assigning value to an array of uint64\n"`)
            printf(`"\tpop rbx\n\tpop rax\n\tmov qword [rax], rbx\n"`, stringAtPointer)`
        else ` 
            printf(`"[Error] Error: unknown array type %d\n"`, [gsType])
            ExitProcess(1)`
        end end
    else `
        printf(`"[Error] Error: unknown type %d\n"`, [gsType])
        ExitProcess(1)`
    end end end `
    printf(`"[Trace] Assignment statement for: '%s'\n"`, stringAtPointer)`
endproc parseAssignmentStatement

proc parseIfStatement ( )
    expectedToken = TOKEN_IF ;
    consumeToken ( ) ; `
    printf(`"[Trace] If statement: IF\n"`)
    `

    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_THEN ;
    consumeToken ( ) ;
    `
    printf(`"[Trace] If statement: THEN\n"`)
    `
    parseStatements ( ) ;

    while true == 1 do
        if currentToken == [TOKEN_ELSE] then 
            expectedToken = TOKEN_ELSE ;
            consumeToken ( ) ; 
            `
            printf(`"[Trace] If statement: ELSE\n"`)
            `
            if currentToken == [TOKEN_IF] then
                expectedToken = TOKEN_IF ;
                consumeToken ( ) ; `
                printf(`"[Trace] If statement: IF\n"`)
                `
                parseLogicalOrExpression ( ) ;

                expectedToken = TOKEN_THEN ;
                consumeToken ( ) ; `
                printf(`"[Trace] If statement: THEN\n"`)
                `
            end
            parseStatements ( ) ; 
        else 
            break ;
        end 
    end

    expectedToken = TOKEN_END ;
    consumeToken ( ) ; `
    printf(`"[Trace] If statement: END\n"`)`
endproc parseIfStatement

proc parseWhileStatement ( )
    expectedToken = TOKEN_WHILE ;
    consumeToken ( ) ; `
    printf(`"[Trace] While statement: WHILE\n"`)
    `
    parseLogicalOrExpression ( ) ;

    expectedToken = TOKEN_DO ;
    consumeToken ( ) ; `
    printf(`"[Trace] While statement: DO\n"`)
    `
    parseStatements ( ) ;

    expectedToken = TOKEN_END ;
    consumeToken ( ) ; `
    printf(`"[Trace] While statement: END\n"`)`
endproc parseWhileStatement

proc parseBreakStatement ( )
    expectedToken = TOKEN_BREAK ;
    consumeToken ( ) ; 
    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    printf(`"[Trace] Break statement: BREAK\n"`)`
endproc parseBreakStatement

proc parseContinueStatement ( )
    expectedToken = TOKEN_CONTINUE ;
    consumeToken ( ) ;
    expectedToken = TOKEN_SEMICOLON ;
    consumeToken ( ) ; `
    printf(`"[Trace] Continue statement: CONTINUE\n"`)`
endproc parseContinueStatement

proc parseStatement ( )
    if currentToken == [TOKEN_UINT64] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_UINT8] then
        parseVariableDeclaration ( ) ;
    else if currentToken == [TOKEN_IDENTIFIER] then
        parseAssignmentStatement ( ) ;
    else if currentToken == [TOKEN_IF] then
        parseIfStatement ( ) ;
    else if currentToken == [TOKEN_WHILE] then
        parseWhileStatement ( ) ;
    else if currentToken == [TOKEN_BREAK] then
        parseBreakStatement ( ) ;
    else if currentToken == [TOKEN_CONTINUE] then
        parseContinueStatement ( ) ;
    else
        unexpectedToken ( ) ;
    end end end end end end end
endproc parseStatement

proc parseStatements ( )
    while true == 1 do 
        if currentToken == [TOKEN_END] then
            break ;
        else if currentToken == [TOKEN_ELSE] then
            break ;
        else
            parseStatement ( ) ;
        end end
    end
endproc parseStatements

i = 0 ;

while i < [tokenCount] do
    currentToken = tokens [ i ] ;
    parseStatement ( ) ;
end

i = 0 ;

while i < [globalVariableCount] do
    _ = gvTypeOffset + i * globalVariableSize ;
    gvType = globalVariables [ _ ] ;
    _ = gvSubTypeOffset + i * globalVariableSize ;
    gvSubType = globalVariables [ _ ] ;
    _ = gvNameOffset + i * globalVariableSize ;
    gvNamePointer = globalVariables [ _ ] ;
    _ = gvValueOffset + i * globalVariableSize ;
    gvValue = globalVariables [ _ ] ;
    _ = readString ( gvNamePointer ) ; 
    
    if gvType == [TYPE_UINT8] then `
        printf(`"section .data\r\n\t%s db %d\n"`, stringAtPointer, [gvValue])`
    else if gvType == [TYPE_UINT64] then `
        printf(`"section .data\r\n\t%s dq %d\n"`, stringAtPointer, [gvValue])`
    else if gvType == [TYPE_ARRAY] then 
        if gvSubType == [TYPE_UINT8] then `
            printf(`"section .bss\r\n\t%s resb %d\n"`, stringAtPointer, [gvValue])`
        else if gvSubType == [TYPE_UINT64] then `
            printf(`"section .bss\r\n\t%s resq %d\n"`, stringAtPointer, [gvValue])`
        else `
            printf(`"Error: unknown array type %d\n"`, [gvType])
            ExitProcess(1)`
        end end
    else `
        printf(`"Error: unknown type %d\n"`, [gvType])
        ExitProcess(1)`
    end end end

    i = i + 1 ;
end

`
ExitProcess(0)
`