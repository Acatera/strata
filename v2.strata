extern proc GetStdHandle(uint64 nStdHandle) -> uint64;
extern proc WriteConsoleA(pointer hConsoleOutput, pointer lpBuffer, uint64 nNumberOfCharsToWrite, pointer lpNumberOfCharsWritten) -> uint64;
extern proc GetProcessHeap() -> pointer;
extern proc HeapAlloc(uint64 hHeap, uint64 flags, uint64 size) -> pointer;
extern proc GetLastError() -> uint64;
extern proc CreateFileA(pointer lpFileName, uint64 dwDesiredAccess, uint64 dwShareMode, pointer lpSecurityAttributes, uint64 dwCreationDisposition, uint64 dwFlagsAndAttributes, pointer hTemplateFile) -> pointer;
extern proc GetFileSizeEx(pointer hFile, pointer lpFileSize) -> uint64;
extern proc ReadFile(pointer hFile, pointer lpBuffer, uint64 nNumberOfBytesToRead, pointer lpNumberOfBytesRead, pointer lpOverlapped) -> uint64;
extern proc WriteFile(pointer hFile, pointer lpBuffer, uint64 nNumberOfBytesToWrite, pointer lpNumberOfBytesWritten, pointer lpOverlapped) -> uint64;

@define DEBUG 0
@define DEBUG_LEXER 0

@define STD_OUTPUT_HANDLE 0xFFFFFFF5
@define NULL 0

@define false 0
@define true 1

@define GENERIC_READ 0x80000000
@define GENERIC_WRITE 0x40000000

@define FILE_SHARE_READ 0x00000001
@define FILE_SHARE_WRITE 0x00000002

@define CREATE_ALWAYS 0x00000002
@define OPEN_EXISTING 0x00000003

@define FILE_ATTRIBUTE_NORMAL 0x00000080

uint64 NOT_FOUND = 0;
NOT_FOUND = 0 - 1;

uint64 std_handle = GetStdHandle(STD_OUTPUT_HANDLE);

uint8* _sl_ptr = 0;
proc string_length(pointer str) -> uint64
vars
    uint64 length = 0;
code
    _sl_ptr = str;
    length = 0;
    while *_sl_ptr != 0 do
        _sl_ptr++;
        length++;
    end
    return length;
end

proc print_nstring(pointer text, uint64 len)
code
    WriteConsoleA(std_handle, text, len, NULL);
end

proc print_string(pointer text)
vars
    uint64 ps_len = 0;
code
    ps_len = string_length(text);
    print_nstring(text, ps_len);
end

proc debug_string(pointer text)
vars
    uint64 ds_length = 0;
code
    if DEBUG then
        ds_length = string_length(text);
        print_nstring(text, ds_length);
    end
end

proc debug_nstring(pointer text, uint64 len)
code
    if DEBUG then
        print_nstring(text, len);
    end
end

uint8[] input_file = "v3.strata";

uint64 input_file_handle = CreateFileA(input_file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if input_file_handle < 0 then
    print_string("Failed to open file\n");
    exit(1);
end

uint64 file_size = 0;
if GetFileSizeEx(input_file_handle, &file_size) != true then
    print_string("Failed to get file size\n");
    exit(1);
end

uint64 heap = GetProcessHeap();
if heap == NULL then
    print_string("Failed to get heap\n");
    exit(1);
end

uint8* file_contents = HeapAlloc(heap, 0, file_size);
if file_contents == NULL then
    print_string("Failed to allocate memory\n");
    exit(1);
end

uint64 bytes_read = 0;
if ReadFile(input_file_handle, file_contents, file_size, &bytes_read, NULL) != true then
    print_string("Failed to read file\n");
    exit(1);
end

uint8[256] buffer;
uint8* buffer_ptr = &buffer;
uint64 buffer_size = 0;
uint8* str_number = 0;

proc to_string(uint64 value) -> uint64
vars
    uint64 val = 0;
    uint64 ts_negative = 0;
code
    val = value;
    ts_negative = 0;
    if val < 0 then
        ts_negative = 1;
        val = 0 - val;
    end

    if val == 0 then
        buffer_ptr = &buffer + buffer_size;
        buffer_ptr = buffer_ptr - 1;
        *buffer_ptr = 48;
        return buffer_ptr;
    end

    buffer_ptr = &buffer + buffer_size;
    while val != 0 do
        buffer_ptr = buffer_ptr - 1;
        *buffer_ptr = val % 10 + 48;
        val = val / 10;
    end

    if ts_negative then
        buffer_ptr = buffer_ptr - 1;
        *buffer_ptr = '-';
    end

    return buffer_ptr;
end

uint8* tn_ptr = 0;
proc to_number(pointer text, uint64 length) -> uint64
vars
    uint64 _tn_i = 0;
    uint64 _tn_number = 0;
code
    tn_ptr = text;
    _tn_i = 0;
    _tn_number = 0;
    while _tn_i < length do
        _tn_number = _tn_number * 10 + *tn_ptr - '0';
        _tn_i++;
        tn_ptr++;
    end
    return _tn_number;
end



uint8* snc_a_ptr = 0;
uint8* snc_b_ptr = 0;
proc string_compare(pointer a, pointer b, uint64 len_a, uint64 len_b) -> uint64
vars
    uint64 i = 0;
code
    snc_a_ptr = a;
    snc_b_ptr = b;

    if len_a != len_b then
        return false;
    end

    i = 0;
    while i < len_a do
        if *snc_a_ptr != *snc_b_ptr then
            return false;
        end
        snc_a_ptr++;
        snc_b_ptr++;
        i++;
    end

    return true;
end

enum TokenType
    TOKEN_UINT8 = 1,
    TOKEN_UINT16,
    TOKEN_UINT32,
    TOKEN_UINT64,
    TOKEN_INT8,
    TOKEN_INT16,
    TOKEN_INT32,
    TOKEN_INT64,
    TOKEN_BOOL,
    TOKEN_IDENTIFIER,
    TOKEN_OPEN_PAREN,
    TOKEN_CLOSE_PAREN,
    TOKEN_OPEN_BRACKET,
    TOKEN_CLOSE_BRACKET,
    TOKEN_COMMA,
    TOKEN_DOT,
    TOKEN_SEMICOLON,
    TOKEN_AT,
    TOKEN_AMPERSAND,
    TOKEN_LITERAL_INT,
    TOKEN_LITERAL_STRING,
    TOKEN_LITERAL_CHAR,
    TOKEN_ASSIGNMENT,
    TOKEN_EQUALS,
    TOKEN_NOT,
    TOKEN_NOT_EQUALS,
    TOKEN_PLUS,
    TOKEN_PLUS_EQUALS,
    TOKEN_INCREMENT,
    TOKEN_MINUS,
    TOKEN_MINUS_EQUALS,
    TOKEN_ARROW,
    TOKEN_DECREMENT,
    TOKEN_MULTIPLY,
    TOKEN_MULTIPLY_EQUALS,
    TOKEN_DIVIDE,
    TOKEN_DIVIDE_EQUALS,
    TOKEN_MODULO,
    TOKEN_MODULO_EQUALS,
    TOKEN_LESS_THAN,
    TOKEN_LESS_THAN_EQUALS,
    TOKEN_GREATER_THAN,
    TOKEN_GREATER_THAN_EQUALS,
    TOKEN_LSHIFT,
    TOKEN_RSHIFT,
    TOKEN_PROC_DECL,
    TOKEN_END,
    TOKEN_ASSERT,
end

struct Keyword
    uint64 type;
    uint64 length;
    pointer text;
    pointer human_readable_text;
    uint64 human_readable_length;
end


@define KEYWORD_COUNT 100
Keyword[KEYWORD_COUNT] keywords;
uint64 keyword_count = 0;

proc add_keyword(uint64 type, pointer text, uint64 length, pointer human_readable_text)
code
    if keyword_count >= KEYWORD_COUNT then
        print_string("Keyword count exceeded\n");
        exit(1);
    end

    keywords[keyword_count].type = type;
    keywords[keyword_count].text = text;
    keywords[keyword_count].length = length;
    keywords[keyword_count].human_readable_text = human_readable_text;
    keywords[keyword_count].human_readable_length = string_length(human_readable_text);
    keyword_count++;
end

@define TOKEN_COUNT 100000
struct Token
    uint64 type;
    uint64 line;
    uint64 column;
    uint64 length;
    pointer text;
end

Token[TOKEN_COUNT] tokens;
uint64 token_count = 0;

uint64 line = 1;
uint64 column = 1;

proc is_whitespace(uint8 c) -> uint64
code
    return c == ' ' or c == '\n' or c == '\r' or c == '\t';
end

proc is_alpha(uint8 c) -> uint64
vars
    uint64 _is_lowercase = 0;
    uint64 _is_uppercase = 0;
code
    _is_lowercase = c >= 'a' and c <= 'z';
    _is_uppercase = c >= 'A' and c <= 'Z';
    return _is_lowercase or _is_uppercase or c == '_';
end

proc is_digit(uint8 c) -> uint64
code
    return c >= '0' and c <= '9';
end

proc is_hex_digit(uint8 c) -> uint64
vars
    uint64 _is_lowercase = 0;
    uint64 _is_uppercase = 0;
code
    _is_lowercase = c >= 'a' and c <= 'f';
    _is_uppercase = c >= 'A' and c <= 'F';
    return is_digit(c) or _is_lowercase or _is_uppercase;
end

proc is_alphanumeric(uint8 c) -> uint64
code
    return is_alpha(c) or is_digit(c);
end

proc is_delimiter(uint8 c) -> uint64
code
    return  c == '(' or c == ')' or
            c == '[' or c == ']' or
            c == ',' or c == '.' or
            c == ';' or c == '@' or
            c == '&';
end

uint64 i = 0;

proc print_token_type(uint64 type)
vars
    uint64 _ptt_i = 0;
code
    _ptt_i = 0;
    while _ptt_i < keyword_count do
        if type == keywords[_ptt_i].type then
            print_nstring(keywords[_ptt_i].human_readable_text, keywords[_ptt_i].human_readable_length);
            return;
        end
        _ptt_i++;
    end
end

proc get_identifier_type(pointer text, uint64 length) -> uint64
vars
    uint64 _git_i = 0;
code
    _git_i = 0;
    while _git_i < keyword_count do
        if string_compare(text, keywords[_git_i].text, length, keywords[_git_i].length) then
            return keywords[_git_i].type;
        end
        _git_i++;
    end
    return TOKEN_IDENTIFIER;
end

proc get_symbol_type(uint64 symbol) -> uint64
vars
    uint8 _symbol = 0;
code
    _symbol = symbol;
    if _symbol == '(' then
        return TOKEN_OPEN_PAREN;
    else if _symbol == ')' then
        return TOKEN_CLOSE_PAREN;
    else if _symbol == '[' then
        return TOKEN_OPEN_BRACKET;
    else if _symbol == ']' then
        return TOKEN_CLOSE_BRACKET;
    else if _symbol == ',' then
        return TOKEN_COMMA;
    else if _symbol == '.' then
        return TOKEN_DOT;
    else if _symbol == ';' then
        return TOKEN_SEMICOLON;
    else if _symbol == '@' then
        return TOKEN_AT;
    else if _symbol == '&' then
        return TOKEN_AMPERSAND;
    else
        print_string("Unknown symbol: '");
        str_number = to_string(_symbol);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("'\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end end end end end end
end

// Data types
add_keyword(TOKEN_UINT8,  "uint8",  5, "TOKEN_TYPE_UINT8");
add_keyword(TOKEN_UINT16, "uint16", 6, "TOKEN_TYPE_UINT16");
add_keyword(TOKEN_UINT32, "uint32", 6, "TOKEN_TYPE_UINT32");
add_keyword(TOKEN_UINT64, "uint64", 6, "TOKEN_TYPE_UINT64");
add_keyword(TOKEN_INT8,   "int8",   4, "TOKEN_TYPE_INT8");
add_keyword(TOKEN_INT16,  "int16",  5, "TOKEN_TYPE_INT16");
add_keyword(TOKEN_INT32,  "int32",  5, "TOKEN_TYPE_INT32");
add_keyword(TOKEN_INT64,  "int64",  5, "TOKEN_TYPE_INT64");
add_keyword(TOKEN_BOOL,   "bool",   4, "TOKEN_TYPE_BOOL");

add_keyword(TOKEN_IDENTIFIER, NULL, NULL, "TOKEN_TYPE_IDENTIFIER");

// Symbols
add_keyword(TOKEN_OPEN_PAREN,    NULL, NULL, "TOKEN_TYPE_OPEN_PAREN");
add_keyword(TOKEN_CLOSE_PAREN,   NULL, NULL, "TOKEN_TYPE_CLOSE_PAREN");
add_keyword(TOKEN_OPEN_BRACKET,  NULL, NULL, "TOKEN_TYPE_OPEN_BRACKET");
add_keyword(TOKEN_CLOSE_BRACKET, NULL, NULL, "TOKEN_TYPE_CLOSE_BRACKET");
add_keyword(TOKEN_COMMA,         NULL, NULL, "TOKEN_TYPE_COMMA");
add_keyword(TOKEN_DOT,           NULL, NULL, "TOKEN_TYPE_DOT");
add_keyword(TOKEN_SEMICOLON,     NULL, NULL, "TOKEN_TYPE_SEMICOLON");
add_keyword(TOKEN_AT,            NULL, NULL, "TOKEN_TYPE_AT");
add_keyword(TOKEN_AMPERSAND,     NULL, NULL, "TOKEN_TYPE_AMPERSAND");

// Logical operators
add_keyword(TOKEN_ASSIGNMENT, NULL, NULL, "TOKEN_TYPE_ASSIGNMENT");
add_keyword(TOKEN_EQUALS,     NULL, NULL, "TOKEN_TYPE_EQUALS");
add_keyword(TOKEN_NOT,        NULL, NULL, "TOKEN_TYPE_NOT");
add_keyword(TOKEN_NOT_EQUALS, NULL, NULL, "TOKEN_TYPE_NOT_EQUALS");

// Arithmetic operators
add_keyword(TOKEN_PLUS, "+", 1, "TOKEN_TYPE_PLUS");
add_keyword(TOKEN_PLUS_EQUALS, "+=", 2, "TOKEN_TYPE_PLUS_EQUALS");
add_keyword(TOKEN_INCREMENT, "++", 2, "TOKEN_TYPE_INCREMENT");
add_keyword(TOKEN_MINUS, "-", 1, "TOKEN_TYPE_MINUS");
add_keyword(TOKEN_MINUS_EQUALS, "-=", 2, "TOKEN_TYPE_MINUS_EQUALS");
add_keyword(TOKEN_ARROW, "->", 2, "TOKEN_TYPE_ARROW");
add_keyword(TOKEN_DECREMENT, "--", 2, "TOKEN_TYPE_DECREMENT");
add_keyword(TOKEN_MULTIPLY, "*", 1, "TOKEN_TYPE_MULTIPLY");
add_keyword(TOKEN_MULTIPLY_EQUALS, "*=", 2, "TOKEN_TYPE_MULTIPLY_EQUALS");
add_keyword(TOKEN_DIVIDE, "/", 1, "TOKEN_TYPE_DIVIDE");
add_keyword(TOKEN_DIVIDE_EQUALS, "/=", 2, "TOKEN_TYPE_DIVIDE_EQUALS");
add_keyword(TOKEN_MODULO, "%%", 1, "TOKEN_TYPE_MODULO");
add_keyword(TOKEN_MODULO_EQUALS, "%%=", 2, "TOKEN_TYPE_MODULO_EQUALS");

add_keyword(TOKEN_LSHIFT, "<<", 1, "TOKEN_TYPE_LEFT_SHIFT");
add_keyword(TOKEN_RSHIFT, ">>", 1, "TOKEN_TYPE_LEFT_SHIFT");

// Comparison operators
add_keyword(TOKEN_LESS_THAN, "<", 1, "TOKEN_TYPE_LESS_THAN");
add_keyword(TOKEN_LESS_THAN_EQUALS, "<=", 2, "TOKEN_TYPE_LESS_THAN_EQUALS");
add_keyword(TOKEN_GREATER_THAN, ">", 1, "TOKEN_TYPE_GREATER_THAN");
add_keyword(TOKEN_GREATER_THAN_EQUALS, ">=", 2, "TOKEN_TYPE_GREATER_THAN_EQUALS");

// Literals
add_keyword(TOKEN_LITERAL_INT, NULL, NULL, "TOKEN_TYPE_LITERAL_INT");
add_keyword(TOKEN_LITERAL_STRING, NULL, NULL, "TOKEN_TYPE_LITERAL_STRING");
add_keyword(TOKEN_LITERAL_CHAR, NULL, NULL, "TOKEN_TYPE_LITERAL_CHAR");

// Keywords
add_keyword(TOKEN_PROC_DECL, "proc", 4, "TOKEN_TYPE_PROC_DECL");
add_keyword(TOKEN_END, "end", 3, "TOKEN_TYPE_END");
add_keyword(TOKEN_ASSERT, "assert", 6, "TOKEN_TYPE_ASSERT");


proc lex_identifier()
vars
    uint64 _lit_type = 0;
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    while is_alphanumeric(*file_contents) and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end

    tokens[token_count].type = get_identifier_type(tokens[token_count].text, tokens[token_count].length);

    token_count++;
end

proc lex_delimiter()
code
    tokens[token_count].type = get_symbol_type(*file_contents);
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    token_count++;
end

proc lex_hex_number()
code
    file_contents++;
    i++;
    column++;
    tokens[token_count].length = tokens[token_count].length + 1;
    while is_hex_digit(*file_contents) and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end
end

proc lex_decimal_number()
code
    while is_digit(*file_contents) and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end
end

proc is_math_symbol(uint8 c) -> uint64
code    
    return c == '+' or c == '-' or c == '*' or c == '/' or c == '%';
end

proc lex_number()
code
    tokens[token_count].type = TOKEN_LITERAL_INT;
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == 'x' or *file_contents == 'X' then
        lex_hex_number();
    else
        lex_decimal_number();
    end

    if is_whitespace(*file_contents) or is_delimiter(*file_contents) or is_math_symbol(*file_contents) or i >= file_size then
    else
        print_string("Invalid number\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        exit(1);
    end

    token_count++;
end

proc lex_string()
code
    tokens[token_count].type = TOKEN_LITERAL_STRING;
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    while *file_contents != '\"' and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end

    if *file_contents == '\"' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    else
        print_string("Invalid string\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        exit(1);
    end

    token_count++;
end

proc lex_character()
code
    tokens[token_count].type = TOKEN_LITERAL_CHAR;
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '\\' and i < file_size then
        file_contents = file_contents + 2;
        i = i + 2;
        column = column + 2;
        tokens[token_count].length = tokens[token_count].length + 2;
    else
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end

    if *file_contents == '\'' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    else
        if tokens[token_count].length > 1 then
            print_string("Invalid character\n");
            print_string("Line: ");
            str_number = to_string(line);
            print_nstring(str_number, &buffer + buffer_size - str_number);
            print_string(" Column: ");
            str_number = to_string(column);
            print_nstring(str_number, &buffer + buffer_size - str_number);
            exit(1);
        end
    end

    token_count++;
end

proc lex_equals()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_EQUALS;
    else
        tokens[token_count].type = TOKEN_ASSIGNMENT;
    end

    token_count++;
end

proc lex_not()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_NOT_EQUALS;
    else
        tokens[token_count].type = TOKEN_NOT;
    end

    token_count++;
end

proc lex_less_than()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_LESS_THAN_EQUALS;
    else if *file_contents == '<' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_LSHIFT;
    else
        tokens[token_count].type = TOKEN_LESS_THAN;
    end end

    token_count++;
end

proc lex_greater_than()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_GREATER_THAN_EQUALS;
    else if *file_contents == '>' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_RSHIFT;
    else
        tokens[token_count].type = TOKEN_GREATER_THAN;
    end end

    token_count++;
end

proc lex_plus()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_PLUS_EQUALS;
    else if *file_contents == '+' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_INCREMENT;
    else
        tokens[token_count].type = TOKEN_PLUS;
    end end

    token_count++;
end

proc lex_minus()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_MINUS_EQUALS;
    else if *file_contents == '>' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_ARROW;
    else if *file_contents == '-' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_DECREMENT;
    else
        tokens[token_count].type = TOKEN_MINUS;
    end end end

    token_count++;
end

proc lex_multiply()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_MULTIPLY_EQUALS;
    else
        tokens[token_count].type = TOKEN_MULTIPLY;
    end

    token_count++;
end

proc lex_divide()
code
    file_contents++;
    column++;
    i++;
    if *file_contents == '=' then
        tokens[token_count].text = file_contents - 1;
        tokens[token_count].line = line;
        tokens[token_count].column = column;
        tokens[token_count].length = 2;

        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_DIVIDE_EQUALS;

        token_count++;
    else if *file_contents == '/' then
        while *file_contents != '\n' and i < file_size do
            file_contents++;
            i++;
        end
    else
        tokens[token_count].text = file_contents - 1;
        tokens[token_count].line = line;
        tokens[token_count].column = column;
        tokens[token_count].length = 1;
        tokens[token_count].type = TOKEN_DIVIDE;

        token_count++;
    end end
end

proc lex_modulo()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_MODULO_EQUALS;
    else
        tokens[token_count].type = TOKEN_MODULO;
    end

    token_count++;
end

while i < file_size do
    if is_alpha(*file_contents) then
        lex_identifier();
    else if is_delimiter(*file_contents) then
        lex_delimiter();
    else if is_digit(*file_contents) then
        lex_number();
    else if *file_contents == '\n' then
        line++;
        column = 1;
        file_contents++;
        i++;
    else if *file_contents == '\r' then
        file_contents++;
        i++;
    else if *file_contents == ' ' then
        file_contents++;
        column++;
        i++;
    else if *file_contents == '\"' then
        lex_string();
    else if *file_contents == '\'' then
        lex_character();
    else if *file_contents == '=' then
        lex_equals();
    else if *file_contents == '!' then
        lex_not();
    else if *file_contents == '<' then
        lex_less_than();
    else if *file_contents == '>' then
        lex_greater_than();
    else if *file_contents == '+' then
        lex_plus();
    else if *file_contents == '-' then
        lex_minus();
    else if *file_contents == '*' then
        lex_multiply();
    else if *file_contents == '/' then
        lex_divide();
    else if *file_contents == '%' then
        lex_modulo();
    else
        print_string("Unknown character: '");
        print_nstring(file_contents, 1);
        print_string("'\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end end end end end end end end end end end end end end
end

if DEBUG_LEXER then
    str_number = to_string(token_count);
    print_string("Token count: ");
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");

    i = 0;
    while i < token_count do
        print_token_type(tokens[i].type);
        print_string(" text:");
        print_nstring(tokens[i].text, tokens[i].length);
        print_string(" line:");
        str_number = to_string(tokens[i].line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" col:");
        str_number = to_string(tokens[i].column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        i++;
    end
end

// =================================================================================================
// Parser
// =================================================================================================

uint64 token_index = 0;

proc unexpected_token()
code
    print_string("Unexpected token: ");
    print_token_type(tokens[token_index].type);
    print_string("\nLine: ");
    str_number = to_string(tokens[token_index].line);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string(" Column: ");
    str_number = to_string(tokens[token_index].column);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");
    exit(1);
end

proc unknown_identifier()
code
    print_string("Unknown word: ");
    print_nstring(tokens[token_index].text, tokens[token_index].length);
    print_string("\nLine: ");
    str_number = to_string(tokens[token_index].line);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string(" Column: ");
    str_number = to_string(tokens[token_index].column);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");
    exit(1);
end

proc redeclared_identifier()
code
    print_string("Identifier redeclared: ");
    print_nstring(tokens[token_index].text, tokens[token_index].length);
    print_string("\nLine: ");
    str_number = to_string(tokens[token_index].line);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string(" Column: ");
    str_number = to_string(tokens[token_index].column);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");
    exit(1);
end

proc is_data_type_token(uint64 type) -> uint64
code
    return type == TOKEN_UINT8 or type == TOKEN_UINT16 or type == TOKEN_UINT32 or type == TOKEN_UINT64 or
           type == TOKEN_INT8 or type == TOKEN_INT16 or type == TOKEN_INT32 or type == TOKEN_INT64 or
           type == TOKEN_BOOL;
end

proc consume_token(uint64 type)
code
    if token_index >= token_count then
        print_string("Unexpected end of file\n");
        exit(1);
    end
    
    if tokens[token_index].type != type then
        print_string("Expected token: ");
        print_token_type(type);
        print_string(" but got: ");
        print_token_type(tokens[token_index].type);
        print_string("\nLine: ");
        str_number = to_string(tokens[token_index].line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(tokens[token_index].column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end
    token_index++;
end

struct Procedure
    pointer name;
    uint64 name_length;
    uint64 variable_count;
    uint64 first_variable_index;
    uint64 last_variable_index;
    uint64 statement_count;
    uint64 first_statement_index;
    uint64 last_statement_index;
end

@define PROCEDURE_COUNT 1000

Procedure[PROCEDURE_COUNT] procedures;
uint64 procedure_count = 0;

@define VARIABLE_SCOPE_GLOBAL 0

uint64 current_scope = 1;

enum Data_Type_Enum
    DATA_TYPE_UINT8,
    DATA_TYPE_UINT16,
    DATA_TYPE_UINT32,
    DATA_TYPE_UINT64,
    DATA_TYPE_INT8,
    DATA_TYPE_INT16,
    DATA_TYPE_INT32,
    DATA_TYPE_INT64,
    DATA_TYPE_BOOL,
    DATA_TYPE_STRUCT,
end

struct Data_Type
    uint64 type;
    uint64 size;
    uint64 is_primitive;
    pointer name;
    uint64 name_length;
end

enum VariableKind
    VARIABLE_KIND_PARAMETER = 1,
    VARIABLE_KIND_LOCAL,
end

struct Variable
    pointer name;
    uint64 name_length;
    uint64 data_type;
    uint64 rbp_offset; // for local variables
    uint64 initial_value;
    uint64 scope;
    uint64 kind;
    uint64 next_variable_index;
end

@define VARIABLE_COUNT 1000

Variable[VARIABLE_COUNT] variables;
uint64 variable_count = 0;

enum Operation_Type
    OPERATION_ASSIGNMENT = 1,
    OPERATION_ADD,
    OPERATION_SUBTRACT,
    OPERATION_MULTIPLY,
    OPERATION_DIVIDE,
    OPERATION_MODULO,
    OPERATION_EQUALS,
    OPERATION_NOT_EQUALS,
    OPERATION_LESS_THAN,
    OPERATION_LESS_THAN_EQUALS,
    OPERATION_GREATER_THAN,
    OPERATION_GREATER_THAN_EQUALS,
    OPERATION_LEFT_SHIFT,
    OPERATION_RIGHT_SHIFT,
    OPERATION_UNARY_MINUS,
    OPERATION_UNARY_LOGICAL_NOT,
    OPERATION_VALUE,
    OPERATION_ASSERT,
end

enum Term_Type
    TERM_TYPE_LITERAL_INT = 1,
    TERM_TYPE_LITERAL_STRING,
    TERM_TYPE_LITERAL_CHAR,
    TERM_TYPE_VARIABLE,
    TERM_TYPE_UNARY_OPERATION,
    TERM_TYPE_BINARY_OPERATION,
    TERM_TYPE_PROCEDURE_CALL,
end

struct Operation
    uint64 type;
    uint64 left_index;
    uint64 value_type;
    uint64 right_index;
end


@define BINARY_OP_COUNT 1000
Operation[BINARY_OP_COUNT] operations;
uint64 operations_count = 0;

proc add_operation(uint64 type, uint64 left_index, uint64 value_type, uint64 right_index) -> uint64
code
    if operations_count >= BINARY_OP_COUNT then
        print_string("Binary operation count exceeded\n");
        exit(1);
    end

    operations[operations_count].type = type;
    operations[operations_count].left_index = left_index;
    operations[operations_count].value_type = value_type;
    operations[operations_count].right_index = right_index;
    operations_count++;

    return operations_count - 1;
end

struct Statement
    uint64 op_index;
    uint64 next_index;
    uint64 prev_index;
end

@define STATEMENT_COUNT 1000
Statement[STATEMENT_COUNT] statements;
uint64 statement_count = 0;

proc create_statement(uint64 op_index, uint64 next_index, uint64 prev_index) -> uint64
code
    debug_string("Adding statement\n");
    if statement_count >= STATEMENT_COUNT then
        print_string("Statement count exceeded\n");
        exit(1);
    end

    statements[statement_count].op_index = op_index;
    statements[statement_count].next_index = next_index;
    statements[statement_count].prev_index = prev_index;
    statement_count++;

    return statement_count - 1;
end

proc add_procedure(pointer name, uint64 name_length)
code
    if procedure_count >= PROCEDURE_COUNT then
        print_string("Procedure count exceeded\n");
        exit(1);
    end

    procedures[procedure_count].name = name;
    procedures[procedure_count].name_length = name_length;
    procedures[procedure_count].variable_count = 0;
    procedures[procedure_count].first_variable_index = NOT_FOUND;
    procedures[procedure_count].last_variable_index = NOT_FOUND;
    procedures[procedure_count].statement_count = 0;
    procedures[procedure_count].first_statement_index = NOT_FOUND;
    procedures[procedure_count].last_statement_index = NOT_FOUND;
    procedure_count++;
end

proc find_procedure(pointer name, uint64 name_length) -> uint64
vars
    uint64 fp_i = 0;
code
    fp_i = 0;
    while fp_i < procedure_count do
        if string_compare(name, procedures[fp_i].name, name_length, procedures[fp_i].name_length) then
            return fp_i;
        end
        fp_i++;
    end
    return 0 - 1; // only uint64 are supported, so this is the best we can do
end

proc add_variable_to_procedure(uint64 variable_index)
vars
    uint64 avtp_current_proc = 0;
    uint64 avtp_last_variable_index = 0;
code
    debug_string("Adding variable to procedure\n");
    avtp_current_proc = procedure_count - 1;
    if procedures[avtp_current_proc].first_variable_index == NOT_FOUND then
        procedures[avtp_current_proc].first_variable_index = variable_index;
        procedures[avtp_current_proc].last_variable_index = variable_index;
    else
        avtp_last_variable_index = procedures[avtp_current_proc].last_variable_index;
        variables[avtp_last_variable_index].next_variable_index = variable_index;
        procedures[avtp_current_proc].last_variable_index = variable_index;
    end

    // Set variable index
    variables[variable_index].rbp_offset = procedures[avtp_current_proc].variable_count * 8 + 8;

    procedures[avtp_current_proc].variable_count = procedures[avtp_current_proc].variable_count + 1;
end

proc add_variable(pointer name, uint64 name_length, uint64 data_type, uint64 initial_value, uint64 scope, uint64 kind)
code
    if variable_count >= VARIABLE_COUNT then
        print_string("Variable count exceeded\n");
        exit(1);
    end

    variables[variable_count].name = name;
    variables[variable_count].name_length = name_length;
    variables[variable_count].data_type = data_type;
    variables[variable_count].initial_value = initial_value;
    variables[variable_count].scope = scope;
    variables[variable_count].kind = kind;

    if scope != VARIABLE_SCOPE_GLOBAL then
        add_variable_to_procedure(variable_count);
    end

    variable_count++;
end

proc find_variable(uint64 token_index) -> uint64
vars
    uint64 iv_i = 0;
code
    iv_i = 0;
    while iv_i < variable_count do
        if string_compare(tokens[token_index].text, variables[iv_i].name, tokens[token_index].length, variables[iv_i].name_length) then
            return iv_i;
        end
        iv_i++;
    end
    return NOT_FOUND;
end

proc parse_identifier() -> uint64
code
    consume_token(TOKEN_IDENTIFIER);
    return token_index - 1;
end

proc parse_literal_int() -> uint64
vars
    uint64 _pli_i = 0;
code
    _pli_i = token_index;
    consume_token(TOKEN_LITERAL_INT);

    return to_number(tokens[_pli_i].text, tokens[_pli_i].length);
end

proc parse_variable_declaration(uint64 scope)
vars
    uint64 pvd_data_type = 0;
    uint64 pvd_identifier = 0;
    uint64 pvd_initial_value = 0;
code
    pvd_data_type = tokens[token_index].type;
    consume_token(pvd_data_type);
    pvd_identifier = parse_identifier();

    // Check if variable already exists
    if find_variable(pvd_identifier) != NOT_FOUND then
        // revert token index to identifier for error message
        token_index = pvd_identifier;
        redeclared_identifier();
    end

    if tokens[token_index].type == TOKEN_ASSIGNMENT then
        consume_token(TOKEN_ASSIGNMENT);
        pvd_initial_value = parse_literal_int();
    else
        pvd_initial_value = 0;
    end

    consume_token(TOKEN_SEMICOLON);

    add_variable(tokens[pvd_identifier].text, tokens[pvd_identifier].length, pvd_data_type, pvd_initial_value, scope, VARIABLE_KIND_LOCAL);
end

proc parse_expression() -> uint64;

proc parse_factor() -> uint64
vars
    uint64 pe_term_index = 0;
    uint64 pe_var_index = 0;
    uint64 pe_op_index = 0;
code
    if tokens[token_index].type == TOKEN_OPEN_PAREN then
        consume_token(TOKEN_OPEN_PAREN);
        pe_op_index = parse_expression();
        consume_token(TOKEN_CLOSE_PAREN);
        return pe_op_index;
    else if tokens[token_index].type == TOKEN_MINUS then
        consume_token(TOKEN_MINUS);
        if tokens[token_index].type == TOKEN_LITERAL_INT then
            // Unary minus on literal
            pe_term_index = 0 - parse_literal_int();
            return add_operation(OPERATION_VALUE, pe_term_index, TERM_TYPE_LITERAL_INT, 0);
        else 
            // Unary minus 
            pe_term_index = parse_factor();
            return add_operation(OPERATION_UNARY_MINUS, pe_term_index, TERM_TYPE_UNARY_OPERATION, 0);
        end
    else if tokens[token_index].type == TOKEN_NOT then
        consume_token(TOKEN_NOT);
        pe_term_index = parse_factor();
        return add_operation(OPERATION_UNARY_LOGICAL_NOT, pe_term_index, TERM_TYPE_UNARY_OPERATION, 0);
    else if tokens[token_index].type == TOKEN_LITERAL_INT then
        pe_term_index = parse_literal_int();
        return add_operation(OPERATION_VALUE, pe_term_index, TERM_TYPE_LITERAL_INT, 0);
    else if tokens[token_index].type == TOKEN_IDENTIFIER then
        pe_term_index = parse_identifier();
        pe_var_index = find_variable(pe_term_index);
        if pe_var_index != NOT_FOUND then
            return add_operation(OPERATION_VALUE, pe_var_index, TERM_TYPE_VARIABLE, 0);
        else
            token_index = token_index - 1;
            unknown_identifier();
        end
    else
        unexpected_token();
    end end end end end
end

proc parse_multiplicative_expression() -> uint64
vars
    uint64 pme_op_index = 0;
    uint64 pme_right_index = 0;
    uint64 pme_op_type = 0;
code
    pme_op_index = parse_factor();

    while 
        tokens[token_index].type == TOKEN_MULTIPLY or 
        tokens[token_index].type == TOKEN_DIVIDE or 
        tokens[token_index].type == TOKEN_MODULO
    do
        if tokens[token_index].type == TOKEN_MULTIPLY then
            consume_token(TOKEN_MULTIPLY);
            pme_op_type = OPERATION_MULTIPLY;
        else if tokens[token_index].type == TOKEN_DIVIDE then
            consume_token(TOKEN_DIVIDE);
            pme_op_type = OPERATION_DIVIDE;
        else
            consume_token(TOKEN_MODULO);
            pme_op_type = OPERATION_MODULO;
        end end
        pme_right_index = parse_factor();

        pme_op_index = add_operation(pme_op_type, pme_op_index, TERM_TYPE_BINARY_OPERATION, pme_right_index);
    end

    return pme_op_index;
end

proc parse_additive_expression() -> uint64
vars
    uint64 pae_op_index = 0;
    uint64 pae_right_index = 0;
    uint64 pae_op_type = 0;
code
    // NOTE: Unary minus is handled in parse_factor
    pae_op_index = parse_multiplicative_expression();

    while tokens[token_index].type == TOKEN_PLUS or tokens[token_index].type == TOKEN_MINUS do
        if tokens[token_index].type == TOKEN_PLUS then
            consume_token(TOKEN_PLUS);
            pae_op_type = OPERATION_ADD;
        else
            consume_token(TOKEN_MINUS);
            pae_op_type = OPERATION_SUBTRACT;
        end
        pae_right_index = parse_multiplicative_expression();

        pae_op_index = add_operation(pae_op_type, pae_op_index, TERM_TYPE_BINARY_OPERATION, pae_right_index);
    end
   
    return pae_op_index;
end

proc parse_shift_expression() -> uint64
vars
    uint64 pse_op_index = 0;
    uint64 pse_right_index = 0;
    uint64 pse_op_type = 0;
code
    pse_op_index = parse_additive_expression();

    while tokens[token_index].type == TOKEN_LSHIFT or tokens[token_index].type == TOKEN_RSHIFT do
        if tokens[token_index].type == TOKEN_LSHIFT then
            consume_token(TOKEN_LSHIFT);
            pse_op_type = OPERATION_LEFT_SHIFT;
        else
            consume_token(TOKEN_RSHIFT);
            pse_op_type = OPERATION_RIGHT_SHIFT;
        end
        pse_right_index = parse_additive_expression();

        pse_op_index = add_operation(pse_op_type, pse_op_index, TERM_TYPE_BINARY_OPERATION, pse_right_index);
    end
   
    return pse_op_index;
end

proc parse_relational_expression() -> uint64
vars
    uint64 pre_op_index = 0;
    uint64 pre_right_index = 0;
    uint64 pre_op_type = 0;
code
    pre_op_index = parse_shift_expression();

    while 
        tokens[token_index].type == TOKEN_EQUALS or 
        tokens[token_index].type == TOKEN_NOT_EQUALS or 
        tokens[token_index].type == TOKEN_LESS_THAN or 
        tokens[token_index].type == TOKEN_LESS_THAN_EQUALS or 
        tokens[token_index].type == TOKEN_GREATER_THAN or 
        tokens[token_index].type == TOKEN_GREATER_THAN_EQUALS
    do
        if tokens[token_index].type == TOKEN_EQUALS then
            consume_token(TOKEN_EQUALS);
            pre_op_type = OPERATION_EQUALS;
        else if tokens[token_index].type == TOKEN_NOT_EQUALS then
            consume_token(TOKEN_NOT_EQUALS);
            pre_op_type = OPERATION_NOT_EQUALS;
        else if tokens[token_index].type == TOKEN_LESS_THAN then
            consume_token(TOKEN_LESS_THAN);
            pre_op_type = OPERATION_LESS_THAN;
        else if tokens[token_index].type == TOKEN_LESS_THAN_EQUALS then
            consume_token(TOKEN_LESS_THAN_EQUALS);
            pre_op_type = OPERATION_LESS_THAN_EQUALS;
        else if tokens[token_index].type == TOKEN_GREATER_THAN then
            consume_token(TOKEN_GREATER_THAN);
            pre_op_type = OPERATION_GREATER_THAN;
        else
            consume_token(TOKEN_GREATER_THAN_EQUALS);
            pre_op_type = OPERATION_GREATER_THAN_EQUALS;
        end end end end end
        pre_right_index = parse_shift_expression();

        pre_op_index = add_operation(pre_op_type, pre_op_index, TERM_TYPE_BINARY_OPERATION, pre_right_index);
    end

    return pre_op_index;
end

proc parse_expression() -> uint64
code
    return parse_relational_expression();
end

proc add_statement_to_procedure(uint64 statement_index, uint64 proc_index)
vars
    uint64 astp_last_statement_index = 0;
code
    debug_string("Adding statement ");
    str_number = to_string(statement_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string(" to procedure ");
    str_number = to_string(proc_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string("\n");

    if procedures[proc_index].statement_count == 0 then
        procedures[proc_index].first_statement_index = statement_index;
    else
        astp_last_statement_index = procedures[proc_index].last_statement_index;
        statements[astp_last_statement_index].next_index = statement_index;
    end
    procedures[proc_index].last_statement_index = statement_index;

    procedures[proc_index].statement_count = procedures[proc_index].statement_count + 1;
end

proc parse_assert_statement(uint64 scope, uint64 proc_index)
vars
    uint64 pas_expr_index = 0;
    uint64 pas_op_index = 0;
    uint64 pas_statement_index = 0;
code
    consume_token(TOKEN_ASSERT);
    consume_token(TOKEN_OPEN_PAREN);
    
    // Parse expression
    pas_expr_index = parse_expression();
    pas_op_index = add_operation(OPERATION_ASSERT, pas_expr_index, TERM_TYPE_BINARY_OPERATION, 0);
    pas_statement_index = create_statement(pas_op_index, procedures[proc_index].last_statement_index, NULL);
    add_statement_to_procedure(pas_statement_index, proc_index);

    consume_token(TOKEN_CLOSE_PAREN);
    consume_token(TOKEN_SEMICOLON);
end

proc parse_statement(uint64 scope, uint64 proc_index)
vars
    uint64 ps_identifier = 0;
    uint64 ps_data_type = 0;
    uint64 ps_var_index = 0;
    uint64 ps_expr_index = 0;
    uint64 ps_op_index = 0;
    uint64 ps_statement_index = 0;
code
    if is_data_type_token(tokens[token_index].type) then
        parse_variable_declaration(scope);
    else if tokens[token_index].type == TOKEN_ASSERT then
        parse_assert_statement(scope, proc_index);
    else if tokens[token_index].type == TOKEN_IDENTIFIER then
        ps_identifier = parse_identifier();

        ps_var_index = find_variable(ps_identifier);
        if ps_var_index != NOT_FOUND then
            ps_data_type = DATA_TYPE_UINT64;
        else
            token_index = token_index - 1;
            unknown_identifier();
        end

        debug_string("Variable index is ");
        str_number = to_string(ps_var_index);
        debug_nstring(str_number, &buffer + buffer_size - str_number);
        debug_string("\n");

        debug_string("Variable Count is ");
        str_number = to_string(variable_count);
        debug_nstring(str_number, &buffer + buffer_size - str_number);
        debug_string("\n");

        if tokens[token_index] == TOKEN_ASSIGNMENT then
            consume_token(TOKEN_ASSIGNMENT);
        else
            unexpected_token();
        end

        ps_expr_index = parse_expression();

        ps_op_index = add_operation(OPERATION_ASSIGNMENT, ps_var_index, TERM_TYPE_VARIABLE, ps_expr_index);

        debug_string("Added binary op index: ");
        str_number = to_string(ps_op_index);
        debug_nstring(str_number, &buffer + buffer_size - str_number);
        debug_string("\n");

        ps_statement_index = create_statement(ps_op_index, procedures[proc_index].last_statement_index, NULL);

        add_statement_to_procedure(ps_statement_index, proc_index);

        consume_token(TOKEN_SEMICOLON);
    else
        unexpected_token();
    end end end
end

proc parse_procedure_declaration(uint64 scope)
vars
    uint64 ppd_identifier = 0;
    pointer ppd_proc_pointer = 0;
    uint64 ppd_proc_index = 0;
code
    consume_token(TOKEN_PROC_DECL);
    ppd_identifier = parse_identifier();

    // Check if procedure already exists
    if find_procedure(tokens[ppd_identifier].text, tokens[ppd_identifier].length) != NOT_FOUND then
        // revert token index to identifier for error message
        token_index = ppd_identifier;
        redeclared_identifier();
    end

    add_procedure(tokens[ppd_identifier].text, tokens[ppd_identifier].length);

    consume_token(TOKEN_OPEN_PAREN);
    consume_token(TOKEN_CLOSE_PAREN);

    while tokens[token_index].type != TOKEN_END and token_index < token_count do
        parse_statement(scope, procedure_count - 1);
    end

    consume_token(TOKEN_END);
end

while token_index < token_count do
    if is_data_type_token(tokens[token_index].type) then
        parse_variable_declaration(VARIABLE_SCOPE_GLOBAL);
    else if tokens[token_index].type == TOKEN_PROC_DECL then
        parse_procedure_declaration(current_scope);
        current_scope++;
    else
        unexpected_token();
    end end
end

// =================================================================================================
// Code generation
// =================================================================================================

proc is_comparison_operation(uint64 op_type) -> uint64
code
    return op_type == OPERATION_EQUALS or
           op_type == OPERATION_NOT_EQUALS or
           op_type == OPERATION_LESS_THAN or
           op_type == OPERATION_LESS_THAN_EQUALS or
           op_type == OPERATION_GREATER_THAN or
           op_type == OPERATION_GREATER_THAN_EQUALS;
end

uint64 output_file_handle = 0;

proc emit_nstring(uint64 handle, pointer text, uint64 length)
code
    WriteFile(handle, text, length, NULL, NULL);
end

proc emit_string(uint64 handle, pointer text)
vars
    uint64 es_length = 0;
code
    es_length = string_length(text);
    emit_nstring(handle, text, es_length);
end

proc write_header(uint64 file_handle)
code
    emit_string(file_handle, "; Generated by Strata v2.0\n\n");
    emit_string(file_handle, "bits 64\n");
    emit_string(file_handle, "default rel\n\n");

    emit_string(file_handle, "section .bss\n");
    emit_string(file_handle, "\t__std_output__ resq 1\n\n");

    emit_string(file_handle, "section .rodata\n");
    emit_string(file_handle, "\t__assert_failed__ db 'Assert failed', 0\n");
    emit_string(file_handle, "\t__assert_failed_length__ equ $ - __assert_failed__\n\n");

    emit_string(file_handle, "section .text\n");
    emit_string(file_handle, "\textern GetStdHandle\n");
    emit_string(file_handle, "\textern WriteConsoleA\n");
    emit_string(file_handle, "\textern ExitProcess\n");
    emit_string(file_handle, "\tglobal proc_main\n\n");

    emit_string(file_handle, "\tglobal init_program\n\n");
    emit_string(file_handle, "init_program:\n");
    emit_string(file_handle, "\tmov rcx, -11\n");
    emit_string(file_handle, "\tcall GetStdHandle\n");
    emit_string(file_handle, "\tmov [__std_output__], rax\n");
    emit_string(file_handle, "\tjmp proc_main\n\n");
    emit_string(file_handle, "assert_failed:\n");
    emit_string(file_handle, "\tmov rcx, [__std_output__]\n");
    emit_string(file_handle, "\tmov rdx, __assert_failed__\n");
    emit_string(file_handle, "\tmov r8, __assert_failed_length__\n");
    emit_string(file_handle, "\tmov r9, 0\n");
    emit_string(file_handle, "\tcall WriteConsoleA\n");
    emit_string(file_handle, "\tmov rcx, 1\n");
    emit_string(file_handle, "\tcall ExitProcess\n\n");
    emit_string(file_handle, "\tret\n\n");
end

proc write_var_init(uint64 file_handle, uint64 variable_index)
vars
    uint64 wvi_initial_value = 0;
code
    wvi_initial_value = variables[variable_index].initial_value;
    if wvi_initial_value > 0x7FFFFFFF then
        emit_string(file_handle, "\tmov r15, ");
        str_number = to_string(wvi_initial_value);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
        emit_string(file_handle, "\tmov qword [rbp - ");
        str_number = to_string(variables[variable_index].rbp_offset);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "], r15\n");
    else
        emit_string(file_handle, "\tmov qword [rbp - ");
        str_number = to_string(variables[variable_index].rbp_offset);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "], ");
        str_number = to_string(wvi_initial_value);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, " ; local var ");
        emit_nstring(file_handle, variables[variable_index].name, variables[variable_index].name_length);
        emit_string(file_handle, "\n");
    end
end

enum Registers
    REG_R15 = 1,
    REG_R14,
    REG_R13,
    REG_R12,
    REG_R11,
    REG_R10,
    REG_R9,
    REG_R8,
    REG_RDI,
    REG_RSI,
    REG_RDX,
    REG_RCX,
    REG_RBX,
    REG_RAX,
end

@define REG_COUNT 15
uint64[REG_COUNT] reg_used;
uint64[REG_COUNT] reg_stack;
uint64 reg_stack_count = 0;
uint64 regs_in_use = 0;
uint64[REG_COUNT] reg_names;
uint64[REG_COUNT] reg_lb_names;

uint8[] reg_r15 = "r15"; reg_names[REG_R15] = &reg_r15;
uint8[] reg_r14 = "r14"; reg_names[REG_R14] = &reg_r14;
uint8[] reg_r13 = "r13"; reg_names[REG_R13] = &reg_r13;
uint8[] reg_r12 = "r12"; reg_names[REG_R12] = &reg_r12;
uint8[] reg_r11 = "r11"; reg_names[REG_R11] = &reg_r11;
uint8[] reg_r10 = "r10"; reg_names[REG_R10] = &reg_r10;
uint8[] reg_r9 = "r9";   reg_names[REG_R9] = &reg_r9;
uint8[] reg_r8 = "r8";   reg_names[REG_R8] = &reg_r8;
uint8[] reg_rdi = "rdi"; reg_names[REG_RDI] = &reg_rdi;
uint8[] reg_rsi = "rsi"; reg_names[REG_RSI] = &reg_rsi;
uint8[] reg_rdx = "rdx"; reg_names[REG_RDX] = &reg_rdx;
uint8[] reg_rcx = "rcx"; reg_names[REG_RCX] = &reg_rcx;
uint8[] reg_rbx = "rbx"; reg_names[REG_RBX] = &reg_rbx;
uint8[] reg_rax = "rax"; reg_names[REG_RAX] = &reg_rax;

uint8[] reg_lb_r15 = "r15b"; reg_lb_names[REG_R15] = &reg_lb_r15;
uint8[] reg_lb_r14 = "r14b"; reg_lb_names[REG_R14] = &reg_lb_r14;
uint8[] reg_lb_r13 = "r13b"; reg_lb_names[REG_R13] = &reg_lb_r13;
uint8[] reg_lb_r12 = "r12b"; reg_lb_names[REG_R12] = &reg_lb_r12;
uint8[] reg_lb_r11 = "r11b"; reg_lb_names[REG_R11] = &reg_lb_r11;
uint8[] reg_lb_r10 = "r10b"; reg_lb_names[REG_R10] = &reg_lb_r10;
uint8[] reg_lb_r9 = "r9b";   reg_lb_names[REG_R9] = &reg_lb_r9;
uint8[] reg_lb_r8 = "r8b";   reg_lb_names[REG_R8] = &reg_lb_r8;
uint8[] reg_lb_rdi = "dil"; reg_lb_names[REG_RDI] = &reg_lb_rdi;
uint8[] reg_lb_rsi = "sil"; reg_lb_names[REG_RSI] = &reg_lb_rsi;
uint8[] reg_lb_rdx = "dl"; reg_lb_names[REG_RDX] = &reg_lb_rdx;
uint8[] reg_lb_rcx = "cl"; reg_lb_names[REG_RCX] = &reg_lb_rcx;
uint8[] reg_lb_rbx = "bl"; reg_lb_names[REG_RBX] = &reg_lb_rbx;
uint8[] reg_lb_rax = "al"; reg_lb_names[REG_RAX] = &reg_lb_rax;

proc get_register(uint64 op_type) -> uint64
vars
    uint64 gr_i = 0;
code
    if regs_in_use >= REG_COUNT then
        print_string("Out of registers\n");
        exit(1);
    end

    if 
        op_type == OPERATION_MULTIPLY or 
        op_type == OPERATION_DIVIDE or 
        op_type == OPERATION_MODULO
    then
        if reg_used[REG_RAX] == 0 then
            reg_used[REG_RAX] = 1;
            regs_in_use++;
            reg_stack[reg_stack_count] = REG_RAX;
            reg_stack_count++;
            return REG_RAX;
        else
            //TEMP: This is a hack to get multiplication working
            emit_string(output_file_handle, "\tpush rax\n");
            reg_used[REG_RAX] = reg_used[REG_RAX] + 1;
            // regs_in_use++;
            reg_stack[reg_stack_count] = REG_RAX;
            reg_stack_count++;
            return REG_RAX;
            // print_string("Out of registers\n");
            // exit(1);
        end 
    end

    if op_type == OPERATION_LEFT_SHIFT or op_type == OPERATION_RIGHT_SHIFT then
        if reg_used[REG_RCX] == 0 then
            reg_used[REG_RCX] = 1;
            regs_in_use++;
            reg_stack[reg_stack_count] = REG_RCX;
            reg_stack_count++;
            return REG_RCX;
        else
            //TEMP: This is a hack to get shift working
            emit_string(output_file_handle, "\tpush rcx\n");
            reg_used[REG_RCX] = reg_used[REG_RCX] + 1;
            // regs_in_use++;
            reg_stack[reg_stack_count] = REG_RCX;
            reg_stack_count++;
            return REG_RCX;
            // print_string("Out of registers\n");
            // exit(1);
        end 
    end

    gr_i = 1;
    while gr_i < REG_COUNT do
        if reg_used[gr_i] == 0 then
            reg_used[gr_i] = 1;
            regs_in_use++;
            reg_stack[reg_stack_count] = gr_i;
            reg_stack_count++;
            return gr_i;
        end
        gr_i = gr_i + 1;
    end

    print_string("Out of registers\n");
    exit(1);
end

proc free_register(uint64 reg)
code
    if reg == REG_RAX and reg_used[REG_RAX] > 1 then
        emit_string(output_file_handle, "\tpop rax\n");
        reg_used[REG_RAX] = reg_used[REG_RAX] - 1;
        reg_stack_count = reg_stack_count - 1;
        return;
    end

    if reg == REG_RCX and reg_used[REG_RCX] > 1 then
        emit_string(output_file_handle, "\tpop rcx\n");
        reg_used[REG_RCX] = reg_used[REG_RCX] - 1;
        reg_stack_count = reg_stack_count - 1;
        return;
    end

    reg_used[reg] = 0;
    regs_in_use = regs_in_use - 1;
    return;
end

proc push_register(uint64 reg)
code
    if reg_stack_count >= REG_COUNT then
        print_string("Register stack overflow\n");
        exit(1);
    end

    if reg_used[reg] >= 1 then
        print_string("Register already in use\n");
        exit(1);
    end

    reg_stack[reg_stack_count] = reg;
    reg_stack_count++;
end

proc peek_register() -> uint64
vars
    uint64 pr_reg = 0;
code
    if reg_stack_count == 0 then
        print_string("Peek: Register stack underflow\n");
        exit(1);
    end

    return reg_stack[reg_stack_count - 1];
end

proc pop_register() -> uint64
vars
    uint64 pr_reg = 0;
code
    if reg_stack_count == 0 then
        print_string("Pop: Register stack underflow\n");
        exit(1);
    end
    pr_reg = reg_stack[reg_stack_count - 1];
    free_register(pr_reg);
    reg_stack_count = reg_stack_count - 1;
    return pr_reg;
end

proc get_register_name(uint64 reg) -> pointer
code
    return reg_names[reg];
end

proc print_reg_stack()
vars
    uint64 prs_i = 0;
    uint64 prs_reg = 0;
code
    prs_i = 0;
    while prs_i < reg_stack_count do
        print_string(" ");
        print_string(reg_names[prs_reg]);
        prs_i = prs_i + 1;
    end
    print_string("\n");
end

@define DEBUG_CODEGEN 0

proc log_codegen(pointer text)
code
    if DEBUG_CODEGEN then
        print_string(text);
    end
end

proc write_op_value(uint64 file_handle, uint64 op_index, uint64 parent_op_type)
vars
    uint64 guov_left_index = 0;
    uint64 guov_free_reg = 0;
code
    guov_free_reg = get_register(parent_op_type);
    if operations[op_index].value_type == TERM_TYPE_LITERAL_INT then
        log_codegen("write_op_value: Unary op value is int literal\n");
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[guov_free_reg]);
        emit_string(file_handle, ", ");
        str_number = to_string(operations[op_index].left_index);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
    else if operations[op_index].value_type == TERM_TYPE_VARIABLE then
        log_codegen("write_op_value: Unary op value is variable\n");
        guov_left_index = operations[op_index].left_index;
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[guov_free_reg]);
        emit_string(file_handle, ", qword [rbp - ");
        str_number = to_string(variables[guov_left_index].rbp_offset);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "]\n");
    else
        print_string("write_op_value: Unsupported unary type\n");
        exit(1);
    end end 
end

proc write_op_addition(uint64 file_handle, uint64 op_index);

proc write_op_multiplication(uint64 file_handle, uint64 op_index)
vars
    uint64 wom_left_index = 0;
    uint64 wom_right_index = 0;
    uint64 wom_left_reg = 0;
    uint64 wom_right_reg = 0;
code
    wom_left_index = operations[op_index].left_index;
    wom_right_index = operations[op_index].right_index;

    // Check for constant folding
    if operations[wom_left_index].value_type == TERM_TYPE_LITERAL_INT and operations[wom_right_index].value_type == TERM_TYPE_LITERAL_INT then
        log_codegen("write_op_multiplication: Constant folding\n");
        wom_left_reg = get_register(OPERATION_VALUE);
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[wom_left_reg]);
        emit_string(file_handle, ", ");
        if operations[op_index].type == OPERATION_MULTIPLY then
            str_number = to_string(operations[wom_left_index].left_index * operations[wom_right_index].left_index);
        else if operations[op_index].type == OPERATION_DIVIDE then
            str_number = to_string(operations[wom_left_index].left_index / operations[wom_right_index].left_index);
        else
            str_number = to_string(operations[wom_left_index].left_index % operations[wom_right_index].left_index);
        end end
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
        return;
    end

    if operations[wom_left_index].type == OPERATION_VALUE then
        log_codegen("write_op_multiplication: left - Unary\n");
        write_op_value(file_handle, wom_left_index, operations[op_index].type);
    else if operations[wom_left_index].type == OPERATION_ADD or operations[wom_left_index].type == OPERATION_SUBTRACT then
        // Handle addition and subtraction 
        log_codegen("write_op_multiplication: left - Addition or subtraction\n");
        write_op_addition(file_handle, wom_left_index);
    else if 
        operations[wom_left_index].type == OPERATION_MULTIPLY or 
        operations[wom_left_index].type == OPERATION_DIVIDE or 
        operations[wom_left_index].type == OPERATION_MODULO
    then
        // Handle multiplication, division and modulo
        log_codegen("write_op_multiplication: left - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wom_left_index);
    else
        print_string("write_op_multiplication: Unsupported left type\n");
        exit(1);
    end end end

    if operations[wom_right_index].type == OPERATION_VALUE then
        // Check for division by zero
        if operations[wom_right_index].value_type == TERM_TYPE_LITERAL_INT and operations[wom_right_index].left_index == 0 then
            print_string("Division by zero\n");
            exit(1);
        end
        log_codegen("write_op_multiplication: right - Unary\n");
        write_op_value(file_handle, wom_right_index, OPERATION_VALUE);
    else if operations[wom_right_index].type == OPERATION_ADD or operations[wom_right_index].type == OPERATION_SUBTRACT then
        // Handle addition and subtraction 
        log_codegen("write_op_multiplication: right - Addition or subtraction\n");
        write_op_addition(file_handle, wom_right_index);
    else if 
        operations[wom_right_index].type == OPERATION_MULTIPLY or 
        operations[wom_right_index].type == OPERATION_DIVIDE or 
        operations[wom_right_index].type == OPERATION_MODULO
    then
        // Handle multiplication, division and modulo
        log_codegen("write_op_multiplication: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wom_right_index);
    else 
        print_string("write_op_multiplication: Unsupported right type ");
        str_number = to_string(operations[wom_right_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end

    wom_right_reg = pop_register();
    wom_left_reg = pop_register();
    if wom_left_reg != REG_RAX then
        emit_string(file_handle, "\tmov rax, ");
        emit_string(file_handle, reg_names[wom_left_reg]);
        emit_string(file_handle, "\n");
        free_register(wom_left_reg);
    end

    if operations[op_index].type == OPERATION_MULTIPLY then
        emit_string(file_handle, "\tmul ");
    else if operations[op_index].type == OPERATION_DIVIDE or operations[op_index].type == OPERATION_MODULO then
        emit_string(file_handle, "\tcqo\n\tdiv ");
    else
        print_string("write_op_multiplication: Unsupported operation type\n");
        exit(1);
    end end

    emit_string(file_handle, reg_names[wom_right_reg]);
    emit_string(file_handle, "\n");

     wom_right_reg = get_register(OPERATION_VALUE);

    emit_string(file_handle, "\tmov ");
    emit_string(file_handle, reg_names[wom_right_reg]);
    if operations[op_index].type == OPERATION_MULTIPLY or operations[op_index].type == OPERATION_DIVIDE then
        // Multiplication and division stores result in rax
        emit_string(file_handle, ", rax\n");
    else
        // Modulo stores remainder in rdx
        emit_string(file_handle, ", rdx\n");
    end
    emit_string(file_handle, "\t; -- end mul or div --\n");
    return;
end

proc write_op_addition(uint64 file_handle, uint64 op_index)
vars
    uint64 woa_left_index = 0;
    uint64 woa_right_index = 0;
    uint64 woa_left_reg = 0;
    uint64 woa_right_reg = 0;
code
    woa_left_index = operations[op_index].left_index;
    woa_right_index = operations[op_index].right_index;

    // Constant folding for addition
    if operations[woa_left_index].value_type == TERM_TYPE_LITERAL_INT and operations[woa_right_index].value_type == TERM_TYPE_LITERAL_INT then
        log_codegen("write_op_addition: Constant folding\n");
        woa_left_reg = get_register(OPERATION_ADD);
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[woa_left_reg]);
        emit_string(file_handle, ", ");
        if operations[op_index].type == OPERATION_ADD then
            str_number = to_string(operations[woa_left_index].left_index + operations[woa_right_index].left_index);
        else
            str_number = to_string(operations[woa_left_index].left_index - operations[woa_right_index].left_index);
        end
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
        return;
    end

    if operations[woa_left_index].type == OPERATION_VALUE then
        log_codegen("write_op_addition: left - Unary\n");
        write_op_value(file_handle, woa_left_index, operations[op_index].type);
    else if operations[woa_left_index].type == OPERATION_ADD or operations[woa_left_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_addition: left - Addition or subtraction\n");
        write_op_addition(file_handle, woa_left_index);
    else if operations[woa_left_index].type == OPERATION_MULTIPLY or operations[woa_left_index].type == OPERATION_DIVIDE then
        log_codegen("write_op_addition: left - Multiplication or division\n");
        write_op_multiplication(file_handle, woa_left_index);
    else
        print_string("write_op_addition: left - Unsupported left type: ");
        str_number = to_string(operations[woa_left_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end

    if operations[woa_right_index].type == OPERATION_VALUE then
        log_codegen("write_op_addition: right - Unary\n");
        write_op_value(file_handle, woa_right_index, operations[op_index].type);
    else if operations[woa_right_index].type == OPERATION_ADD or operations[woa_right_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_addition: right - Addition or subtraction\n");
        write_op_addition(file_handle, woa_right_index);
    else if 
        operations[woa_right_index].type == OPERATION_MULTIPLY or 
        operations[woa_right_index].type == OPERATION_DIVIDE or
        operations[woa_right_index].type == OPERATION_MODULO
    then
        log_codegen("write_op_addition: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woa_right_index);
    else 
        print_string("write_op_addition: Unsupported right type: ");
        str_number = to_string(operations[woa_right_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end

    woa_right_reg = pop_register();
    woa_left_reg = pop_register();
    
    if operations[op_index].type == OPERATION_ADD then
        emit_string(file_handle, "\tadd ");
    else if operations[op_index].type == OPERATION_SUBTRACT then
        emit_string(file_handle, "\tsub ");
    else
        print_string("write_op_addition: Unsupported operation type\n");
        exit(1);
    end end
    emit_string(file_handle, reg_names[woa_left_reg]);
    emit_string(file_handle, ", ");
    emit_string(file_handle, reg_names[woa_right_reg]);
    emit_string(file_handle, "\n");

    woa_right_reg = get_register(operations[op_index].type);
    emit_string(file_handle, "\t; -- end add or sub --\n");
    return;
end

proc write_op_shift(uint64 file_handle, uint64 op_index)
vars
    uint64 wos_left_index = 0;
    uint64 wos_right_index = 0;
    uint64 wos_left_reg = 0;
    uint64 wos_right_reg = 0;
code
    wos_left_index = operations[op_index].left_index;
    wos_right_index = operations[op_index].right_index;

    if operations[wos_left_index].type == OPERATION_VALUE then
        print_string("write_op_shift: left - Unary\n");
        write_op_value(file_handle, wos_left_index, OPERATION_VALUE);
    else if operations[wos_left_index].type == OPERATION_ADD or operations[wos_left_index].type == OPERATION_SUBTRACT then
        print_string("write_op_shift: left - Addition or subtraction\n");
        write_op_addition(file_handle, wos_left_index);
    else if 
        operations[wos_left_index].type == OPERATION_MULTIPLY or 
        operations[wos_left_index].type == OPERATION_DIVIDE or
        operations[wos_left_index].type == OPERATION_MODULO
    then
        print_string("write_op_shift: left - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wos_left_index);
    else 
        print_string("write_op_shift: Unsupported left type\n");
        exit(1);
    end end end

    if operations[wos_right_index].type == OPERATION_VALUE then
        print_string("write_op_shift: right - Unary\n");
        write_op_value(file_handle, wos_right_index, operations[op_index].type);
    else if operations[wos_right_index].type == OPERATION_ADD or operations[wos_right_index].type == OPERATION_SUBTRACT then
        print_string("write_op_shift: right - Addition or subtraction\n");
        write_op_addition(file_handle, wos_right_index);
    else if 
        operations[wos_right_index].type == OPERATION_MULTIPLY or 
        operations[wos_right_index].type == OPERATION_DIVIDE or
        operations[wos_right_index].type == OPERATION_MODULO
    then
        print_string("write_op_shift: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wos_right_index);
    else 
        print_string("write_op_shift: Unsupported right type\n");
        exit(1);
    end end end

    wos_right_reg = pop_register();
    wos_left_reg = pop_register();

    if wos_right_reg != REG_RCX then
        emit_string(file_handle, "\tmov rcx, ");
        emit_string(file_handle, reg_names[wos_right_reg]);
        emit_string(file_handle, "\n");
        free_register(wos_right_reg);
    end

    if operations[op_index].type == OPERATION_LEFT_SHIFT then
        emit_string(file_handle, "\tshl ");
    else if operations[op_index].type == OPERATION_RIGHT_SHIFT then
        emit_string(file_handle, "\tshr ");
    else
        print_string("write_op_shift: Unsupported operation type\n");
        exit(1);
    end end
    emit_string(file_handle, reg_names[wos_left_reg]);
    emit_string(file_handle, ", cl\n");

    wos_right_reg = get_register(OPERATION_VALUE);
    emit_string(file_handle, "\t; -- end shift --\n");
    return;
end

proc write_unary_logical_not(uint64 file_handle, uint64 op_index);

proc write_op_comparison(uint64 file_handle, uint64 op_index)
vars
    uint64 woc_left_index = 0;
    uint64 woc_right_index = 0;
    uint64 woc_left_reg = 0;
    uint64 woc_right_reg = 0;
code
    woc_left_index = operations[op_index].left_index;
    woc_right_index = operations[op_index].right_index;

    if operations[woc_left_index].type == OPERATION_VALUE then
        print_string("write_op_comparison: left - Unary\n");
        write_op_value(file_handle, woc_left_index, operations[op_index].type);
    else if operations[woc_left_index].type == OPERATION_ADD or operations[woc_left_index].type == OPERATION_SUBTRACT then
        print_string("write_op_comparison: left - Addition or subtraction\n");
        write_op_addition(file_handle, woc_left_index);
    else if 
        operations[woc_left_index].type == OPERATION_MULTIPLY or 
        operations[woc_left_index].type == OPERATION_DIVIDE or
        operations[woc_left_index].type == OPERATION_MODULO
    then
        print_string("write_op_comparison: left - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woc_left_index);
    else if operations[woc_left_index].type == OPERATION_UNARY_LOGICAL_NOT then
        print_string("write_op_comparison: left - Unary logical not\n");
        write_unary_logical_not(file_handle, woc_left_index);
    else if operations[woc_left_index].type == OPERATION_LEFT_SHIFT or operations[woc_left_index].type == OPERATION_RIGHT_SHIFT then
        print_string("write_op_comparison: left - Shift\n");
        write_op_shift(file_handle, woc_left_index);
    else 
        print_string("write_op_comparison: Unsupported left type\n");
        exit(1);
    end end end end end

    if operations[woc_right_index].type == OPERATION_VALUE then
        print_string("write_op_comparison: right - Unary\n");
        write_op_value(file_handle, woc_right_index, operations[op_index].type);
    else if operations[woc_right_index].type == OPERATION_ADD or operations[woc_right_index].type == OPERATION_SUBTRACT then
        print_string("write_op_comparison: right - Addition or subtraction\n");
        write_op_addition(file_handle, woc_right_index);
    else if 
        operations[woc_right_index].type == OPERATION_MULTIPLY or 
        operations[woc_right_index].type == OPERATION_DIVIDE or
        operations[woc_right_index].type == OPERATION_MODULO
    then
        print_string("write_op_comparison: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woc_right_index);
    else if  operations[woc_right_index].type == OPERATION_UNARY_LOGICAL_NOT then
        print_string("write_op_comparison: right - Unary logical not\n");
        write_unary_logical_not(file_handle, woc_right_index);
    else if operations[woc_right_index].type == OPERATION_LEFT_SHIFT or operations[woc_right_index].type == OPERATION_RIGHT_SHIFT then
        print_string("write_op_comparison: right - Shift\n");
        write_op_shift(file_handle, woc_right_index);
    else 
        print_string("write_op_comparison: Unsupported right type\n");
        exit(1);
    end end end end end

    woc_right_reg = pop_register();
    woc_left_reg = pop_register();

    emit_string(file_handle, "\tcmp ");
    emit_string(file_handle, reg_names[woc_left_reg]);
    emit_string(file_handle, ", ");
    emit_string(file_handle, reg_names[woc_right_reg]);
    emit_string(file_handle, "\n");

    woc_right_reg = get_register(OPERATION_VALUE);

    if operations[op_index].type == OPERATION_EQUALS then
        emit_string(file_handle, "\tsete ");
    else if operations[op_index].type == OPERATION_NOT_EQUALS then
        emit_string(file_handle, "\tsetne ");
    else if operations[op_index].type == OPERATION_LESS_THAN then
        emit_string(file_handle, "\tsetl ");
    else if operations[op_index].type == OPERATION_LESS_THAN_EQUALS then
        emit_string(file_handle, "\tsetle ");
    else if operations[op_index].type == OPERATION_GREATER_THAN then
        emit_string(file_handle, "\tsetg ");
    else if operations[op_index].type == OPERATION_GREATER_THAN_EQUALS then
        emit_string(file_handle, "\tsetge ");
    else
        print_string("write_op_comparison: Unsupported operation type\n");
        exit(1);
    end end end end end end

    emit_string(file_handle, reg_lb_names[woc_right_reg]);
    emit_string(file_handle, "\n");

    emit_string(file_handle, "\t; -- end cmp --\n");
    return;
end

proc write_unary_logical_not(uint64 file_handle, uint64 op_index)
vars
    uint64 wun_op_index = 0;
    uint64 wun_reg = 0;
code
    wun_op_index = operations[op_index].left_index;

    if operations[wun_op_index].type == OPERATION_VALUE then
        print_string("write_unary_logical_not: Unary\n");
        write_op_value(file_handle, wun_op_index, operations[op_index].type);
    else if is_comparison_operation(operations[wun_op_index].type) then
        print_string("write_unary_logical_not: Comparison\n");
        write_op_comparison(file_handle, wun_op_index);
    else 
        print_string("write_unary_logical_not: Unsupported left type\n");
        exit(1);
    end end 

    wun_reg = pop_register();

    emit_string(file_handle, "\tcmp ");
    emit_string(file_handle, reg_lb_names[wun_reg]);
    emit_string(file_handle, ", 0\n");

    wun_reg = get_register(OPERATION_VALUE);

    emit_string(file_handle, "\tsete ");
    emit_string(file_handle, reg_lb_names[wun_reg]);
    emit_string(file_handle, "\n");

    emit_string(file_handle, "\t; -- end not --\n");
    return;
end

proc write_op_unary_minus(uint64 file_handle, uint64 op_index)
vars
    uint64 woum_op_index = 0;
    uint64 woum_reg = 0;
code
    woum_op_index = operations[op_index].left_index;

    if operations[woum_op_index].type == OPERATION_VALUE or operations[woum_op_index].type == OPERATION_UNARY_MINUS then
        print_string("write_op_unary_minus: Unary\n");
        write_op_value(file_handle, woum_op_index, operations[op_index].type);
    else if operations[woum_op_index].type == OPERATION_ADD or operations[woum_op_index].type == OPERATION_SUBTRACT then
        print_string("write_op_unary_minus: Addition or subtraction\n");
        write_op_addition(file_handle, woum_op_index);
    else if 
        operations[woum_op_index].type == OPERATION_MULTIPLY or 
        operations[woum_op_index].type == OPERATION_DIVIDE or
        operations[woum_op_index].type == OPERATION_MODULO
    then
        print_string("write_op_unary_minus: Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woum_op_index);
    else if operations[woum_op_index].type == OPERATION_LEFT_SHIFT or operations[woum_op_index].type == OPERATION_RIGHT_SHIFT then
        print_string("write_op_unary_minus: Shift\n");
        write_op_shift(file_handle, woum_op_index);
    else 
        print_string("write_op_unary_minus: Unsupported left type ");
        str_number = to_string(operations[woum_op_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end

    woum_reg = pop_register();

    emit_string(file_handle, "\tneg ");
    emit_string(file_handle, reg_names[woum_reg]);
    emit_string(file_handle, "\n");

    woum_reg = get_register(OPERATION_VALUE);

    emit_string(file_handle, "\t; -- end unary minus --\n");
    return;
end

proc write_assignment(uint64 file_handle, uint64 op_index)
vars
    uint64 wa_left_index = 0;
    uint64 wa_right_index = 0;
    uint64 wa_right_reg = 0;
    uint64 wa_is_comparison = 0;
code
    wa_is_comparison = 0;
    wa_left_index = operations[op_index].left_index;
    wa_right_index = operations[op_index].right_index;

    if operations[wa_right_index].type == OPERATION_VALUE then
        log_codegen("write_assignment: Unary\n");
        write_op_value(file_handle, wa_right_index, operations[op_index].type);
    else if operations[wa_right_index].type == OPERATION_ADD or operations[wa_right_index].type == OPERATION_SUBTRACT then
        log_codegen("write_assignment: Addition or subtraction\n");
        write_op_addition(file_handle, wa_right_index);
    else if 
        operations[wa_right_index].type == OPERATION_MULTIPLY or 
        operations[wa_right_index].type == OPERATION_DIVIDE or
        operations[wa_right_index].type == OPERATION_MODULO 
    then
        log_codegen("write_assignment: Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wa_right_index);
    else if is_comparison_operation(operations[wa_right_index].type) then
        wa_is_comparison = 1;
        log_codegen("write_assignment: Comparison\n");
        write_op_comparison(file_handle, wa_right_index);
    else if operations[wa_right_index].type == OPERATION_UNARY_LOGICAL_NOT then
        log_codegen("write_assignment: Unary not\n");
        write_unary_logical_not(file_handle, wa_right_index);
    else if operations[wa_right_index].type == OPERATION_UNARY_MINUS then
        print_string("write_assignment: Unary minus\n");
        write_op_unary_minus(file_handle, wa_right_index);
    else if operations[wa_right_index].type == OPERATION_LEFT_SHIFT or operations[wa_right_index].type == OPERATION_RIGHT_SHIFT then
        log_codegen("write_assignment: Shift\n");
        write_op_shift(file_handle, wa_right_index);
    else 
        print_string("write_assignment: Unsupported right type: ");
        str_number = to_string(operations[wa_right_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end end end end

    if operations[op_index].value_type == TERM_TYPE_VARIABLE then
        wa_right_reg = pop_register();
        
        if wa_is_comparison then
            emit_string(file_handle, "\tmov byte [rbp - ");
            str_number = to_string(variables[wa_left_index].rbp_offset);
            emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
            emit_string(file_handle, "], ");
            emit_string(file_handle, reg_lb_names[wa_right_reg]);
        else
            emit_string(file_handle, "\tmov qword [rbp - ");
            str_number = to_string(variables[wa_left_index].rbp_offset);
            emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
            emit_string(file_handle, "], ");
            emit_string(file_handle, reg_names[wa_right_reg]);
        end
        // emit_string(file_handle, reg_names[wa_right_reg]);
        emit_string(file_handle, "\n");
    else
        print_string("write_assignment: Unsupported left type\n");
    end
end

proc write_assert(uint64 file_handle, uint64 op_index)
vars
    uint64 wa_reg = 0;
    uint64 wa_left_index = 0;
    uint64 wa_right_reg = 0;
    uint64 wa_is_comparison = 0;
code
    wa_left_index = operations[op_index].left_index;
    if is_comparison_operation(operations[wa_left_index].type) then
        write_op_comparison(file_handle, wa_left_index);
    else 
        print_string("write_assert: Unsupported type ");
        str_number = to_string(operations[op_index].left_index);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");

        exit(1);
    end

    wa_reg = pop_register();

    emit_string(file_handle, "\tcmp ");
    emit_string(file_handle, reg_lb_names[wa_reg]);
    emit_string(file_handle, ", 1\n");
    emit_string(file_handle, "\tjne assert_failed\n");
    emit_string(file_handle, "\t; -- end assert --\n");
end

uint64 ws_statement_index = 0;
proc write_statement(uint64 file_handle, uint64 statement_index)
vars
    uint64 ws_op_index = 0;
    uint64 ws_left_index = 0;
    uint64 ws_right_index = 0;
code
    debug_string("; writing statement ");
    str_number = to_string(statement_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string("\n");
    ws_op_index = statements[statement_index].op_index;

    emit_string(file_handle, "; statement index: ");
    str_number = to_string(ws_statement_index);
    emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
    emit_string(file_handle, "\n");

    if operations[ws_op_index].type == OPERATION_ASSIGNMENT then
        write_assignment(file_handle, ws_op_index);
    else if operations[ws_op_index].type == OPERATION_ASSERT then
        write_assert(file_handle, ws_op_index);
    else
        unexpected_token();
    end end

    ws_statement_index++;
end

proc write_procedure_declaration(uint64 file_handle, uint64 procedure_index)
vars
    uint64 wp_i = 0;
    uint64 wp_variable_index = 0;
    uint64 wp_statement_index = 0;
code
    debug_string("; writing procedure\n");
    emit_string(file_handle, "proc_");
    emit_nstring(file_handle, procedures[procedure_index].name, procedures[procedure_index].name_length);
    emit_string(file_handle, ":\n");
    emit_string(file_handle, "\tpush rbp\n");
    emit_string(file_handle, "\tmov rbp, rsp\n");

    if procedures[procedure_index].variable_count != 0 then
        emit_string(file_handle, "\tsub rsp, ");
        str_number = to_string(procedures[procedure_index].variable_count * 8);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, " ; ");
        str_number = to_string(procedures[procedure_index].variable_count);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, " local vars\n");

        wp_i = 0;
        wp_variable_index = procedures[procedure_index].first_variable_index;
        while wp_i < procedures[procedure_index].variable_count do
            write_var_init(file_handle, wp_variable_index);
            wp_variable_index = variables[wp_variable_index].next_variable_index;
            wp_i++;
        end
    end

    wp_i = 0;
    wp_statement_index = procedures[procedure_index].first_statement_index;
    while wp_i < procedures[procedure_index].statement_count do
        write_statement(file_handle, wp_statement_index);
        wp_statement_index = statements[wp_statement_index].next_index;
        wp_i++;
    end

    emit_string(file_handle, "\tmov rsp, rbp\n");
    emit_string(file_handle, "\tpop rbp\n");
    emit_string(file_handle, "\tret\n");
    emit_string(file_handle, "; end proc_");
    emit_nstring(file_handle, procedures[procedure_index].name, procedures[procedure_index].name_length);
    emit_string(file_handle, "\n\n");
end

proc write_program(uint64 file_handle)
vars
    uint64 wp_i = 0;
code
    if find_procedure("main", 4) == NOT_FOUND then
        print_string("No main procedure found\n");
        exit(1);
    end

    write_header(file_handle);

    debug_string("Writing program\n");
    wp_i = 0;
    while wp_i < procedure_count do
        write_procedure_declaration(file_handle, wp_i);
        wp_i++;
    end
end

output_file_handle = CreateFileA("v3.asm", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
write_program(output_file_handle);



// Strings - compare, index, read, write
// Uint16, uint32, int8, int16, uint32, int64
// offsetof() intrinsic
// Macros
// Variadic procedures
// `test`, `str` is not a valid identifier because it is a keyword in assembly
// Includes
// Asserts
//
// For loops
// Generate byte code
// Dead code elimination
// Constant folding
// Tests - edit some simple examples and develop a C# app to run them. Compare output
// Type check
//