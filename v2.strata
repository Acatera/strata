extern proc GetStdHandle(uint64 nStdHandle) -> uint64;
extern proc WriteConsoleA(pointer hConsoleOutput, pointer lpBuffer, uint64 nNumberOfCharsToWrite, pointer lpNumberOfCharsWritten) -> uint64;
extern proc GetProcessHeap() -> pointer;
extern proc HeapAlloc(uint64 hHeap, uint64 flags, uint64 size) -> pointer;
extern proc GetLastError() -> uint64;
extern proc CreateFileA(pointer lpFileName, uint64 dwDesiredAccess, uint64 dwShareMode, pointer lpSecurityAttributes, uint64 dwCreationDisposition, uint64 dwFlagsAndAttributes, pointer hTemplateFile) -> pointer;
extern proc GetFileSizeEx(pointer hFile, pointer lpFileSize) -> uint64;
extern proc ReadFile(pointer hFile, pointer lpBuffer, uint64 nNumberOfBytesToRead, pointer lpNumberOfBytesRead, pointer lpOverlapped) -> uint64;
//BOOL GetFileSizeEx(
//  [in]  HANDLE         hFile,
//  [out] PLARGE_INTEGER lpFileSize
//);

@define STD_OUTPUT_HANDLE 0xFFFFFFF5
@define NULL 0

@define false 0
@define true 1

@define GENERIC_READ 0x80000000
@define FILE_SHARE_READ 0x00000001
@define OPEN_EXISTING 0x00000003
@define FILE_ATTRIBUTE_NORMAL 0x00000080

uint64 std_handle = GetStdHandle(STD_OUTPUT_HANDLE);

uint8[] input_file = "v3.strata";
uint8[] file_open_error = "Failed to open file\n";
uint8[] process_heap_error = "Failed to get process heap\n";
uint8[] file_size_error = "Failed to get file size\n";
uint8[] file_read_error = "Failed to read file\n";
uint8[] mem_alloc_error = "Failed to allocate memory\n";

uint64 input_file_handle = CreateFileA(input_file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if input_file_handle < 0 then
    WriteConsoleA(std_handle, file_open_error, 20, NULL);
    exit(1);
end

uint64 file_size = 0;
if GetFileSizeEx(input_file_handle, &file_size) != true then
   WriteConsoleA(std_handle, file_size_error, 23, NULL);
    exit(1);
end

uint64 heap = GetProcessHeap();
if heap == NULL then
    WriteConsoleA(std_handle, process_heap_error, 26, NULL);
    exit(1);
end

uint8* file_contents = HeapAlloc(heap, 0, file_size);
if file_contents == NULL then
    WriteConsoleA(std_handle, mem_alloc_error, 26, NULL);
    exit(1);
end

uint64 bytes_read = 0;
if ReadFile(input_file_handle, file_contents, file_size, &bytes_read, NULL) != true then
    WriteConsoleA(std_handle, file_read_error, 19, NULL);
    exit(1);
end

WriteConsoleA(std_handle, file_contents, file_size, NULL);

while *file_contents != 0 do
    file_contents++;
end

// Uint16, uint32, int8, int16, uint32, int64
// offsetof() intrinsic
// Strings - compare, index, read, write
// Characters - convert to uint8
// Variadic procedures
// Macros
// String literals
// `test`, `str` is not a valid identifier because it is a keyword in assembly
// number parsing always treats the number as hex, resulting in identifier ceed being parsed as 0xceed
// Includes
// Asserts
// 
// For loops
// Generate byte code
// Dead code elimination
// Constant folding 
// Tests - edit some simple examples and develop a C# app to run them. Compare output
// Type check 
// 