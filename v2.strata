extern proc GetStdHandle(uint64 nStdHandle) -> uint64;
extern proc WriteConsoleA(pointer hConsoleOutput, pointer lpBuffer, uint64 nNumberOfCharsToWrite, pointer lpNumberOfCharsWritten) -> uint64;
extern proc GetProcessHeap() -> pointer;
extern proc HeapAlloc(uint64 hHeap, uint64 flags, uint64 size) -> pointer;
extern proc GetLastError() -> uint64;
extern proc CreateFileA(pointer lpFileName, uint64 dwDesiredAccess, uint64 dwShareMode, pointer lpSecurityAttributes, uint64 dwCreationDisposition, uint64 dwFlagsAndAttributes, pointer hTemplateFile) -> pointer;
extern proc GetFileSizeEx(pointer hFile, pointer lpFileSize) -> uint64;
extern proc ReadFile(pointer hFile, pointer lpBuffer, uint64 nNumberOfBytesToRead, pointer lpNumberOfBytesRead, pointer lpOverlapped) -> uint64;
extern proc WriteFile(pointer hFile, pointer lpBuffer, uint64 nNumberOfBytesToWrite, pointer lpNumberOfBytesWritten, pointer lpOverlapped) -> uint64;

@define DEBUG 0
@define DEBUG_LEXER 0

@define STD_OUTPUT_HANDLE 0xFFFFFFF5
@define NULL 0

@define false 0
@define true 1

@define GENERIC_READ 0x80000000
@define GENERIC_WRITE 0x40000000

@define FILE_SHARE_READ 0x00000001
@define FILE_SHARE_WRITE 0x00000002

@define CREATE_ALWAYS 0x00000002
@define OPEN_EXISTING 0x00000003

@define FILE_ATTRIBUTE_NORMAL 0x00000080

@define WINDOWS 0
@define LINUX 1

@define CALLING_CONVENTION 0

uint64 NOT_FOUND = 0;
NOT_FOUND = 0 - 1;
uint64 NONE = 0;
NONE = 0 - 1;

uint64 std_handle = GetStdHandle(STD_OUTPUT_HANDLE);

uint8* _sl_ptr = 0;
proc string_length(pointer str) -> uint64
vars
    uint64 length = 0;
code
    _sl_ptr = str;
    length = 0;
    while *_sl_ptr != 0 do
        _sl_ptr++;
        length++;
    end
    return length;
end

proc print_nstring(pointer text, uint64 len)
code
    WriteConsoleA(std_handle, text, len, NULL);
end

proc print_string(pointer text)
vars
    uint64 ps_len = 0;
code
    ps_len = string_length(text);
    print_nstring(text, ps_len);
end

proc debug_string(pointer text)
vars
    uint64 ds_length = 0;
code
    if DEBUG then
        ds_length = string_length(text);
        print_nstring(text, ds_length);
    end
end

proc debug_nstring(pointer text, uint64 len)
code
    if DEBUG then
        print_nstring(text, len);
    end
end

uint8[] input_file = "v3.strata";

uint64 input_file_handle = CreateFileA(input_file, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
if input_file_handle < 0 then
    print_string("Failed to open file\n");
    exit(1);
end

uint64 file_size = 0;
if GetFileSizeEx(input_file_handle, &file_size) != true then
    print_string("Failed to get file size\n");
    exit(1);
end

uint64 heap = GetProcessHeap();
if heap == NULL then
    print_string("Failed to get heap\n");
    exit(1);
end

uint8* file_contents = HeapAlloc(heap, 0, file_size);
if file_contents == NULL then
    print_string("Failed to allocate memory\n");
    exit(1);
end

uint64 bytes_read = 0;
if ReadFile(input_file_handle, file_contents, file_size, &bytes_read, NULL) != true then
    print_string("Failed to read file\n");
    exit(1);
end

uint8[256] buffer;
uint8* buffer_ptr = &buffer;
uint64 buffer_size = 0;
uint8* str_number = 0;

proc to_string(uint64 value) -> uint64
vars
    uint64 val = 0;
    uint64 ts_negative = 0;
code
    val = value;
    ts_negative = 0;
    if val < 0 then
        ts_negative = 1;
        val = 0 - val;
    end

    if val == 0 then
        buffer_ptr = &buffer + buffer_size;
        buffer_ptr = buffer_ptr - 1;
        *buffer_ptr = 48;
        return buffer_ptr;
    end

    buffer_ptr = &buffer + buffer_size;
    while val != 0 do
        buffer_ptr = buffer_ptr - 1;
        *buffer_ptr = val % 10 + 48;
        val = val / 10;
    end

    if ts_negative then
        buffer_ptr = buffer_ptr - 1;
        *buffer_ptr = '-';
    end

    return buffer_ptr;
end

proc print_number(uint64 value)
code
    str_number = to_string(value);
    print_nstring(str_number, &buffer + buffer_size - str_number);
end

uint8* tn_ptr = 0;
proc to_number(pointer text, uint64 length) -> uint64
vars
    uint64 _tn_i = 0;
    uint64 _tn_number = 0;
code
    tn_ptr = text;
    _tn_i = 0;
    _tn_number = 0;
    while _tn_i < length do
        _tn_number = _tn_number * 10 + *tn_ptr - '0';
        _tn_i++;
        tn_ptr++;
    end
    return _tn_number;
end



uint8* snc_a_ptr = 0;
uint8* snc_b_ptr = 0;
proc string_compare(pointer a, pointer b, uint64 len_a, uint64 len_b) -> uint64
vars
    uint64 i = 0;
code
    snc_a_ptr = a;
    snc_b_ptr = b;

    if len_a != len_b then
        return false;
    end

    i = 0;
    while i < len_a do
        if *snc_a_ptr != *snc_b_ptr then
            return false;
        end
        snc_a_ptr++;
        snc_b_ptr++;
        i++;
    end

    return true;
end

enum TokenType
    TOKEN_UINT8 = 1,
    TOKEN_UINT16,
    TOKEN_UINT32,
    TOKEN_UINT64,
    TOKEN_INT8,
    TOKEN_INT16,
    TOKEN_INT32,
    TOKEN_INT64,
    TOKEN_BOOL,
    TOKEN_CHAR,
    TOKEN_IDENTIFIER,
    TOKEN_OPEN_PAREN,
    TOKEN_CLOSE_PAREN,
    TOKEN_OPEN_BRACKET,
    TOKEN_CLOSE_BRACKET,
    TOKEN_COMMA,
    TOKEN_DOT,
    TOKEN_SEMICOLON,
    TOKEN_AT,
    TOKEN_AMPERSAND,
    TOKEN_LITERAL_INT,
    TOKEN_LITERAL_STRING,
    TOKEN_LITERAL_CHAR,
    TOKEN_ASSIGNMENT,
    TOKEN_EQUALS,
    TOKEN_NOT,
    TOKEN_NOT_EQUALS,
    TOKEN_PLUS,
    TOKEN_PLUS_EQUALS,
    TOKEN_INCREMENT,
    TOKEN_MINUS,
    TOKEN_MINUS_EQUALS,
    TOKEN_ARROW,
    TOKEN_DECREMENT,
    TOKEN_MULTIPLY,
    TOKEN_MULTIPLY_EQUALS,
    TOKEN_DIVIDE,
    TOKEN_DIVIDE_EQUALS,
    TOKEN_MODULO,
    TOKEN_MODULO_EQUALS,
    TOKEN_LESS_THAN,
    TOKEN_LESS_THAN_EQUALS,
    TOKEN_GREATER_THAN,
    TOKEN_GREATER_THAN_EQUALS,
    TOKEN_LSHIFT,
    TOKEN_RSHIFT,
    TOKEN_PROC_DECL,
    TOKEN_END,
    TOKEN_ASSERT,
    TOKEN_TRUE,
    TOKEN_FALSE,
    TOKEN_IF,
    TOKEN_THEN,
    TOKEN_ELSE,
    TOKEN_ELIF,
    TOKEN_RETURN,
end

struct Keyword
    uint64 type;
    uint64 length;
    pointer text;
    pointer human_readable_text;
    uint64 human_readable_length;
end


@define KEYWORD_COUNT 100
Keyword[KEYWORD_COUNT] keywords;
uint64 keyword_count = 0;

proc add_keyword(uint64 type, pointer text, uint64 length, pointer human_readable_text)
code
    if keyword_count >= KEYWORD_COUNT then
        print_string("Keyword count exceeded\n");
        exit(1);
    end

    keywords[keyword_count].type = type;
    keywords[keyword_count].text = text;
    keywords[keyword_count].length = length;
    keywords[keyword_count].human_readable_text = human_readable_text;
    keywords[keyword_count].human_readable_length = string_length(human_readable_text);
    keyword_count++;
end

@define TOKEN_COUNT 100000
struct Token
    uint64 type;
    uint64 line;
    uint64 column;
    uint64 length;
    pointer text;
end

Token[TOKEN_COUNT] tokens;
uint64 token_count = 0;

uint64 line = 1;
uint64 column = 1;

proc is_whitespace(uint8 c) -> uint64
code
    return c == ' ' or c == '\n' or c == '\r' or c == '\t';
end

proc is_alpha(uint8 c) -> uint64
vars
    uint64 _is_lowercase = 0;
    uint64 _is_uppercase = 0;
code
    _is_lowercase = c >= 'a' and c <= 'z';
    _is_uppercase = c >= 'A' and c <= 'Z';
    return _is_lowercase or _is_uppercase or c == '_';
end

proc is_digit(uint8 c) -> uint64
code
    return c >= '0' and c <= '9';
end

proc is_hex_digit(uint8 c) -> uint64
vars
    uint64 _is_lowercase = 0;
    uint64 _is_uppercase = 0;
code
    _is_lowercase = c >= 'a' and c <= 'f';
    _is_uppercase = c >= 'A' and c <= 'F';
    return is_digit(c) or _is_lowercase or _is_uppercase;
end

proc is_alphanumeric(uint8 c) -> uint64
code
    return is_alpha(c) or is_digit(c);
end

proc is_delimiter(uint8 c) -> uint64
code
    return  c == '(' or c == ')' or
            c == '[' or c == ']' or
            c == ',' or c == '.' or
            c == ';' or c == '@' or
            c == '&';
end

uint64 i = 0;

proc print_token_type(uint64 type)
vars
    uint64 _ptt_i = 0;
code
    _ptt_i = 0;
    while _ptt_i < keyword_count do
        if type == keywords[_ptt_i].type then
            print_nstring(keywords[_ptt_i].human_readable_text, keywords[_ptt_i].human_readable_length);
            return;
        end
        _ptt_i++;
    end
end

proc get_identifier_type(pointer text, uint64 length) -> uint64
vars
    uint64 _git_i = 0;
code
    _git_i = 0;
    while _git_i < keyword_count do
        if string_compare(text, keywords[_git_i].text, length, keywords[_git_i].length) then
            return keywords[_git_i].type;
        end
        _git_i++;
    end
    return TOKEN_IDENTIFIER;
end

proc get_symbol_type(uint64 symbol) -> uint64
vars
    uint8 _symbol = 0;
code
    _symbol = symbol;
    if _symbol == '(' then
        return TOKEN_OPEN_PAREN;
    else if _symbol == ')' then
        return TOKEN_CLOSE_PAREN;
    else if _symbol == '[' then
        return TOKEN_OPEN_BRACKET;
    else if _symbol == ']' then
        return TOKEN_CLOSE_BRACKET;
    else if _symbol == ',' then
        return TOKEN_COMMA;
    else if _symbol == '.' then
        return TOKEN_DOT;
    else if _symbol == ';' then
        return TOKEN_SEMICOLON;
    else if _symbol == '@' then
        return TOKEN_AT;
    else if _symbol == '&' then
        return TOKEN_AMPERSAND;
    else
        print_string("Unknown symbol: '");
        str_number = to_string(_symbol);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("'\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end end end end end end
end

// Data types
add_keyword(TOKEN_UINT8,  "uint8",  5, "TOKEN_TYPE_UINT8");
add_keyword(TOKEN_UINT16, "uint16", 6, "TOKEN_TYPE_UINT16");
add_keyword(TOKEN_UINT32, "uint32", 6, "TOKEN_TYPE_UINT32");
add_keyword(TOKEN_UINT64, "uint64", 6, "TOKEN_TYPE_UINT64");
add_keyword(TOKEN_INT8,   "int8",   4, "TOKEN_TYPE_INT8");
add_keyword(TOKEN_INT16,  "int16",  5, "TOKEN_TYPE_INT16");
add_keyword(TOKEN_INT32,  "int32",  5, "TOKEN_TYPE_INT32");
add_keyword(TOKEN_INT64,  "int64",  5, "TOKEN_TYPE_INT64");
add_keyword(TOKEN_BOOL,   "bool",   4, "TOKEN_TYPE_BOOL");
add_keyword(TOKEN_CHAR,   "char",   4, "TOKEN_TYPE_CHAR");

add_keyword(TOKEN_IDENTIFIER, NULL, NULL, "TOKEN_TYPE_IDENTIFIER");

// Symbols
add_keyword(TOKEN_OPEN_PAREN,    NULL, NULL, "TOKEN_TYPE_OPEN_PAREN");
add_keyword(TOKEN_CLOSE_PAREN,   NULL, NULL, "TOKEN_TYPE_CLOSE_PAREN");
add_keyword(TOKEN_OPEN_BRACKET,  NULL, NULL, "TOKEN_TYPE_OPEN_BRACKET");
add_keyword(TOKEN_CLOSE_BRACKET, NULL, NULL, "TOKEN_TYPE_CLOSE_BRACKET");
add_keyword(TOKEN_COMMA,         NULL, NULL, "TOKEN_TYPE_COMMA");
add_keyword(TOKEN_DOT,           NULL, NULL, "TOKEN_TYPE_DOT");
add_keyword(TOKEN_SEMICOLON,     NULL, NULL, "TOKEN_TYPE_SEMICOLON");
add_keyword(TOKEN_AT,            NULL, NULL, "TOKEN_TYPE_AT");
add_keyword(TOKEN_AMPERSAND,     NULL, NULL, "TOKEN_TYPE_AMPERSAND");

// Logical operators
add_keyword(TOKEN_ASSIGNMENT, NULL, NULL, "TOKEN_TYPE_ASSIGNMENT");
add_keyword(TOKEN_EQUALS,     NULL, NULL, "TOKEN_TYPE_EQUALS");
add_keyword(TOKEN_NOT,        NULL, NULL, "TOKEN_TYPE_NOT");
add_keyword(TOKEN_NOT_EQUALS, NULL, NULL, "TOKEN_TYPE_NOT_EQUALS");

// Arithmetic operators
add_keyword(TOKEN_PLUS, "+", 1, "TOKEN_TYPE_PLUS");
add_keyword(TOKEN_PLUS_EQUALS, "+=", 2, "TOKEN_TYPE_PLUS_EQUALS");
add_keyword(TOKEN_INCREMENT, "++", 2, "TOKEN_TYPE_INCREMENT");
add_keyword(TOKEN_MINUS, "-", 1, "TOKEN_TYPE_MINUS");
add_keyword(TOKEN_MINUS_EQUALS, "-=", 2, "TOKEN_TYPE_MINUS_EQUALS");
add_keyword(TOKEN_ARROW, "->", 2, "TOKEN_TYPE_ARROW");
add_keyword(TOKEN_DECREMENT, "--", 2, "TOKEN_TYPE_DECREMENT");
add_keyword(TOKEN_MULTIPLY, "*", 1, "TOKEN_TYPE_MULTIPLY");
add_keyword(TOKEN_MULTIPLY_EQUALS, "*=", 2, "TOKEN_TYPE_MULTIPLY_EQUALS");
add_keyword(TOKEN_DIVIDE, "/", 1, "TOKEN_TYPE_DIVIDE");
add_keyword(TOKEN_DIVIDE_EQUALS, "/=", 2, "TOKEN_TYPE_DIVIDE_EQUALS");
add_keyword(TOKEN_MODULO, "%%", 1, "TOKEN_TYPE_MODULO");
add_keyword(TOKEN_MODULO_EQUALS, "%%=", 2, "TOKEN_TYPE_MODULO_EQUALS");

add_keyword(TOKEN_LSHIFT, "<<", 1, "TOKEN_TYPE_LEFT_SHIFT");
add_keyword(TOKEN_RSHIFT, ">>", 1, "TOKEN_TYPE_LEFT_SHIFT");

// Comparison operators
add_keyword(TOKEN_LESS_THAN, "<", 1, "TOKEN_TYPE_LESS_THAN");
add_keyword(TOKEN_LESS_THAN_EQUALS, "<=", 2, "TOKEN_TYPE_LESS_THAN_EQUALS");
add_keyword(TOKEN_GREATER_THAN, ">", 1, "TOKEN_TYPE_GREATER_THAN");
add_keyword(TOKEN_GREATER_THAN_EQUALS, ">=", 2, "TOKEN_TYPE_GREATER_THAN_EQUALS");

// Literals
add_keyword(TOKEN_LITERAL_INT, NULL, NULL, "TOKEN_TYPE_LITERAL_INT");
add_keyword(TOKEN_LITERAL_STRING, NULL, NULL, "TOKEN_TYPE_LITERAL_STRING");
add_keyword(TOKEN_LITERAL_CHAR, NULL, NULL, "TOKEN_TYPE_LITERAL_CHAR");

// Keywords
add_keyword(TOKEN_PROC_DECL, "proc", 4, "TOKEN_TYPE_PROC_DECL");
add_keyword(TOKEN_END, "end", 3, "TOKEN_TYPE_END");
add_keyword(TOKEN_RETURN, "return", 6, "TOKEN_TYPE_RETURN");
add_keyword(TOKEN_ASSERT, "assert", 6, "TOKEN_TYPE_ASSERT");
add_keyword(TOKEN_TRUE, "true", 4, "TOKEN_TYPE_TRUE");
add_keyword(TOKEN_FALSE, "false", 5, "TOKEN_TYPE_FALSE");

add_keyword(TOKEN_IF, "if", 2, "TOKEN_TYPE_IF");
add_keyword(TOKEN_THEN, "then", 4, "TOKEN_TYPE_THEN");
add_keyword(TOKEN_ELSE, "else", 4, "TOKEN_TYPE_ELSE");
add_keyword(TOKEN_ELIF, "elif", 4, "TOKEN_TYPE_ELIF");

proc lex_identifier()
vars
    uint64 _lit_type = 0;
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    while is_alphanumeric(*file_contents) and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end

    tokens[token_count].type = get_identifier_type(tokens[token_count].text, tokens[token_count].length);

    token_count++;
end

proc lex_delimiter()
code
    tokens[token_count].type = get_symbol_type(*file_contents);
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    token_count++;
end

proc lex_hex_number()
code
    file_contents++;
    i++;
    column++;
    tokens[token_count].length = tokens[token_count].length + 1;
    while is_hex_digit(*file_contents) and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end
end

proc lex_decimal_number()
code
    while is_digit(*file_contents) and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end
end

proc is_math_symbol(uint8 c) -> uint64
code    
    return c == '+' or c == '-' or c == '*' or c == '/' or c == '%';
end

proc lex_number()
code
    tokens[token_count].type = TOKEN_LITERAL_INT;
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == 'x' or *file_contents == 'X' then
        lex_hex_number();
    else
        lex_decimal_number();
    end

    if is_whitespace(*file_contents) or is_delimiter(*file_contents) or is_math_symbol(*file_contents) or i >= file_size then
    else
        print_string("Invalid number\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        exit(1);
    end

    token_count++;
end

proc lex_string()
code
    tokens[token_count].type = TOKEN_LITERAL_STRING;
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    while *file_contents != '\"' and i < file_size do
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end

    if *file_contents == '\"' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    else
        print_string("Invalid string\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        exit(1);
    end

    token_count++;
end

proc lex_character()
code
    tokens[token_count].type = TOKEN_LITERAL_CHAR;
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '\\' and i < file_size then
        file_contents = file_contents + 2;
        i = i + 2;
        column = column + 2;
        tokens[token_count].length = tokens[token_count].length + 2;
    else
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    end

    if *file_contents == '\'' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = tokens[token_count].length + 1;
    else
        if tokens[token_count].length > 1 then
            print_string("Invalid character\n");
            print_string("Line: ");
            str_number = to_string(line);
            print_nstring(str_number, &buffer + buffer_size - str_number);
            print_string(" Column: ");
            str_number = to_string(column);
            print_nstring(str_number, &buffer + buffer_size - str_number);
            exit(1);
        end
    end

    token_count++;
end

proc lex_equals()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_EQUALS;
    else
        tokens[token_count].type = TOKEN_ASSIGNMENT;
    end

    token_count++;
end

proc lex_not()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_NOT_EQUALS;
    else
        tokens[token_count].type = TOKEN_NOT;
    end

    token_count++;
end

proc lex_less_than()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_LESS_THAN_EQUALS;
    else if *file_contents == '<' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_LSHIFT;
    else
        tokens[token_count].type = TOKEN_LESS_THAN;
    end end

    token_count++;
end

proc lex_greater_than()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    i++;
    column++;

    if *file_contents == '=' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_GREATER_THAN_EQUALS;
    else if *file_contents == '>' then
        file_contents++;
        i++;
        column++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_RSHIFT;
    else
        tokens[token_count].type = TOKEN_GREATER_THAN;
    end end

    token_count++;
end

proc lex_plus()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_PLUS_EQUALS;
    else if *file_contents == '+' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_INCREMENT;
    else
        tokens[token_count].type = TOKEN_PLUS;
    end end

    token_count++;
end

proc lex_minus()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_MINUS_EQUALS;
    else if *file_contents == '>' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_ARROW;
    else if *file_contents == '-' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_DECREMENT;
    else
        tokens[token_count].type = TOKEN_MINUS;
    end end end

    token_count++;
end

proc lex_multiply()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_MULTIPLY_EQUALS;
    else
        tokens[token_count].type = TOKEN_MULTIPLY;
    end

    token_count++;
end

proc lex_divide()
code
    file_contents++;
    column++;
    i++;
    if *file_contents == '=' then
        tokens[token_count].text = file_contents - 1;
        tokens[token_count].line = line;
        tokens[token_count].column = column;
        tokens[token_count].length = 2;

        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_DIVIDE_EQUALS;

        token_count++;
    else if *file_contents == '/' then
        while *file_contents != '\n' and i < file_size do
            file_contents++;
            i++;
        end
    else
        tokens[token_count].text = file_contents - 1;
        tokens[token_count].line = line;
        tokens[token_count].column = column;
        tokens[token_count].length = 1;
        tokens[token_count].type = TOKEN_DIVIDE;

        token_count++;
    end end
end

proc lex_modulo()
code
    tokens[token_count].text = file_contents;
    tokens[token_count].line = line;
    tokens[token_count].column = column;
    tokens[token_count].length = 1;

    file_contents++;
    column++;
    i++;

    if *file_contents == '=' then
        file_contents++;
        column++;
        i++;
        tokens[token_count].length = 2;
        tokens[token_count].type = TOKEN_MODULO_EQUALS;
    else
        tokens[token_count].type = TOKEN_MODULO;
    end

    token_count++;
end

while i < file_size do
    if is_alpha(*file_contents) then
        lex_identifier();
    else if is_delimiter(*file_contents) then
        lex_delimiter();
    else if is_digit(*file_contents) then
        lex_number();
    else if *file_contents == '\n' then
        line++;
        column = 1;
        file_contents++;
        i++;
    else if *file_contents == '\r' then
        file_contents++;
        i++;
    else if *file_contents == ' ' then
        file_contents++;
        column++;
        i++;
    else if *file_contents == '\"' then
        lex_string();
    else if *file_contents == '\'' then
        lex_character();
    else if *file_contents == '=' then
        lex_equals();
    else if *file_contents == '!' then
        lex_not();
    else if *file_contents == '<' then
        lex_less_than();
    else if *file_contents == '>' then
        lex_greater_than();
    else if *file_contents == '+' then
        lex_plus();
    else if *file_contents == '-' then
        lex_minus();
    else if *file_contents == '*' then
        lex_multiply();
    else if *file_contents == '/' then
        lex_divide();
    else if *file_contents == '%' then
        lex_modulo();
    else
        print_string("Unknown character: '");
        print_nstring(file_contents, 1);
        print_string("'\n");
        print_string("Line: ");
        str_number = to_string(line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end end end end end end end end end end end end end end
end

if DEBUG_LEXER then
    str_number = to_string(token_count);
    print_string("Token count: ");
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");

    i = 0;
    while i < token_count do
        print_token_type(tokens[i].type);
        print_string(" text:");
        print_nstring(tokens[i].text, tokens[i].length);
        print_string(" line:");
        str_number = to_string(tokens[i].line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" col:");
        str_number = to_string(tokens[i].column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        i++;
    end
end

// =================================================================================================
// Parser
// =================================================================================================

uint64 token_index = 0;

proc unexpected_token()
code
    print_string("Unexpected token: ");
    print_token_type(tokens[token_index].type);
    print_string("\nLine: ");
    str_number = to_string(tokens[token_index].line);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string(" Column: ");
    str_number = to_string(tokens[token_index].column);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");
    exit(1);
end

proc unknown_identifier()
code
    print_string("Unknown word: ");
    print_nstring(tokens[token_index].text, tokens[token_index].length);
    print_string("\nLine: ");
    str_number = to_string(tokens[token_index].line);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string(" Column: ");
    str_number = to_string(tokens[token_index].column);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");
    exit(1);
end

proc redeclared_identifier()
code
    print_string("Identifier redeclared: ");
    print_nstring(tokens[token_index].text, tokens[token_index].length);
    print_string("\nLine: ");
    str_number = to_string(tokens[token_index].line);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string(" Column: ");
    str_number = to_string(tokens[token_index].column);
    print_nstring(str_number, &buffer + buffer_size - str_number);
    print_string("\n");
    exit(1);
end

proc is_data_type_token(uint64 type) -> uint64
code
    return type == TOKEN_UINT8 or type == TOKEN_UINT16 or type == TOKEN_UINT32 or type == TOKEN_UINT64 or
           type == TOKEN_INT8 or type == TOKEN_INT16 or type == TOKEN_INT32 or type == TOKEN_INT64 or
           type == TOKEN_BOOL;
end

proc consume_token(uint64 type)
code
    if token_index >= token_count then
        print_string("Unexpected end of file\n");
        exit(1);
    end
    
    if tokens[token_index].type != type then
        print_string("Expected token: ");
        print_token_type(type);
        print_string(" but got: ");
        print_token_type(tokens[token_index].type);
        print_string("\nLine: ");
        str_number = to_string(tokens[token_index].line);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string(" Column: ");
        str_number = to_string(tokens[token_index].column);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end
    token_index++;
end

struct Procedure
    pointer name;
    uint64 name_length;
    uint64 variable_count;
    uint64 first_variable_index;
    uint64 last_variable_index;
    uint64 param_count;
    uint64 first_param_index;
    uint64 last_param_index;
    uint64 statement_count;
    uint64 first_statement_index;
    uint64 last_statement_index;
    uint64 return_type;
end

@define PROCEDURE_COUNT 1000

Procedure[PROCEDURE_COUNT] procedures;
uint64 procedure_count = 0;

@define VARIABLE_SCOPE_GLOBAL 0

uint64 current_scope = 1;

enum Primitive_Types
    PRIMITIVE_ANY = 0,
    PRIMITIVE_UINT8,
    PRIMITIVE_UINT16,
    PRIMITIVE_UINT32,
    PRIMITIVE_UINT64,
    PRIMITIVE_INT8,
    PRIMITIVE_INT16,
    PRIMITIVE_INT32,
    PRIMITIVE_INT64,
    PRIMITIVE_BOOL,
    PRIMITIVE_CHAR,
    PRIMITIVE_STRUCT,
end

struct Data_Type
    uint64 type;
    uint64 size;
    uint64 is_primitive;
    pointer name;
    uint64 name_length;
end

@define DATA_TYPE_COUNT 1000
Data_Type[DATA_TYPE_COUNT] data_types;
uint64 data_type_count = 0;

proc add_data_type(uint64 type, uint64 size, uint64 is_primitive, pointer name, uint64 name_length)
code
    if data_type_count >= DATA_TYPE_COUNT then
        print_string("Data type count exceeded\n");
        exit(1);
    end

    data_types[data_type_count].type = type;
    data_types[data_type_count].size = size;
    data_types[data_type_count].is_primitive = is_primitive;
    data_types[data_type_count].name = name;
    data_types[data_type_count].name_length = name_length;
    data_type_count++;
end

proc init_data_types()
code
    add_data_type(PRIMITIVE_UINT8, 1, 1, NULL, NULL);
    add_data_type(PRIMITIVE_UINT16, 2, 1, NULL, NULL);
    add_data_type(PRIMITIVE_UINT32, 4, 1, NULL, NULL);
    add_data_type(PRIMITIVE_UINT64, 8, 1, NULL, NULL);
    add_data_type(PRIMITIVE_INT8, 1, 1, NULL, NULL);
    add_data_type(PRIMITIVE_INT16, 2, 1, NULL, NULL);
    add_data_type(PRIMITIVE_INT32, 4, 1, NULL, NULL);
    add_data_type(PRIMITIVE_INT64, 8, 1, NULL, NULL);
    add_data_type(PRIMITIVE_BOOL, 1, 1, NULL, NULL);
    add_data_type(PRIMITIVE_CHAR, 1, 1, NULL, NULL);
end

enum VariableKind
    VARIABLE_KIND_PARAMETER = 1,
    VARIABLE_KIND_LOCAL,
end

struct Variable
    pointer name;
    uint64 name_length;
    uint64 data_type;
    uint64 rbp_offset; // for local variables
    uint64 initial_value;
    uint64 scope;
    uint64 kind;
    uint64 next_variable_index;
end

@define VARIABLE_COUNT 1000

Variable[VARIABLE_COUNT] variables;
uint64 variable_count = 0;

enum Operation_Type
    OPERATION_ASSIGNMENT = 1,
    OPERATION_ADD,
    OPERATION_SUBTRACT,
    OPERATION_MULTIPLY,
    OPERATION_DIVIDE,
    OPERATION_MODULO,
    OPERATION_EQUALS,
    OPERATION_NOT_EQUALS,
    OPERATION_LESS_THAN,
    OPERATION_LESS_THAN_EQUALS,
    OPERATION_GREATER_THAN,
    OPERATION_GREATER_THAN_EQUALS,
    OPERATION_LEFT_SHIFT,
    OPERATION_RIGHT_SHIFT,
    OPERATION_UNARY_MINUS,
    OPERATION_UNARY_LOGICAL_NOT,
    // 17
    OPERATION_VALUE,
    OPERATION_ASSERT,
    OPERATION_IF,
    OPERATION_PROCEDURE_CALL,
    OPERATION_RETURN,
end

enum Term_Type
    TERM_TYPE_LITERAL_INT = 1,
    TERM_TYPE_LITERAL_STRING,
    TERM_TYPE_LITERAL_CHAR,
    TERM_TYPE_LITERAL_BOOL,
    TERM_TYPE_VARIABLE,
    TERM_TYPE_UNARY_OPERATION,
    TERM_TYPE_BINARY_OPERATION,
    TERM_TYPE_PROCEDURE_CALL,
end

struct Operation
    uint64 type;
    uint64 value_type;
    uint64 result_type;
    uint64 left_index;
    uint64 left_data_type;
    uint64 right_index;
    uint64 right_data_type;
end


@define BINARY_OP_COUNT 1000
Operation[BINARY_OP_COUNT] operations;
uint64 operations_count = 0;

struct Conditional_Code
    uint64 block_index;
    uint64 op_condition_index;
    uint64 statements_count;
    uint64 first_statement_index;
    uint64 last_statement_index;
    uint64 next_index;
end

struct If_Statement
    uint64 block_index;
    uint64 conditionals_count;
    uint64 first_conditional_index;
    uint64 last_conditional_index;
    uint64 else_index;
end

@define CONDITIONAL_COUNT 1000
Conditional_Code[CONDITIONAL_COUNT] conditionals;
uint64 conditionals_count = 0;

@define IF_STATEMENT_COUNT 1000
If_Statement[IF_STATEMENT_COUNT] if_structs;
uint64 if_structs_count = 0;

// This is used to uniquely identify a block of code. It is used to jump to the end of the block
uint64 block_scope_index = 0; 

proc create_conditional_code(uint64 op_condition_index) -> uint64
code
    if conditionals_count >= CONDITIONAL_COUNT then
        print_string("Conditional count exceeded\n");
        exit(1);
    end

    conditionals[conditionals_count].op_condition_index = op_condition_index;
    conditionals[conditionals_count].block_index = block_scope_index;
    conditionals[conditionals_count].statements_count = 0;
    conditionals[conditionals_count].first_statement_index = NOT_FOUND;
    conditionals[conditionals_count].last_statement_index = NOT_FOUND;
    conditionals[conditionals_count].next_index = NOT_FOUND;
    
    conditionals_count++;
    block_scope_index++;

    return conditionals_count - 1;
end

proc create_if_struct(uint64 conditional_index) -> uint64
code
    if if_structs_count >= IF_STATEMENT_COUNT then
        print_string("If statement count exceeded\n");
        exit(1);
    end

    if_structs[if_structs_count].block_index = block_scope_index;
    if_structs[if_structs_count].first_conditional_index = conditional_index;
    if_structs[if_structs_count].last_conditional_index = conditional_index;
    if_structs[if_structs_count].conditionals_count = 1;
    if_structs[if_structs_count].else_index = NOT_FOUND;

    if_structs_count++;
    block_scope_index++;

    return if_structs_count - 1;
end

proc add_conditional_to_if_struct(uint64 if_struct_index, uint64 conditional_index)
vars
    uint64 aci_last_conditional_index = 0;
code
    // Get last conditional index
    aci_last_conditional_index = if_structs[if_struct_index].last_conditional_index;
    
    // Set next index of last conditional to current conditional
    conditionals[aci_last_conditional_index].next_index = conditional_index;

    // Set last conditional index of if struct to current conditional
    if_structs[if_struct_index].conditionals_count = if_structs[if_struct_index].conditionals_count + 1;
    if_structs[if_struct_index].last_conditional_index = conditional_index;
end

proc are_data_types_compatible(uint64 left_data_type, uint64 right_data_type) -> uint64
code
    // print_string("Checking if data types are compatible: ");
    // print_number(left_data_type);
    // print_string(" and ");
    // print_number(right_data_type);
    // print_string("\n");

    if left_data_type == PRIMITIVE_ANY or right_data_type == PRIMITIVE_ANY then
        return 1;
    end

    if left_data_type == right_data_type then
        return 1;
    end

    return 0;
end

proc add_operation(uint64 type, uint64 left_index, uint64 value_type, uint64 right_index, uint64 left_data_type, uint64 right_data_type) -> uint64
vars
    uint64 ao_left_data_type = 0;
    uint64 ao_right_data_type = 0;
code
    if operations_count >= BINARY_OP_COUNT then
        print_string("Binary operation count exceeded\n");
        exit(1);
    end

    // Check if left and right data types are compatible
    if are_data_types_compatible(left_data_type, right_data_type) == 0 then
        token_index = token_index - 1;
        print_string("Incompatible data types: ");
        print_number(left_data_type);
        print_string(" and ");
        print_number(right_data_type);
        print_string("\nLine: ");
        print_number(tokens[token_index].line);
        print_string(" Column: ");
        print_number(tokens[token_index].column);
        print_string("\n");
        exit(1);
    end

    operations[operations_count].type = type;
    operations[operations_count].value_type = value_type;
    operations[operations_count].left_index = left_index;
    operations[operations_count].right_index = right_index;
    operations[operations_count].left_data_type = left_data_type;
    operations[operations_count].right_data_type = right_data_type;

    operations[operations_count].result_type = left_data_type;
   
    operations_count++;

    return operations_count - 1;
end

struct Statement
    uint64 op_index;
    uint64 next_index;
    uint64 prev_index;
end

@define STATEMENT_COUNT 1000
Statement[STATEMENT_COUNT] statements;
uint64 statement_count = 0;

proc create_statement(uint64 op_index, uint64 next_index, uint64 prev_index) -> uint64
code
    debug_string("Adding statement\n");
    if statement_count >= STATEMENT_COUNT then
        print_string("Statement count exceeded\n");
        exit(1);
    end

    statements[statement_count].op_index = op_index;
    statements[statement_count].next_index = next_index;
    statements[statement_count].prev_index = prev_index;
    statement_count++;

    return statement_count - 1;
end

proc add_procedure(pointer name, uint64 name_length) -> uint64
code
    if procedure_count >= PROCEDURE_COUNT then
        print_string("Procedure count exceeded\n");
        exit(1);
    end

    procedures[procedure_count].name = name;
    procedures[procedure_count].name_length = name_length;
    procedures[procedure_count].variable_count = 0;
    procedures[procedure_count].first_variable_index = NONE;
    procedures[procedure_count].last_variable_index = NONE;
    procedures[procedure_count].param_count = 0;
    procedures[procedure_count].first_param_index = NONE;
    procedures[procedure_count].last_param_index = NONE;
    procedures[procedure_count].statement_count = 0;
    procedures[procedure_count].first_statement_index = NONE;
    procedures[procedure_count].last_statement_index = NONE;
    procedures[procedure_count].return_type = NONE;
    
    procedure_count++;

    return procedure_count - 1;
end

proc update_procedure_return_type(uint64 procedure_index, uint64 return_type)
code
    procedures[procedure_index].return_type = return_type;
end

proc find_procedure(pointer name, uint64 name_length) -> uint64
vars
    uint64 fp_i = 0;
code
    fp_i = 0;
    while fp_i < procedure_count do
        if string_compare(name, procedures[fp_i].name, name_length, procedures[fp_i].name_length) then
            return fp_i;
        end
        fp_i++;
    end
    return 0 - 1; // only uint64 are supported, so this is the best we can do
end

proc add_variable_to_procedure(uint64 variable_index)
vars
    uint64 avtp_current_proc = 0;
    uint64 avtp_last_variable_index = 0;
code
    debug_string("Adding variable to procedure\n");
    avtp_current_proc = procedure_count - 1;
    if procedures[avtp_current_proc].first_variable_index == NOT_FOUND then
        procedures[avtp_current_proc].first_variable_index = variable_index;
        procedures[avtp_current_proc].last_variable_index = variable_index;
    else
        avtp_last_variable_index = procedures[avtp_current_proc].last_variable_index;
        variables[avtp_last_variable_index].next_variable_index = variable_index;
        procedures[avtp_current_proc].last_variable_index = variable_index;
    end

    // Set variable index
    variables[variable_index].rbp_offset = procedures[avtp_current_proc].variable_count * 8 + 8;

    procedures[avtp_current_proc].variable_count = procedures[avtp_current_proc].variable_count + 1;
end

proc add_param_to_procedure(uint64 param_index)
vars
    uint64 aptp_current_proc = 0;
    uint64 aptp_last_param_index = 0;
code
    debug_string("Adding param to procedure\n");
    aptp_current_proc = procedure_count - 1;
    if procedures[aptp_current_proc].first_param_index == NOT_FOUND then
        procedures[aptp_current_proc].first_param_index = param_index;
        procedures[aptp_current_proc].last_param_index = param_index;
    else
        aptp_last_param_index = procedures[aptp_current_proc].last_param_index;
        variables[aptp_last_param_index].next_variable_index = param_index;
        procedures[aptp_current_proc].last_param_index = param_index;
    end

    // Set variable index
    variables[param_index].rbp_offset = procedures[aptp_current_proc].param_count * 8 + 16;

    procedures[aptp_current_proc].param_count = procedures[aptp_current_proc].param_count + 1;
end

proc add_variable(pointer name, uint64 name_length, uint64 data_type, uint64 initial_value, uint64 scope, uint64 kind)
code
    if variable_count >= VARIABLE_COUNT then
        print_string("Variable count exceeded\n");
        exit(1);
    end

    variables[variable_count].name = name;
    variables[variable_count].name_length = name_length;
    variables[variable_count].data_type = data_type;
    variables[variable_count].initial_value = initial_value;
    variables[variable_count].scope = scope;
    variables[variable_count].kind = kind;

    print_string("Kind: ");
    print_number(kind);
    print_string("\n");

    if scope != VARIABLE_SCOPE_GLOBAL then
        if kind == VARIABLE_KIND_LOCAL then
            print_string("Adding local variable\n");
            variables[variable_count].rbp_offset = 0;
            add_variable_to_procedure(variable_count);
        else if kind == VARIABLE_KIND_PARAMETER then
            print_string("Adding parameter\n");
            variables[variable_count].rbp_offset = 0;
            add_param_to_procedure(variable_count);
        else
            print_string("Unknown variable kind\n");
            exit(1);
        end end
    end

    variable_count++;
end

proc find_variable(uint64 token_index, uint64 scope) -> uint64
vars
    uint64 iv_i = 0;
code
    iv_i = 0;
    while iv_i < variable_count do
        if string_compare(tokens[token_index].text, variables[iv_i].name, tokens[token_index].length, variables[iv_i].name_length) and 
            variables[iv_i].scope == scope then
            return iv_i;
        end
        iv_i++;
    end
    return NOT_FOUND;
end

proc parse_identifier() -> uint64
code
    consume_token(TOKEN_IDENTIFIER);
    return token_index - 1;
end

proc parse_literal_int() -> uint64
vars
    uint64 _pli_i = 0;
code
    _pli_i = token_index;
    consume_token(TOKEN_LITERAL_INT);

    return to_number(tokens[_pli_i].text, tokens[_pli_i].length);
end

proc get_data_type(uint64 token_type) -> uint64
code
    if token_type == TOKEN_UINT8 then
        return PRIMITIVE_UINT8;
    else if token_type == TOKEN_UINT16 then
        return PRIMITIVE_UINT16;
    else if token_type == TOKEN_UINT32 then
        return PRIMITIVE_UINT32;
    else if token_type == TOKEN_UINT64 then
        return PRIMITIVE_UINT64;
    else if token_type == TOKEN_INT8 then
        return PRIMITIVE_INT8;
    else if token_type == TOKEN_INT16 then
        return PRIMITIVE_INT16;
    else if token_type == TOKEN_INT32 then
        return PRIMITIVE_INT32;
    else if token_type == TOKEN_INT64 then
        return PRIMITIVE_INT64;
    else if token_type == TOKEN_BOOL then
        return PRIMITIVE_BOOL;
    else if token_type == TOKEN_CHAR then
        return PRIMITIVE_CHAR;
    else
        print_string("Unknown data type\n");
        exit(1);
    end end end end end end end end end end 
end

proc parse_variable_declaration(uint64 scope)
vars
    uint64 pvd_data_type = 0;
    uint64 pvd_identifier = 0;
    uint64 pvd_initial_value = 0;
code
    pvd_data_type = get_data_type(tokens[token_index].type);
    
    consume_token(tokens[token_index].type);
    pvd_identifier = parse_identifier();

    // Check if variable already exists
    if find_variable(pvd_identifier, scope) != NOT_FOUND then
        // revert token index to identifier for error message
        token_index = pvd_identifier;
        redeclared_identifier();
    end

    if tokens[token_index].type == TOKEN_ASSIGNMENT then
        consume_token(TOKEN_ASSIGNMENT);
        pvd_initial_value = parse_literal_int();
    else
        pvd_initial_value = 0;
    end

    consume_token(TOKEN_SEMICOLON);

    add_variable(tokens[pvd_identifier].text, tokens[pvd_identifier].length, pvd_data_type, pvd_initial_value, scope, VARIABLE_KIND_LOCAL);
end

proc parse_expression(uint64 scope) -> uint64;

proc parse_factor(uint64 scope) -> uint64
vars
    uint64 pe_term_index = 0;
    uint64 pe_var_index = 0;
    uint64 pe_var_type = 0;
    uint64 pe_op_index = 0;
    uint64 pe_param_count = 0;
code
    if tokens[token_index].type == TOKEN_OPEN_PAREN then
        consume_token(TOKEN_OPEN_PAREN);
        pe_op_index = parse_expression(scope);
        consume_token(TOKEN_CLOSE_PAREN);
        return pe_op_index;
    else if tokens[token_index].type == TOKEN_TRUE then
        consume_token(TOKEN_TRUE);
        return add_operation(OPERATION_VALUE, 1, TERM_TYPE_LITERAL_BOOL, 0, PRIMITIVE_BOOL, PRIMITIVE_ANY);
    else if tokens[token_index].type == TOKEN_FALSE then
        consume_token(TOKEN_FALSE);
        return add_operation(OPERATION_VALUE, 0, TERM_TYPE_LITERAL_BOOL, 0, PRIMITIVE_BOOL, PRIMITIVE_ANY);
    else if tokens[token_index].type == TOKEN_MINUS then
        consume_token(TOKEN_MINUS);
        if tokens[token_index].type == TOKEN_LITERAL_INT then
            // Unary minus on literal
            pe_term_index = 0 - parse_literal_int();
            return add_operation(OPERATION_VALUE, pe_term_index, TERM_TYPE_LITERAL_INT, 0, PRIMITIVE_INT64, PRIMITIVE_ANY);
        else 
            // Unary minus 
            pe_term_index = parse_factor(scope);
            return add_operation(OPERATION_UNARY_MINUS, pe_term_index, TERM_TYPE_UNARY_OPERATION, 0, 
                operations[pe_term_index].result_type, PRIMITIVE_ANY);
        end
    else if tokens[token_index].type == TOKEN_NOT then
        consume_token(TOKEN_NOT);
        pe_term_index = parse_factor(scope);
        return add_operation(OPERATION_UNARY_LOGICAL_NOT, pe_term_index, TERM_TYPE_UNARY_OPERATION, 0, PRIMITIVE_BOOL, PRIMITIVE_ANY);
    else if tokens[token_index].type == TOKEN_LITERAL_INT then
        pe_term_index = parse_literal_int();
        return add_operation(OPERATION_VALUE, pe_term_index, TERM_TYPE_LITERAL_INT, 0, PRIMITIVE_INT64, PRIMITIVE_ANY);
    else if tokens[token_index].type == TOKEN_IDENTIFIER then
        pe_term_index = parse_identifier();
        pe_var_index = find_variable(pe_term_index, scope);
        if pe_var_index != NOT_FOUND then
            print_string("Found variable: ");
            print_nstring(variables[pe_var_index].name, variables[pe_var_index].name_length);
            print_string("\n");

            pe_var_type = variables[pe_var_index].data_type;
            return add_operation(OPERATION_VALUE, pe_var_index, TERM_TYPE_VARIABLE, 0, pe_var_type, PRIMITIVE_ANY);
        else
            pe_var_index = find_procedure(tokens[pe_term_index].text, tokens[pe_term_index].length);
            if pe_var_index != NOT_FOUND then
                print_string("Found procedure: ");
                print_nstring(procedures[pe_var_index].name, procedures[pe_var_index].name_length);
                print_string(" (");
                print_number(pe_var_index);
                print_string(")\n");

                pe_var_type = procedures[pe_var_index].return_type;

                consume_token(TOKEN_OPEN_PAREN);

                pe_param_count = 0;
                while tokens[token_index].type != TOKEN_CLOSE_PAREN do
                    print_string("Found argument\n");
                    pe_param_count = pe_param_count + 1;
                    parse_expression(scope);
                    if tokens[token_index].type == TOKEN_COMMA then
                        consume_token(TOKEN_COMMA);
                    end
                end

                consume_token(TOKEN_CLOSE_PAREN);

                if pe_param_count != procedures[pe_var_index].param_count then
                    token_index = token_index - 1;
                    print_string("Incorrect number of parameters. Expected ");
                    print_number(procedures[pe_var_index].param_count);
                    print_string(" but got ");
                    print_number(pe_param_count);
                    print_string("\nLine: ");
                    print_number(tokens[token_index].line);
                    print_string(" Column: ");
                    print_number(tokens[token_index].column);
                    print_string("\n");
                    exit(1);
                end
                return add_operation(OPERATION_PROCEDURE_CALL, pe_var_index, TERM_TYPE_PROCEDURE_CALL, 0, pe_var_type, PRIMITIVE_ANY);
            else
                token_index = token_index - 1;
                unknown_identifier();
            end
        end
    else
        unexpected_token();
    end end end end end end end
end

proc parse_multiplicative_expression(uint64 scope) -> uint64
vars
    uint64 pme_op_index = 0;
    uint64 pme_right_index = 0;
    uint64 pme_op_type = 0;
code
    pme_op_index = parse_factor(scope);

    while 
        tokens[token_index].type == TOKEN_MULTIPLY or 
        tokens[token_index].type == TOKEN_DIVIDE or 
        tokens[token_index].type == TOKEN_MODULO
    do
        if tokens[token_index].type == TOKEN_MULTIPLY then
            consume_token(TOKEN_MULTIPLY);
            pme_op_type = OPERATION_MULTIPLY;
        else if tokens[token_index].type == TOKEN_DIVIDE then
            consume_token(TOKEN_DIVIDE);
            pme_op_type = OPERATION_DIVIDE;
        else
            consume_token(TOKEN_MODULO);
            pme_op_type = OPERATION_MODULO;
        end end
        pme_right_index = parse_factor(scope);

        pme_op_index = add_operation(pme_op_type, pme_op_index, TERM_TYPE_BINARY_OPERATION, pme_right_index, 
            operations[pme_op_index].result_type, 
            operations[pme_right_index].result_type);
    end

    return pme_op_index;
end

proc parse_additive_expression(uint64 scope) -> uint64
vars
    uint64 pae_op_index = 0;
    uint64 pae_right_index = 0;
    uint64 pae_op_type = 0;
code
    pae_op_index = parse_multiplicative_expression(scope);

    while tokens[token_index].type == TOKEN_PLUS or tokens[token_index].type == TOKEN_MINUS do
        if tokens[token_index].type == TOKEN_PLUS then
            consume_token(TOKEN_PLUS);
            pae_op_type = OPERATION_ADD;
        else
            consume_token(TOKEN_MINUS);
            pae_op_type = OPERATION_SUBTRACT;
        end
        pae_right_index = parse_multiplicative_expression(scope);

        pae_op_index = add_operation(pae_op_type, pae_op_index, TERM_TYPE_BINARY_OPERATION, pae_right_index, 
            operations[pae_op_index].result_type, 
            operations[pae_right_index].result_type);
    end
   
    return pae_op_index;
end

proc parse_shift_expression(uint64 scope) -> uint64
vars
    uint64 pse_op_index = 0;
    uint64 pse_right_index = 0;
    uint64 pse_op_type = 0;
code
    pse_op_index = parse_additive_expression(scope);

    while tokens[token_index].type == TOKEN_LSHIFT or tokens[token_index].type == TOKEN_RSHIFT do
        if tokens[token_index].type == TOKEN_LSHIFT then
            consume_token(TOKEN_LSHIFT);
            pse_op_type = OPERATION_LEFT_SHIFT;
        else
            consume_token(TOKEN_RSHIFT);
            pse_op_type = OPERATION_RIGHT_SHIFT;
        end
        pse_right_index = parse_additive_expression(scope);

        pse_op_index = add_operation(pse_op_type, pse_op_index, TERM_TYPE_BINARY_OPERATION, pse_right_index, 
            operations[pse_op_index].result_type, 
            operations[pse_right_index].result_type);
    end
   
    return pse_op_index;
end

proc parse_relational_expression(uint64 scope) -> uint64
vars
    uint64 pre_op_index = 0;
    uint64 pre_right_index = 0;
    uint64 pre_op_type = 0;
code
    pre_op_index = parse_shift_expression(scope);

    while 
        tokens[token_index].type == TOKEN_EQUALS or 
        tokens[token_index].type == TOKEN_NOT_EQUALS or 
        tokens[token_index].type == TOKEN_LESS_THAN or 
        tokens[token_index].type == TOKEN_LESS_THAN_EQUALS or 
        tokens[token_index].type == TOKEN_GREATER_THAN or 
        tokens[token_index].type == TOKEN_GREATER_THAN_EQUALS
    do
        if tokens[token_index].type == TOKEN_EQUALS then
            consume_token(TOKEN_EQUALS);
            pre_op_type = OPERATION_EQUALS;
        else if tokens[token_index].type == TOKEN_NOT_EQUALS then
            consume_token(TOKEN_NOT_EQUALS);
            pre_op_type = OPERATION_NOT_EQUALS;
        else if tokens[token_index].type == TOKEN_LESS_THAN then
            consume_token(TOKEN_LESS_THAN);
            pre_op_type = OPERATION_LESS_THAN;
        else if tokens[token_index].type == TOKEN_LESS_THAN_EQUALS then
            consume_token(TOKEN_LESS_THAN_EQUALS);
            pre_op_type = OPERATION_LESS_THAN_EQUALS;
        else if tokens[token_index].type == TOKEN_GREATER_THAN then
            consume_token(TOKEN_GREATER_THAN);
            pre_op_type = OPERATION_GREATER_THAN;
        else
            consume_token(TOKEN_GREATER_THAN_EQUALS);
            pre_op_type = OPERATION_GREATER_THAN_EQUALS;
        end end end end end
        pre_right_index = parse_shift_expression(scope);

        pre_op_index = add_operation(pre_op_type, pre_op_index, TERM_TYPE_BINARY_OPERATION, pre_right_index, 
            operations[pre_op_index].result_type, 
            operations[pre_right_index].result_type);
        // Hack to make relational expressions return a boolean
        operations[pre_op_index].result_type = PRIMITIVE_BOOL;
    end

    return pre_op_index;
end

proc parse_expression(uint64 scope) -> uint64
code
    return parse_relational_expression(scope);
end

proc add_statement_to_procedure(uint64 statement_index, uint64 proc_index)
vars
    uint64 astp_last_statement_index = 0;
code
    debug_string("Adding statement ");
    str_number = to_string(statement_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string(" to procedure ");
    str_number = to_string(proc_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string("\n");

    if procedures[proc_index].statement_count == 0 then
        procedures[proc_index].first_statement_index = statement_index;
    else
        astp_last_statement_index = procedures[proc_index].last_statement_index;
        statements[astp_last_statement_index].next_index = statement_index;
    end
    procedures[proc_index].last_statement_index = statement_index;

    procedures[proc_index].statement_count = procedures[proc_index].statement_count + 1;
end

proc parse_assert_statement(uint64 scope, uint64 proc_index) -> uint64
vars
    uint64 pas_expr_index = 0;
    uint64 pas_op_index = 0;
    uint64 pas_statement_index = 0;
code
    consume_token(TOKEN_ASSERT);
    consume_token(TOKEN_OPEN_PAREN);
    
    // Parse expression
    pas_expr_index = parse_expression(scope);
    pas_op_index = add_operation(OPERATION_ASSERT, pas_expr_index, TERM_TYPE_BINARY_OPERATION, 0, 
        operations[pas_expr_index].result_type, PRIMITIVE_ANY);

    // Check if expression is a boolean
    if operations[pas_op_index].result_type != PRIMITIVE_BOOL then
        token_index = token_index - 1;
        print_string("Assertion expression must be a boolean\nLine: ");
        print_number(tokens[token_index].line);
        print_string(" Column: ");
        print_number(tokens[token_index].column);
        print_string("\n");
        exit(1);
    end

    pas_statement_index = create_statement(pas_op_index, procedures[proc_index].last_statement_index, NULL);

    consume_token(TOKEN_CLOSE_PAREN);
    consume_token(TOKEN_SEMICOLON);

    return pas_statement_index;
end

proc parse_statement(uint64 scope, uint64 proc_index) -> uint64; // Forward declaration

proc add_statement_to_conditional(uint64 statement_index, uint64 conditional_index)
vars
    uint64 astc_last_statement_index = 0;
code
    debug_string("Adding statement ");
    str_number = to_string(statement_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string(" to conditional ");
    str_number = to_string(conditional_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string("\n");

    if conditionals[conditional_index].statements_count == 0 then
        conditionals[conditional_index].first_statement_index = statement_index;
    else
        astc_last_statement_index = conditionals[conditional_index].last_statement_index;
        statements[astc_last_statement_index].next_index = statement_index;
    end
    conditionals[conditional_index].last_statement_index = statement_index;

    conditionals[conditional_index].statements_count = conditionals[conditional_index].statements_count + 1;
end

proc parse_elif_statement(uint64 scope, uint64 proc_index) -> uint64
vars
    uint64 pes_expr_index = 0;
    uint64 pes_cond_index = 0;
    uint64 pes_else_cond_index = 0;
    uint64 pes_current_statement = 0;
code
    consume_token(TOKEN_ELIF);

    // conditional block(s) -> else (optional)
    // Parse expression
    pes_expr_index = parse_expression(scope);
    // Create a conditional code block from the expression
    pes_cond_index = create_conditional_code(pes_expr_index);

    consume_token(TOKEN_THEN);

    while tokens[token_index].type != TOKEN_END and tokens[token_index].type != TOKEN_ELSE and tokens[token_index].type != TOKEN_ELIF do
        debug_string("Parsing `elif` statement\n");
        pes_current_statement = parse_statement(scope, proc_index);

        // Some statements return NULL, like variable declarations
        // These should not be added to the conditional
        if pes_current_statement != NULL then
            add_statement_to_conditional(pes_current_statement, pes_cond_index);
        end
    end

    return pes_cond_index;
end

proc parse_if_statement(uint64 scope, uint64 proc_index) -> uint64
vars
    uint64 pis_expr_index = 0;
    uint64 pis_cond_index = 0;
    uint64 pis_next_cond_index = 0;
    uint64 pis_else_cond_index = 0;
    uint64 pis_if_struct_index = 0;
    uint64 pis_op_index = 0;
    uint64 pis_statement_index = 0;
    uint64 pis_current_statement = 0;
code 
    consume_token(TOKEN_IF);

    // proc -> statement -> operation(IF) -> if_struct -> conditional block(s) -> else (optional)
    // Parse expression
    pis_expr_index = parse_expression(scope);

    // Check if expression is a boolean
    if operations[pis_expr_index].result_type != PRIMITIVE_BOOL then
        token_index = token_index - 1;
        print_string("If expression must be a boolean\nLine: ");
        print_number(tokens[token_index].line);
        print_string(" Column: ");
        print_number(tokens[token_index].column);
        print_string("\n");
        exit(1);
    end

    // Create a conditional code block from the expression
    pis_cond_index = create_conditional_code(pis_expr_index);
    // Create an if struct to hold the conditional code block(s)
    pis_if_struct_index = create_if_struct(pis_cond_index);
    // Create an Operation for the if statement
    pis_op_index = add_operation(OPERATION_IF, pis_if_struct_index, NULL, NULL, PRIMITIVE_ANY, PRIMITIVE_ANY);
    // Create a Statement for the Operation
    pis_statement_index = create_statement(pis_op_index, procedures[proc_index].last_statement_index, NULL);

    consume_token(TOKEN_THEN);

    while tokens[token_index].type != TOKEN_END and tokens[token_index].type != TOKEN_ELSE and tokens[token_index].type != TOKEN_ELIF do
        debug_string("Parsing `then` statement\n");
        pis_current_statement = parse_statement(scope, proc_index);

        // Some statements return NULL, like variable declarations
        // These should not be added to the conditional
        if pis_current_statement != NULL then
            add_statement_to_conditional(pis_current_statement, pis_cond_index);
        end
    end

    while tokens[token_index].type == TOKEN_ELIF do
        pis_next_cond_index = parse_elif_statement(scope, proc_index);
        // conditionals[pis_cond_index].next_index = pis_next_cond_index;
        add_conditional_to_if_struct(pis_if_struct_index, pis_next_cond_index);
    end  

    if tokens[token_index].type == TOKEN_ELSE then
        consume_token(TOKEN_ELSE);
        debug_string("Parsed else\n");

        // Create a conditional code block from the expression
        pis_else_cond_index = create_conditional_code(NONE);
        // Add the conditional code block to the if struct
        if_structs[pis_if_struct_index].else_index = pis_else_cond_index;

        while tokens[token_index].type != TOKEN_END do
            debug_string("Parsing `else` statement\n");
            pis_current_statement = parse_statement(scope, proc_index);

            // Some statements return NULL, like variable declarations
            // These should not be added to the conditional
            if pis_current_statement != NULL then
                add_statement_to_conditional(pis_current_statement, pis_else_cond_index);
            end
        end
    end

    consume_token(TOKEN_END);

    return pis_statement_index;
end

proc parse_procedure_call(uint64 scope, uint64 proc_index) -> uint64
vars
    uint64 ppc_identifier = 0;
    uint64 ppc_proc_index = 0;
    uint64 ppc_op_index = 0;
    uint64 ppc_statement_index = 0;
    uint64 ppc_param_count = 0;
    uint64 ppc_first_arg_stmt_index = 0;
    uint64 ppc_arg_prev_stmt_index = 0;
    uint64 ppc_arg_stmt_index = 0;
    uint64 ppc_arg_op_index = 0;
code
    ppc_identifier = parse_identifier();

    ppc_proc_index = find_procedure(tokens[ppc_identifier].text, tokens[ppc_identifier].length);
    if ppc_proc_index != NOT_FOUND then
        consume_token(TOKEN_OPEN_PAREN);

        ppc_param_count = 0;
        ppc_first_arg_stmt_index = 0;
        ppc_arg_prev_stmt_index = NONE;
        while tokens[token_index].type != TOKEN_CLOSE_PAREN do
            ppc_arg_op_index = parse_expression(scope); 
            ppc_arg_stmt_index = create_statement(ppc_arg_op_index, NONE, NONE);
            // Update `next_index` of previous argument statement
            if ppc_arg_prev_stmt_index != NONE then
                statements[ppc_arg_prev_stmt_index].next_index = ppc_arg_stmt_index;
            end
            if ppc_param_count == 0 then
                // Save first argument statement index
                ppc_first_arg_stmt_index = ppc_arg_stmt_index;
            end
            print_string("Found argument\n");
            if tokens[token_index].type == TOKEN_COMMA then
                consume_token(TOKEN_COMMA);
            end
            ppc_arg_prev_stmt_index = ppc_arg_stmt_index;
            ppc_param_count = ppc_param_count + 1;
        end

        consume_token(TOKEN_CLOSE_PAREN);

        if ppc_param_count != procedures[ppc_proc_index].param_count then
            token_index = token_index - 1;
            print_string("Incorrect number of parameters. Expected ");
            print_number(procedures[ppc_proc_index].param_count);
            print_string(" but got ");
            print_number(ppc_param_count);
            print_string("\nLine: ");
            print_number(tokens[token_index].line);
            print_string(" Column: ");
            print_number(tokens[token_index].column);
            print_string("\n");
            exit(1);
        end

        ppc_op_index = add_operation(OPERATION_PROCEDURE_CALL, ppc_proc_index, TERM_TYPE_PROCEDURE_CALL, ppc_first_arg_stmt_index, PRIMITIVE_ANY, PRIMITIVE_ANY);

        ppc_statement_index = create_statement(ppc_op_index, procedures[proc_index].last_statement_index, NULL);

        consume_token(TOKEN_SEMICOLON);

        return ppc_statement_index;
    else
        token_index = token_index - 1;
        unknown_identifier();
    end
    return NONE;
end

proc parse_return_statement(uint64 scope, uint64 proc_index) -> uint64
vars 
    uint64 prs_expr_index = 0;
    uint64 prs_op_index = 0;
    uint64 prs_statement_index = 0;
    uint64 prs_proc_return_type = 0;
code
    prs_proc_return_type = procedures[proc_index].return_type;

    consume_token(TOKEN_RETURN);

    if tokens[token_index].type == TOKEN_SEMICOLON then
        if prs_proc_return_type == NONE then
            prs_op_index = add_operation(OPERATION_RETURN, NONE, NONE, NONE, PRIMITIVE_ANY, PRIMITIVE_ANY);
        else
            token_index = token_index - 1;
            print_string("Procedure must return a value\nLine: ");
            print_number(tokens[token_index].line);
            print_string(" Column: ");
            print_number(tokens[token_index].column);
            print_string("\n");
            exit(1);
        end
    else
        prs_expr_index = parse_expression(scope);

        print_string("Return expr index: ");
        print_number(prs_expr_index);
        print_string("\n");
        print_string("Return expr type: ");
        print_number(operations[prs_expr_index].type);
        print_string("\n");

        print_string("Return value type: ");
        print_number(operations[prs_expr_index].value_type);
        print_string("\n");
        prs_op_index = add_operation(OPERATION_RETURN, prs_expr_index, TERM_TYPE_UNARY_OPERATION, NONE, 
            operations[prs_expr_index].result_type, PRIMITIVE_ANY);
        
    end

    consume_token(TOKEN_SEMICOLON);

    prs_statement_index = create_statement(prs_op_index, procedures[proc_index].last_statement_index, NULL);

    return prs_statement_index;
end

proc parse_statement(uint64 scope, uint64 proc_index) -> uint64
vars
    uint64 ps_identifier = 0;
    uint64 ps_data_type = 0;
    uint64 ps_symbol_index = 0;
    uint64 ps_expr_index = 0;
    uint64 ps_op_index = 0;
    uint64 ps_statement_index = 0;
code
    if is_data_type_token(tokens[token_index].type) then
        parse_variable_declaration(scope);
        return NONE;
    else if tokens[token_index].type == TOKEN_ASSERT then
        return parse_assert_statement(scope, proc_index);
    else if tokens[token_index].type == TOKEN_IF then
        return parse_if_statement(scope, proc_index);
    else if tokens[token_index].type == TOKEN_RETURN then
        return parse_return_statement(scope, proc_index);
    else if tokens[token_index].type == TOKEN_IDENTIFIER then
        ps_identifier = parse_identifier();

        ps_symbol_index = find_variable(ps_identifier, scope);
        if ps_symbol_index != NOT_FOUND then
            ps_data_type = variables[ps_symbol_index].data_type;
        else
            ps_symbol_index = find_procedure(tokens[ps_identifier].text, tokens[ps_identifier].length);
            if ps_symbol_index != NOT_FOUND then
                token_index = token_index - 1; // revert token index 
                return parse_procedure_call(scope, proc_index);
            else
                token_index = token_index - 1;
                unknown_identifier();
            end
        end

        debug_string("Variable index is ");
        str_number = to_string(ps_symbol_index);
        debug_nstring(str_number, &buffer + buffer_size - str_number);
        debug_string("\n");

        debug_string("Variable Count is ");
        str_number = to_string(variable_count);
        debug_nstring(str_number, &buffer + buffer_size - str_number);
        debug_string("\n");

        if tokens[token_index] == TOKEN_ASSIGNMENT then
            consume_token(TOKEN_ASSIGNMENT);
        else
            unexpected_token();
        end

        ps_expr_index = parse_expression(scope);

        ps_op_index = add_operation(OPERATION_ASSIGNMENT, ps_symbol_index, TERM_TYPE_VARIABLE, ps_expr_index, 
            ps_data_type, 
            operations[ps_expr_index].result_type
        );

        debug_string("Added binary op index: ");
        str_number = to_string(ps_op_index);
        debug_nstring(str_number, &buffer + buffer_size - str_number);
        debug_string("\n");

        ps_statement_index = create_statement(ps_op_index, procedures[proc_index].last_statement_index, NULL);

        consume_token(TOKEN_SEMICOLON);

        return ps_statement_index;
    else
        unexpected_token();
    end end end end end
end

proc parse_param_declaration(uint64 scope, uint64 proc_index)
vars
    uint64 pad_data_type = 0;
    uint64 pad_identifier = 0;
code
    if is_data_type_token(tokens[token_index].type) then
        pad_data_type = get_data_type(tokens[token_index].type);
        consume_token(tokens[token_index].type);
        pad_identifier = parse_identifier();
    else    
        unexpected_token();
    end

    add_variable(tokens[pad_identifier].text, tokens[pad_identifier].length, pad_data_type, 0, scope, VARIABLE_KIND_PARAMETER);
end

proc parse_procedure_declaration(uint64 scope)
vars
    uint64 ppd_identifier = 0;
    uint64 ppd_proc_index = 0;
    uint64 ppd_current_statement = 0;
    uint64 ppd_param_index = 0;
    uint64 ppd_return_type = 0;
code
    consume_token(TOKEN_PROC_DECL);
    ppd_identifier = parse_identifier();

    // Check if procedure already exists
    if find_procedure(tokens[ppd_identifier].text, tokens[ppd_identifier].length) != NOT_FOUND then
        // revert token index to identifier for error message
        token_index = ppd_identifier;
        redeclared_identifier();
    end

    ppd_proc_index = add_procedure(tokens[ppd_identifier].text, tokens[ppd_identifier].length);

    consume_token(TOKEN_OPEN_PAREN);

    // Parse parameters
    while tokens[token_index].type != TOKEN_CLOSE_PAREN do
        ppd_param_index = parse_param_declaration(scope, ppd_proc_index);

        if tokens[token_index].type == TOKEN_COMMA then
            consume_token(TOKEN_COMMA);
        end
    end

    consume_token(TOKEN_CLOSE_PAREN);

    print_string("Procedure ");
    print_nstring(procedures[ppd_proc_index].name, procedures[ppd_proc_index].name_length);
    print_string("(");
    print_number(ppd_proc_index);
    print_string(") has ");
    print_number(procedures[ppd_proc_index].param_count);
    print_string(" parameters\n");

    if tokens[token_index].type == TOKEN_ARROW then
        consume_token(TOKEN_ARROW);
        ppd_return_type = get_data_type(tokens[token_index].type);
        consume_token(tokens[token_index].type);
        update_procedure_return_type(ppd_proc_index, ppd_return_type);
    end

    while tokens[token_index].type != TOKEN_END and token_index < token_count do
        ppd_current_statement = parse_statement(scope, ppd_proc_index);

        // Some statements return NULL, like variable declarations
        // These should not be added to the procedure
        if ppd_current_statement != NONE then
            add_statement_to_procedure(ppd_current_statement, ppd_proc_index);
        end
    end
    
    consume_token(TOKEN_END);
end

// Initialize primitive data types
init_data_types();

// Start parsing
while token_index < token_count do
    if is_data_type_token(tokens[token_index].type) then
        parse_variable_declaration(VARIABLE_SCOPE_GLOBAL);
    else if tokens[token_index].type == TOKEN_PROC_DECL then
        parse_procedure_declaration(current_scope);
        current_scope++;
    else
        unexpected_token();
    end end
end

// =================================================================================================
// Code generation
// =================================================================================================

proc is_comparison_operation(uint64 op_type) -> uint64
code
    return op_type == OPERATION_EQUALS or
           op_type == OPERATION_NOT_EQUALS or
           op_type == OPERATION_LESS_THAN or
           op_type == OPERATION_LESS_THAN_EQUALS or
           op_type == OPERATION_GREATER_THAN or
           op_type == OPERATION_GREATER_THAN_EQUALS;
end

uint64 output_file_handle = 0;

proc emit_nstring(uint64 handle, pointer text, uint64 length)
code
    WriteFile(handle, text, length, NULL, NULL);
end

proc emit_string(uint64 handle, pointer text)
vars
    uint64 es_length = 0;
code
    es_length = string_length(text);
    emit_nstring(handle, text, es_length);
end

proc emit_num_string(uint64 handle, uint64 number)
code
    str_number = to_string(number);
    emit_nstring(handle, str_number, &buffer + buffer_size - str_number);
end

proc write_header(uint64 file_handle)
code
    emit_string(file_handle, "; Generated by Strata v2.0\n\n");
    emit_string(file_handle, "bits 64\n");
    emit_string(file_handle, "default rel\n\n");

    emit_string(file_handle, "section .bss\n");
    emit_string(file_handle, "\t__std_output__ resq 1\n\n");

    emit_string(file_handle, "section .rodata\n");
    emit_string(file_handle, "\t__assert_failed__ db 'Assert failed', 0\n");
    emit_string(file_handle, "\t__assert_failed_length__ equ $ - __assert_failed__\n\n");

    emit_string(file_handle, "section .text\n");
    emit_string(file_handle, "\textern GetStdHandle\n");
    emit_string(file_handle, "\textern WriteConsoleA\n");
    emit_string(file_handle, "\textern ExitProcess\n");
    emit_string(file_handle, "\tglobal proc_main\n\n");

    emit_string(file_handle, "\tglobal init_program\n\n");
    emit_string(file_handle, "init_program:\n");
    emit_string(file_handle, "\tmov rcx, -11\n");
    emit_string(file_handle, "\tcall GetStdHandle\n");
    emit_string(file_handle, "\tmov [__std_output__], rax\n");
    emit_string(file_handle, "\tjmp proc_main\n\n");
    emit_string(file_handle, "assert_failed:\n");
    emit_string(file_handle, "\tmov rcx, [__std_output__]\n");
    emit_string(file_handle, "\tmov rdx, __assert_failed__\n");
    emit_string(file_handle, "\tmov r8, __assert_failed_length__\n");
    emit_string(file_handle, "\tmov r9, 0\n");
    emit_string(file_handle, "\tcall WriteConsoleA\n");
    emit_string(file_handle, "\tmov rcx, 1\n");
    emit_string(file_handle, "\tcall ExitProcess\n\n");
    emit_string(file_handle, "\tret\n\n");
end

proc write_var_init(uint64 file_handle, uint64 variable_index)
vars
    uint64 wvi_initial_value = 0;
code
    wvi_initial_value = variables[variable_index].initial_value;
    if wvi_initial_value > 0x7FFFFFFF then
        emit_string(file_handle, "\tmov r15, ");
        str_number = to_string(wvi_initial_value);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");

        // Check if variable is a parameter or local
        if variables[variable_index].kind == VARIABLE_KIND_LOCAL then
            emit_string(file_handle, "\tmov qword [rbp - ");
        else if variables[variable_index].kind == VARIABLE_KIND_PARAMETER then
            emit_string(file_handle, "\tmov qword [rbp + ");
        else 
            print_string("Unknown variable kind\n");
            exit(1);
        end end

        str_number = to_string(variables[variable_index].rbp_offset);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "], r15\n");
    else
        // Check if variable is a parameter or local
        if variables[variable_index].kind == VARIABLE_KIND_LOCAL then
            emit_string(file_handle, "\tmov qword [rbp - ");
        else if variables[variable_index].kind == VARIABLE_KIND_PARAMETER then
            emit_string(file_handle, "\tmov qword [rbp + ");
        else 
            print_string("Unknown variable kind\n");
            exit(1);
        end end

        str_number = to_string(variables[variable_index].rbp_offset);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "], ");
        str_number = to_string(wvi_initial_value);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, " ; local var ");
        emit_nstring(file_handle, variables[variable_index].name, variables[variable_index].name_length);
        emit_string(file_handle, "\n");
    end
end

enum Registers
    REG_R15 = 1,
    REG_R14,
    REG_R13,
    REG_R12,
    REG_R11,
    REG_R10,
    REG_R9,
    REG_R8,
    REG_RDI,
    REG_RSI,
    REG_RDX,
    REG_RCX,
    REG_RBX,
    REG_RAX,
end

@define REG_COUNT 15
uint64[REG_COUNT] reg_used;
uint64[REG_COUNT] reg_stack;
uint64 reg_stack_count = 0;
uint64 regs_in_use = 0;
uint64[REG_COUNT] reg_names;
uint64[REG_COUNT] reg_lb_names;

uint8[] reg_r15 = "r15"; reg_names[REG_R15] = &reg_r15;
uint8[] reg_r14 = "r14"; reg_names[REG_R14] = &reg_r14;
uint8[] reg_r13 = "r13"; reg_names[REG_R13] = &reg_r13;
uint8[] reg_r12 = "r12"; reg_names[REG_R12] = &reg_r12;
uint8[] reg_r11 = "r11"; reg_names[REG_R11] = &reg_r11;
uint8[] reg_r10 = "r10"; reg_names[REG_R10] = &reg_r10;
uint8[] reg_r9 = "r9";   reg_names[REG_R9] = &reg_r9;
uint8[] reg_r8 = "r8";   reg_names[REG_R8] = &reg_r8;
uint8[] reg_rdi = "rdi"; reg_names[REG_RDI] = &reg_rdi;
uint8[] reg_rsi = "rsi"; reg_names[REG_RSI] = &reg_rsi;
uint8[] reg_rdx = "rdx"; reg_names[REG_RDX] = &reg_rdx;
uint8[] reg_rcx = "rcx"; reg_names[REG_RCX] = &reg_rcx;
uint8[] reg_rbx = "rbx"; reg_names[REG_RBX] = &reg_rbx;
uint8[] reg_rax = "rax"; reg_names[REG_RAX] = &reg_rax;

uint8[] reg_lb_r15 = "r15b"; reg_lb_names[REG_R15] = &reg_lb_r15;
uint8[] reg_lb_r14 = "r14b"; reg_lb_names[REG_R14] = &reg_lb_r14;
uint8[] reg_lb_r13 = "r13b"; reg_lb_names[REG_R13] = &reg_lb_r13;
uint8[] reg_lb_r12 = "r12b"; reg_lb_names[REG_R12] = &reg_lb_r12;
uint8[] reg_lb_r11 = "r11b"; reg_lb_names[REG_R11] = &reg_lb_r11;
uint8[] reg_lb_r10 = "r10b"; reg_lb_names[REG_R10] = &reg_lb_r10;
uint8[] reg_lb_r9 = "r9b";   reg_lb_names[REG_R9] = &reg_lb_r9;
uint8[] reg_lb_r8 = "r8b";   reg_lb_names[REG_R8] = &reg_lb_r8;
uint8[] reg_lb_rdi = "dil"; reg_lb_names[REG_RDI] = &reg_lb_rdi;
uint8[] reg_lb_rsi = "sil"; reg_lb_names[REG_RSI] = &reg_lb_rsi;
uint8[] reg_lb_rdx = "dl"; reg_lb_names[REG_RDX] = &reg_lb_rdx;
uint8[] reg_lb_rcx = "cl"; reg_lb_names[REG_RCX] = &reg_lb_rcx;
uint8[] reg_lb_rbx = "bl"; reg_lb_names[REG_RBX] = &reg_lb_rbx;
uint8[] reg_lb_rax = "al"; reg_lb_names[REG_RAX] = &reg_lb_rax;

proc get_register(uint64 op_type) -> uint64
vars
    uint64 gr_i = 0;
code
    if regs_in_use >= REG_COUNT then
        print_string("Out of registers\n");
        exit(1);
    end

    if 
        op_type == OPERATION_MULTIPLY or 
        op_type == OPERATION_DIVIDE or 
        op_type == OPERATION_MODULO or 
        op_type == OPERATION_RETURN
    then
        if reg_used[REG_RAX] == 0 then
            reg_used[REG_RAX] = 1;
            regs_in_use++;
            reg_stack[reg_stack_count] = REG_RAX;
            reg_stack_count++;
            return REG_RAX;
        else
            //TEMP: This is a hack to get multiplication working
            emit_string(output_file_handle, "\tpush rax\n");
            reg_used[REG_RAX] = reg_used[REG_RAX] + 1;
            // regs_in_use++;
            reg_stack[reg_stack_count] = REG_RAX;
            reg_stack_count++;
            return REG_RAX;
            // print_string("Out of registers\n");
            // exit(1);
        end 
    end

    if op_type == OPERATION_LEFT_SHIFT or op_type == OPERATION_RIGHT_SHIFT then
        if reg_used[REG_RCX] == 0 then
            reg_used[REG_RCX] = 1;
            regs_in_use++;
            reg_stack[reg_stack_count] = REG_RCX;
            reg_stack_count++;
            return REG_RCX;
        else
            //TEMP: This is a hack to get shift working
            emit_string(output_file_handle, "\tpush rcx\n");
            reg_used[REG_RCX] = reg_used[REG_RCX] + 1;
            // regs_in_use++;
            reg_stack[reg_stack_count] = REG_RCX;
            reg_stack_count++;
            return REG_RCX;
            // print_string("Out of registers\n");
            // exit(1);
        end 
    end

    gr_i = 1;
    while gr_i < REG_COUNT do
        if reg_used[gr_i] == 0 then
            reg_used[gr_i] = 1;
            regs_in_use++;
            reg_stack[reg_stack_count] = gr_i;
            reg_stack_count++;
            return gr_i;
        end
        gr_i = gr_i + 1;
    end

    print_string("Out of registers\n");
    exit(1);
end

proc free_register(uint64 reg)
code
    if reg == REG_RAX and reg_used[REG_RAX] > 1 then
        emit_string(output_file_handle, "\tpop rax\n");
        reg_used[REG_RAX] = reg_used[REG_RAX] - 1;
        reg_stack_count = reg_stack_count - 1;
        return;
    end

    if reg == REG_RCX and reg_used[REG_RCX] > 1 then
        emit_string(output_file_handle, "\tpop rcx\n");
        reg_used[REG_RCX] = reg_used[REG_RCX] - 1;
        reg_stack_count = reg_stack_count - 1;
        return;
    end

    reg_used[reg] = 0;
    regs_in_use = regs_in_use - 1;
    return;
end

proc push_register(uint64 reg)
code
    if reg_stack_count >= REG_COUNT then
        print_string("Register stack overflow\n");
        exit(1);
    end

    if reg_used[reg] >= 1 then
        print_string("Register already in use\n");
        exit(1);
    end

    reg_stack[reg_stack_count] = reg;
    reg_stack_count++;
end

proc peek_register() -> uint64
vars
    uint64 pr_reg = 0;
code
    if reg_stack_count == 0 then
        print_string("Peek: Register stack underflow\n");
        exit(1);
    end

    return reg_stack[reg_stack_count - 1];
end

proc pop_register() -> uint64
vars
    uint64 pr_reg = 0;
code
    if reg_stack_count == 0 then
        print_string("Pop: Register stack underflow\n");
        exit(1);
    end
    pr_reg = reg_stack[reg_stack_count - 1];
    free_register(pr_reg);
    reg_stack_count = reg_stack_count - 1;
    return pr_reg;
end

proc get_register_name(uint64 reg) -> pointer
code
    return reg_names[reg];
end

proc print_reg_stack()
vars
    uint64 prs_i = 0;
    uint64 prs_reg = 0;
code
    prs_i = 0;
    while prs_i < reg_stack_count do
        print_string(" ");
        print_string(reg_names[prs_reg]);
        prs_i = prs_i + 1;
    end
    print_string("\n");
end

@define DEBUG_CODEGEN 0

proc log_codegen(pointer text)
code
    if DEBUG_CODEGEN then
        print_string(text);
    end
end

proc write_op_value(uint64 file_handle, uint64 op_index, uint64 parent_op_type)
vars
    uint64 guov_left_index = 0;
    uint64 guov_free_reg = 0;
code
    guov_free_reg = get_register(parent_op_type);
    if operations[op_index].value_type == TERM_TYPE_LITERAL_INT then
        log_codegen("write_op_value: Unary op value is int literal\n");
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[guov_free_reg]);
        emit_string(file_handle, ", ");
        str_number = to_string(operations[op_index].left_index);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
    else if operations[op_index].value_type == TERM_TYPE_LITERAL_BOOL then
        log_codegen("write_op_value: Unary op value is int literal\n");
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[guov_free_reg]);
        emit_string(file_handle, ", ");
        str_number = to_string(operations[op_index].left_index);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
    else if operations[op_index].value_type == TERM_TYPE_VARIABLE then
        log_codegen("write_op_value: Unary op value is variable\n");
        guov_left_index = operations[op_index].left_index;
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[guov_free_reg]);
        
        // Check if variable is a parameter or local
        if variables[guov_left_index].kind == VARIABLE_KIND_LOCAL then
            emit_string(file_handle, "\tmov qword [rbp - ");
        else if variables[guov_left_index].kind == VARIABLE_KIND_PARAMETER then
            emit_string(file_handle, "\tmov qword [rbp + ");
        else 
            print_string("Unknown variable kind\n");
            exit(1);
        end end

        str_number = to_string(variables[guov_left_index].rbp_offset);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "]\n");
    else
        print_string("write_op_value: Unsupported unary type: ");
        print_number(operations[op_index].value_type);
        print_string("\n");
        exit(1);
    end end end
end

proc write_op_addition(uint64 file_handle, uint64 op_index);

proc write_op_multiplication(uint64 file_handle, uint64 op_index)
vars
    uint64 wom_left_index = 0;
    uint64 wom_right_index = 0;
    uint64 wom_left_reg = 0;
    uint64 wom_right_reg = 0;
code
    wom_left_index = operations[op_index].left_index;
    wom_right_index = operations[op_index].right_index;

    // Check for constant folding
    if operations[wom_left_index].value_type == TERM_TYPE_LITERAL_INT and operations[wom_right_index].value_type == TERM_TYPE_LITERAL_INT then
        log_codegen("write_op_multiplication: Constant folding\n");
        wom_left_reg = get_register(OPERATION_VALUE);
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[wom_left_reg]);
        emit_string(file_handle, ", ");
        if operations[op_index].type == OPERATION_MULTIPLY then
            str_number = to_string(operations[wom_left_index].left_index * operations[wom_right_index].left_index);
        else if operations[op_index].type == OPERATION_DIVIDE then
            str_number = to_string(operations[wom_left_index].left_index / operations[wom_right_index].left_index);
        else
            str_number = to_string(operations[wom_left_index].left_index % operations[wom_right_index].left_index);
        end end
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
        return;
    end

    if operations[wom_left_index].type == OPERATION_VALUE then
        log_codegen("write_op_multiplication: left - Unary\n");
        write_op_value(file_handle, wom_left_index, operations[op_index].type);
    else if operations[wom_left_index].type == OPERATION_ADD or operations[wom_left_index].type == OPERATION_SUBTRACT then
        // Handle addition and subtraction 
        log_codegen("write_op_multiplication: left - Addition or subtraction\n");
        write_op_addition(file_handle, wom_left_index);
    else if 
        operations[wom_left_index].type == OPERATION_MULTIPLY or 
        operations[wom_left_index].type == OPERATION_DIVIDE or 
        operations[wom_left_index].type == OPERATION_MODULO
    then
        // Handle multiplication, division and modulo
        log_codegen("write_op_multiplication: left - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wom_left_index);
    else
        print_string("write_op_multiplication: Unsupported left type\n");
        exit(1);
    end end end

    if operations[wom_right_index].type == OPERATION_VALUE then
        // Check for division by zero
        if operations[wom_right_index].value_type == TERM_TYPE_LITERAL_INT and operations[wom_right_index].left_index == 0 then
            print_string("Division by zero\n");
            exit(1);
        end
        log_codegen("write_op_multiplication: right - Unary\n");
        write_op_value(file_handle, wom_right_index, OPERATION_VALUE);
    else if operations[wom_right_index].type == OPERATION_ADD or operations[wom_right_index].type == OPERATION_SUBTRACT then
        // Handle addition and subtraction 
        log_codegen("write_op_multiplication: right - Addition or subtraction\n");
        write_op_addition(file_handle, wom_right_index);
    else if 
        operations[wom_right_index].type == OPERATION_MULTIPLY or 
        operations[wom_right_index].type == OPERATION_DIVIDE or 
        operations[wom_right_index].type == OPERATION_MODULO
    then
        // Handle multiplication, division and modulo
        log_codegen("write_op_multiplication: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wom_right_index);
    else 
        print_string("write_op_multiplication: Unsupported right type ");
        str_number = to_string(operations[wom_right_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end

    wom_right_reg = pop_register();
    wom_left_reg = pop_register();
    if wom_left_reg != REG_RAX then
        emit_string(file_handle, "\tmov rax, ");
        emit_string(file_handle, reg_names[wom_left_reg]);
        emit_string(file_handle, "\n");
        free_register(wom_left_reg);
    end

    if operations[op_index].type == OPERATION_MULTIPLY then
        emit_string(file_handle, "\tmul ");
    else if operations[op_index].type == OPERATION_DIVIDE or operations[op_index].type == OPERATION_MODULO then
        emit_string(file_handle, "\tcqo\n\tdiv ");
    else
        print_string("write_op_multiplication: Unsupported operation type\n");
        exit(1);
    end end

    emit_string(file_handle, reg_names[wom_right_reg]);
    emit_string(file_handle, "\n");

     wom_right_reg = get_register(OPERATION_VALUE);

    emit_string(file_handle, "\tmov ");
    emit_string(file_handle, reg_names[wom_right_reg]);
    if operations[op_index].type == OPERATION_MULTIPLY or operations[op_index].type == OPERATION_DIVIDE then
        // Multiplication and division stores result in rax
        emit_string(file_handle, ", rax\n");
    else
        // Modulo stores remainder in rdx
        emit_string(file_handle, ", rdx\n");
    end
    emit_string(file_handle, "\t; -- end mul or div --\n");
    return;
end

proc write_op_addition(uint64 file_handle, uint64 op_index)
vars
    uint64 woa_left_index = 0;
    uint64 woa_right_index = 0;
    uint64 woa_left_reg = 0;
    uint64 woa_right_reg = 0;
code
    woa_left_index = operations[op_index].left_index;
    woa_right_index = operations[op_index].right_index;

    // Constant folding for addition
    if operations[woa_left_index].value_type == TERM_TYPE_LITERAL_INT and operations[woa_right_index].value_type == TERM_TYPE_LITERAL_INT then
        log_codegen("write_op_addition: Constant folding\n");
        woa_left_reg = get_register(OPERATION_ADD);
        emit_string(file_handle, "\tmov ");
        emit_string(file_handle, reg_names[woa_left_reg]);
        emit_string(file_handle, ", ");
        if operations[op_index].type == OPERATION_ADD then
            str_number = to_string(operations[woa_left_index].left_index + operations[woa_right_index].left_index);
        else
            str_number = to_string(operations[woa_left_index].left_index - operations[woa_right_index].left_index);
        end
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, "\n");
        return;
    end

    if operations[woa_left_index].type == OPERATION_VALUE then
        log_codegen("write_op_addition: left - Unary\n");
        write_op_value(file_handle, woa_left_index, operations[op_index].type);
    else if operations[woa_left_index].type == OPERATION_ADD or operations[woa_left_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_addition: left - Addition or subtraction\n");
        write_op_addition(file_handle, woa_left_index);
    else if operations[woa_left_index].type == OPERATION_MULTIPLY or operations[woa_left_index].type == OPERATION_DIVIDE then
        log_codegen("write_op_addition: left - Multiplication or division\n");
        write_op_multiplication(file_handle, woa_left_index);
    else
        print_string("write_op_addition: left - Unsupported left type: ");
        str_number = to_string(operations[woa_left_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end

    if operations[woa_right_index].type == OPERATION_VALUE then
        log_codegen("write_op_addition: right - Unary\n");
        write_op_value(file_handle, woa_right_index, operations[op_index].type);
    else if operations[woa_right_index].type == OPERATION_ADD or operations[woa_right_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_addition: right - Addition or subtraction\n");
        write_op_addition(file_handle, woa_right_index);
    else if 
        operations[woa_right_index].type == OPERATION_MULTIPLY or 
        operations[woa_right_index].type == OPERATION_DIVIDE or
        operations[woa_right_index].type == OPERATION_MODULO
    then
        log_codegen("write_op_addition: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woa_right_index);
    else 
        print_string("write_op_addition: Unsupported right type: ");
        str_number = to_string(operations[woa_right_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end

    woa_right_reg = pop_register();
    woa_left_reg = pop_register();
    
    if operations[op_index].type == OPERATION_ADD then
        emit_string(file_handle, "\tadd ");
    else if operations[op_index].type == OPERATION_SUBTRACT then
        emit_string(file_handle, "\tsub ");
    else
        print_string("write_op_addition: Unsupported operation type: ");
        print_number(operations[op_index].type);
        print_string("\n");
        exit(1);
    end end
    emit_string(file_handle, reg_names[woa_left_reg]);
    emit_string(file_handle, ", ");
    emit_string(file_handle, reg_names[woa_right_reg]);
    emit_string(file_handle, "\n");

    woa_right_reg = get_register(operations[op_index].type);
    emit_string(file_handle, "\t; -- end add or sub --\n");
    return;
end

proc write_op_shift(uint64 file_handle, uint64 op_index)
vars
    uint64 wos_left_index = 0;
    uint64 wos_right_index = 0;
    uint64 wos_left_reg = 0;
    uint64 wos_right_reg = 0;
code
    wos_left_index = operations[op_index].left_index;
    wos_right_index = operations[op_index].right_index;

    if operations[wos_left_index].type == OPERATION_VALUE then
        log_codegen("write_op_shift: left - Unary\n");
        write_op_value(file_handle, wos_left_index, OPERATION_VALUE);
    else if operations[wos_left_index].type == OPERATION_ADD or operations[wos_left_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_shift: left - Addition or subtraction\n");
        write_op_addition(file_handle, wos_left_index);
    else if 
        operations[wos_left_index].type == OPERATION_MULTIPLY or 
        operations[wos_left_index].type == OPERATION_DIVIDE or
        operations[wos_left_index].type == OPERATION_MODULO
    then
        log_codegen("write_op_shift: left - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wos_left_index);
    else 
        print_string("write_op_shift: Unsupported left type\n");
        exit(1);
    end end end

    if operations[wos_right_index].type == OPERATION_VALUE then
        log_codegen("write_op_shift: right - Unary\n");
        write_op_value(file_handle, wos_right_index, operations[op_index].type);
    else if operations[wos_right_index].type == OPERATION_ADD or operations[wos_right_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_shift: right - Addition or subtraction\n");
        write_op_addition(file_handle, wos_right_index);
    else if 
        operations[wos_right_index].type == OPERATION_MULTIPLY or 
        operations[wos_right_index].type == OPERATION_DIVIDE or
        operations[wos_right_index].type == OPERATION_MODULO
    then
        log_codegen("write_op_shift: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wos_right_index);
    else 
        print_string("write_op_shift: Unsupported right type\n");
        exit(1);
    end end end

    wos_right_reg = pop_register();
    wos_left_reg = pop_register();

    if wos_right_reg != REG_RCX then
        emit_string(file_handle, "\tmov rcx, ");
        emit_string(file_handle, reg_names[wos_right_reg]);
        emit_string(file_handle, "\n");
        free_register(wos_right_reg);
    end

    if operations[op_index].type == OPERATION_LEFT_SHIFT then
        emit_string(file_handle, "\tshl ");
    else if operations[op_index].type == OPERATION_RIGHT_SHIFT then
        emit_string(file_handle, "\tshr ");
    else
        print_string("write_op_shift: Unsupported operation type\n");
        exit(1);
    end end
    emit_string(file_handle, reg_names[wos_left_reg]);
    emit_string(file_handle, ", cl\n");

    wos_right_reg = get_register(OPERATION_VALUE);
    emit_string(file_handle, "\t; -- end shift --\n");
    return;
end

proc write_unary_logical_not(uint64 file_handle, uint64 op_index);

proc write_op_comparison(uint64 file_handle, uint64 op_index)
vars
    uint64 woc_left_index = 0;
    uint64 woc_right_index = 0;
    uint64 woc_left_reg = 0;
    uint64 woc_right_reg = 0;
code
    woc_left_index = operations[op_index].left_index;
    woc_right_index = operations[op_index].right_index;

    if operations[woc_left_index].type == OPERATION_VALUE then
        log_codegen("write_op_comparison: left - Unary\n");
        write_op_value(file_handle, woc_left_index, operations[op_index].type);
    else if operations[woc_left_index].type == OPERATION_ADD or operations[woc_left_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_comparison: left - Addition or subtraction\n");
        write_op_addition(file_handle, woc_left_index);
    else if 
        operations[woc_left_index].type == OPERATION_MULTIPLY or 
        operations[woc_left_index].type == OPERATION_DIVIDE or
        operations[woc_left_index].type == OPERATION_MODULO
    then
        log_codegen("write_op_comparison: left - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woc_left_index);
    else if operations[woc_left_index].type == OPERATION_UNARY_LOGICAL_NOT then
        log_codegen("write_op_comparison: left - Unary logical not\n");
        write_unary_logical_not(file_handle, woc_left_index);
    else if operations[woc_left_index].type == OPERATION_LEFT_SHIFT or operations[woc_left_index].type == OPERATION_RIGHT_SHIFT then
        log_codegen("write_op_comparison: left - Shift\n");
        write_op_shift(file_handle, woc_left_index);
    else 
        print_string("write_op_comparison: Unsupported left type\n");
        exit(1);
    end end end end end

    if operations[woc_right_index].type == OPERATION_VALUE then
        log_codegen("write_op_comparison: right - Unary\n");
        write_op_value(file_handle, woc_right_index, operations[op_index].type);
    else if operations[woc_right_index].type == OPERATION_ADD or operations[woc_right_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_comparison: right - Addition or subtraction\n");
        write_op_addition(file_handle, woc_right_index);
    else if 
        operations[woc_right_index].type == OPERATION_MULTIPLY or 
        operations[woc_right_index].type == OPERATION_DIVIDE or
        operations[woc_right_index].type == OPERATION_MODULO
    then
        log_codegen("write_op_comparison: right - Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woc_right_index);
    else if  operations[woc_right_index].type == OPERATION_UNARY_LOGICAL_NOT then
        log_codegen("write_op_comparison: right - Unary logical not\n");
        write_unary_logical_not(file_handle, woc_right_index);
    else if operations[woc_right_index].type == OPERATION_LEFT_SHIFT or operations[woc_right_index].type == OPERATION_RIGHT_SHIFT then
        log_codegen("write_op_comparison: right - Shift\n");
        write_op_shift(file_handle, woc_right_index);
    else 
        print_string("write_op_comparison: Unsupported right type\n");
        exit(1);
    end end end end end

    woc_right_reg = pop_register();
    woc_left_reg = pop_register();

    emit_string(file_handle, "\tcmp ");
    emit_string(file_handle, reg_names[woc_left_reg]);
    emit_string(file_handle, ", ");
    emit_string(file_handle, reg_names[woc_right_reg]);
    emit_string(file_handle, "\n");

    woc_right_reg = get_register(OPERATION_VALUE);

    if operations[op_index].type == OPERATION_EQUALS then
        emit_string(file_handle, "\tsete ");
    else if operations[op_index].type == OPERATION_NOT_EQUALS then
        emit_string(file_handle, "\tsetne ");
    else if operations[op_index].type == OPERATION_LESS_THAN then
        emit_string(file_handle, "\tsetl ");
    else if operations[op_index].type == OPERATION_LESS_THAN_EQUALS then
        emit_string(file_handle, "\tsetle ");
    else if operations[op_index].type == OPERATION_GREATER_THAN then
        emit_string(file_handle, "\tsetg ");
    else if operations[op_index].type == OPERATION_GREATER_THAN_EQUALS then
        emit_string(file_handle, "\tsetge ");
    else
        print_string("write_op_comparison: Unsupported operation type\n");
        exit(1);
    end end end end end end

    emit_string(file_handle, reg_lb_names[woc_right_reg]);
    emit_string(file_handle, "\n");

    emit_string(file_handle, "\t; -- end cmp --\n");
    return;
end

proc write_unary_logical_not(uint64 file_handle, uint64 op_index)
vars
    uint64 wun_op_index = 0;
    uint64 wun_reg = 0;
code
    wun_op_index = operations[op_index].left_index;

    if operations[wun_op_index].type == OPERATION_VALUE then
        log_codegen("write_unary_logical_not: Unary\n");
        write_op_value(file_handle, wun_op_index, operations[op_index].type);
    else if is_comparison_operation(operations[wun_op_index].type) then
        log_codegen("write_unary_logical_not: Comparison\n");
        write_op_comparison(file_handle, wun_op_index);
    else 
        print_string("write_unary_logical_not: Unsupported left type\n");
        exit(1);
    end end 

    wun_reg = pop_register();

    emit_string(file_handle, "\tcmp ");
    emit_string(file_handle, reg_lb_names[wun_reg]);
    emit_string(file_handle, ", 0\n");

    wun_reg = get_register(OPERATION_VALUE);

    emit_string(file_handle, "\tsete ");
    emit_string(file_handle, reg_lb_names[wun_reg]);
    emit_string(file_handle, "\n");

    emit_string(file_handle, "\t; -- end not --\n");
    return;
end

proc write_op_unary_minus(uint64 file_handle, uint64 op_index)
vars
    uint64 woum_op_index = 0;
    uint64 woum_reg = 0;
code
    woum_op_index = operations[op_index].left_index;

    if operations[woum_op_index].type == OPERATION_VALUE or operations[woum_op_index].type == OPERATION_UNARY_MINUS then
        log_codegen("write_op_unary_minus: Unary\n");
        write_op_value(file_handle, woum_op_index, operations[op_index].type);
    else if operations[woum_op_index].type == OPERATION_ADD or operations[woum_op_index].type == OPERATION_SUBTRACT then
        log_codegen("write_op_unary_minus: Addition or subtraction\n");
        write_op_addition(file_handle, woum_op_index);
    else if 
        operations[woum_op_index].type == OPERATION_MULTIPLY or 
        operations[woum_op_index].type == OPERATION_DIVIDE or
        operations[woum_op_index].type == OPERATION_MODULO
    then
        log_codegen("write_op_unary_minus: Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, woum_op_index);
    else if operations[woum_op_index].type == OPERATION_LEFT_SHIFT or operations[woum_op_index].type == OPERATION_RIGHT_SHIFT then
        log_codegen("write_op_unary_minus: Shift\n");
        write_op_shift(file_handle, woum_op_index);
    else 
        print_string("write_op_unary_minus: Unsupported left type ");
        str_number = to_string(operations[woum_op_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end

    woum_reg = pop_register();

    emit_string(file_handle, "\tneg ");
    emit_string(file_handle, reg_names[woum_reg]);
    emit_string(file_handle, "\n");

    woum_reg = get_register(OPERATION_VALUE);

    emit_string(file_handle, "\t; -- end unary minus --\n");
    return;
end

proc write_procedure_call(uint64 file_handle, uint64 op_index); // Forward declaration

proc write_assignment(uint64 file_handle, uint64 op_index)
vars
    uint64 wa_left_index = 0;
    uint64 wa_right_index = 0;
    uint64 wa_right_reg = 0;
    uint64 wa_is_comparison = 0;
code
    wa_is_comparison = 0;
    wa_left_index = operations[op_index].left_index;
    wa_right_index = operations[op_index].right_index;

    if operations[wa_right_index].type == OPERATION_VALUE then
        log_codegen("write_assignment: Unary\n");
        write_op_value(file_handle, wa_right_index, operations[op_index].type);
    else if operations[wa_right_index].type == OPERATION_ADD or operations[wa_right_index].type == OPERATION_SUBTRACT then
        log_codegen("write_assignment: Addition or subtraction\n");
        write_op_addition(file_handle, wa_right_index);
    else if 
        operations[wa_right_index].type == OPERATION_MULTIPLY or 
        operations[wa_right_index].type == OPERATION_DIVIDE or
        operations[wa_right_index].type == OPERATION_MODULO 
    then
        log_codegen("write_assignment: Multiplication, division or modulo\n");
        write_op_multiplication(file_handle, wa_right_index);
    else if is_comparison_operation(operations[wa_right_index].type) then
        wa_is_comparison = 1;
        log_codegen("write_assignment: Comparison\n");
        write_op_comparison(file_handle, wa_right_index);
    else if operations[wa_right_index].type == OPERATION_UNARY_LOGICAL_NOT then
        log_codegen("write_assignment: Unary not\n");
        write_unary_logical_not(file_handle, wa_right_index);
    else if operations[wa_right_index].type == OPERATION_UNARY_MINUS then
        log_codegen("write_assignment: Unary minus\n");
        write_op_unary_minus(file_handle, wa_right_index);
    else if operations[wa_right_index].type == OPERATION_LEFT_SHIFT or operations[wa_right_index].type == OPERATION_RIGHT_SHIFT then
        log_codegen("write_assignment: Shift\n");
        write_op_shift(file_handle, wa_right_index);
    else if operations[wa_right_index].type == OPERATION_PROCEDURE_CALL then
        print_string("write_assignment: Procedure call\n");
        write_procedure_call(file_handle, wa_right_index);
    else 
        print_string("write_assignment: Unsupported right type: ");
        str_number = to_string(operations[wa_right_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end end end end end

    if operations[op_index].value_type == TERM_TYPE_VARIABLE then
        wa_right_reg = pop_register();
        
        if wa_is_comparison then
            // Check if variable is a parameter or local
            if variables[wa_left_index].kind == VARIABLE_KIND_LOCAL then
                emit_string(file_handle, "\tmov qword [rbp - ");
            else if variables[wa_left_index].kind == VARIABLE_KIND_PARAMETER then
                emit_string(file_handle, "\tmov qword [rbp + ");
            else 
                print_string("Unknown variable kind\n");
                exit(1);
            end end
            
            str_number = to_string(variables[wa_left_index].rbp_offset);
            emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
            emit_string(file_handle, "], ");
            emit_string(file_handle, reg_lb_names[wa_right_reg]);
        else
            // Check if variable is a parameter or local
            if variables[wa_left_index].kind == VARIABLE_KIND_LOCAL then
                emit_string(file_handle, "\tmov qword [rbp - ");
            else if variables[wa_left_index].kind == VARIABLE_KIND_PARAMETER then
                emit_string(file_handle, "\tmov qword [rbp + ");
            else 
                print_string("Unknown variable kind\n");
                exit(1);
            end end

            str_number = to_string(variables[wa_left_index].rbp_offset);
            emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
            emit_string(file_handle, "], ");
            emit_string(file_handle, reg_names[wa_right_reg]);
        end
        // emit_string(file_handle, reg_names[wa_right_reg]);
        emit_string(file_handle, "\n");
    else
        print_string("write_assignment: Unsupported left type\n");
    end
end

proc write_assert(uint64 file_handle, uint64 op_index)
vars
    uint64 wa_reg = 0;
    uint64 wa_left_index = 0;
    uint64 wa_right_reg = 0;
    uint64 wa_is_comparison = 0;
code
    wa_left_index = operations[op_index].left_index;
    if is_comparison_operation(operations[wa_left_index].type) then
        write_op_comparison(file_handle, wa_left_index);
    else if operations[wa_left_index].type == OPERATION_UNARY_LOGICAL_NOT then
        write_unary_logical_not(file_handle, wa_left_index);
    else if operations[wa_left_index].type == OPERATION_VALUE then
        write_op_value(file_handle, wa_left_index, operations[op_index].type);
    else 
        print_string("write_assert: Unsupported type ");
        str_number = to_string(operations[op_index].left_index);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");

        exit(1);
    end end end

    wa_reg = pop_register();

    emit_string(file_handle, "\tcmp ");
    emit_string(file_handle, reg_lb_names[wa_reg]);
    emit_string(file_handle, ", 1\n");
    emit_string(file_handle, "\tjne assert_failed\n");
    emit_string(file_handle, "\t; -- end assert --\n");
end

proc write_statement(uint64 file_handle, uint64 statement_index); // Forward declaration

proc write_conditional_code(uint64 file_handle, uint64 op_index, uint64 parent_block_index, uint64 next_block_index)
vars 
    uint64 wcc_block_index = 0;
    uint64 wcc_cond_index = 0;
    uint64 wcc_reg = 0;
    uint64 wcc_statement_count = 0;
    uint64 wcc_current_statement_index = 0;
code
    wcc_block_index = conditionals[op_index].block_index;
    wcc_cond_index = conditionals[op_index].op_condition_index;

    log_codegen("write_conditional_code: start\n");
    emit_string(file_handle, "\t; conditional block ");
    emit_num_string(file_handle, wcc_block_index);
    emit_string(file_handle, "\n");
    emit_string(file_handle, "block_");
    emit_num_string(file_handle, wcc_block_index);
    emit_string(file_handle, ":\n");

    if wcc_cond_index != NONE then
        if operations[wcc_cond_index].type == OPERATION_VALUE then
            write_op_value(file_handle, wcc_cond_index, OPERATION_VALUE);
        else
            write_op_comparison(file_handle, wcc_cond_index);
        end

        // The comparision must only happen if condition operation is set.
        // Otherwise, the condition is always true. (eg: else block)
        wcc_reg = pop_register();

        emit_string(file_handle, "\tcmp ");
        emit_string(file_handle, reg_lb_names[wcc_reg]);
        emit_string(file_handle, ", 1\n");
        emit_string(file_handle, "\tjne block_");
        emit_num_string(file_handle, next_block_index);
        emit_string(file_handle, "\n");
    end

    wcc_statement_count = 0;
    wcc_current_statement_index = conditionals[op_index].first_statement_index;
    while wcc_statement_count < conditionals[op_index].statements_count do
        write_statement(file_handle, wcc_current_statement_index);
        wcc_current_statement_index = statements[wcc_current_statement_index].next_index;
        wcc_statement_count++;
    end

    emit_string(file_handle, "\tjmp block_");
    emit_num_string(file_handle, parent_block_index);
    emit_string(file_handle, "\n");
end

proc write_if_statement(uint64 file_handle, uint64 op_index)
vars
    uint64 wis_if_struct_index = 0;
    uint64 wis_cond_index = 0;
    uint64 wis_cond_count = 0;
    uint64 wis_block_index = 0;
    uint64 wis_next_index = 0;
    uint64 wis_next_block_index = 0;
    uint64 wis_else_index = 0;
code
    log_codegen("write_if_statement: start\n");

    if operations[op_index].type != OPERATION_IF then
        print_string("write_if_statement: Expected if operation\n");
        exit(1);
    end

    // if_struct index is stored in left_index
    wis_if_struct_index = operations[op_index].left_index;

    wis_block_index = if_structs[wis_if_struct_index].block_index;

    emit_string(file_handle, "\t; if statement ");
    emit_num_string(file_handle, wis_block_index);
    emit_string(file_handle, "\n");

    // Write conditional code
    wis_cond_index = if_structs[wis_if_struct_index].first_conditional_index;

    wis_cond_count = 0;
    while wis_cond_count < if_structs[wis_if_struct_index].conditionals_count do
        wis_next_index = conditionals[wis_cond_index].next_index;

        // If this is not the last conditional, pass the block index of the next conditional
        if wis_next_index != NOT_FOUND then
            wis_next_block_index = conditionals[wis_next_index].block_index;
        else
            // else pass the block index of the else block, if it exists
            wis_else_index = if_structs[wis_if_struct_index].else_index;
            if wis_else_index != NOT_FOUND then
                wis_next_block_index = conditionals[wis_else_index].block_index;
            else
                // else pass the block index of the parent
                wis_next_block_index = wis_block_index;
            end
        end
        write_conditional_code(file_handle, wis_cond_index, wis_block_index, wis_next_block_index);
        wis_cond_index = wis_next_index;
        wis_cond_count++;
    end

    // Write else block
    if if_structs[wis_if_struct_index].else_index != NOT_FOUND then
        write_conditional_code(file_handle, if_structs[wis_if_struct_index].else_index, wis_block_index, wis_block_index);
    end

    emit_string(file_handle, "block_");
    emit_num_string(file_handle, wis_block_index);
    emit_string(file_handle, ": ; end-if statement\n\n");
end

// list of registers that were pushed prior to calling a procedure
uint64[100] regs_pushed;
uint64 regs_pushed_count = 0;

proc emit_push_occupied_registers()
vars
    uint64 por_i = 0;
    uint64 por_j = 0;
code
    por_i = 0;
    while por_i < REG_COUNT do
        if reg_used[por_i] > 1 then
            por_j = 0;
            while por_j < reg_used[por_i] - 1 do
                emit_string(output_file_handle, "\tpush ");
                emit_string(output_file_handle, reg_names[por_i]);
                emit_string(output_file_handle, "\n");

                // Add pushed register to list
                regs_pushed[regs_pushed_count] = por_i;
                regs_pushed_count++;

                por_j = por_j + 1;
            end
        else if reg_used[por_i] == 1 then
            emit_string(output_file_handle, "\tpush ");
            emit_string(output_file_handle, reg_names[por_i]);
            emit_string(output_file_handle, "\n");

            // Add pushed register to list
            regs_pushed[regs_pushed_count] = por_i;
            regs_pushed_count++;
        end end
        por_i = por_i + 1;
    end
end


proc emit_pop_occupied_registers(uint64 file_handle)
vars
    uint64 ppor_i = 0;
    uint64 ppor_reg_index = 0;
code
    ppor_i = regs_pushed_count - 1;
    while ppor_i >= 0 do
        ppor_reg_index = regs_pushed[ppor_i];
        emit_string(file_handle, "\tpop ");
        emit_string(file_handle, reg_names[ppor_reg_index]);
        emit_string(file_handle, "\n");
        ppor_i = ppor_i - 1;
    end
end

proc write_expression(uint64 file_handle, uint64 op_index)
code
    if operations[op_index] == OPERATION_VALUE then
        write_op_value(file_handle, op_index, OPERATION_VALUE);
    else if operations[op_index] == OPERATION_ADD or operations[op_index] == OPERATION_SUBTRACT then
        write_op_addition(file_handle, op_index);
    else if 
        operations[op_index] == OPERATION_MULTIPLY or 
        operations[op_index] == OPERATION_DIVIDE or
        operations[op_index] == OPERATION_MODULO
    then
        write_op_multiplication(file_handle, op_index);
    else if operations[op_index] == OPERATION_UNARY_LOGICAL_NOT then
        write_unary_logical_not(file_handle, op_index);
    else if operations[op_index] == OPERATION_UNARY_MINUS then
        write_op_unary_minus(file_handle, op_index);
    else if operations[op_index] == OPERATION_LEFT_SHIFT or operations[op_index] == OPERATION_RIGHT_SHIFT then
        write_op_shift(file_handle, op_index);
    else 
        print_string("write_expression: Unsupported type ");
        str_number = to_string(operations[op_index].type);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end end end
end

proc get_windows_argument_register(uint64 arg_index)
code
    if arg_index == 0 then
        return REG_RCX;
    else if arg_index == 1 then
        return REG_RDX;
    else if arg_index == 2 then
        return REG_R8;
    else if arg_index == 3 then
        return REG_R9;
    else
        print_string("get_windows_argument_register: Unsupported argument index ");
        str_number = to_string(arg_index);
        print_nstring(str_number, &buffer + buffer_size - str_number);
        print_string("\n");
        exit(1);
    end end end end
end

proc write_procedure_call(uint64 file_handle, uint64 op_index)
vars 
    uint64 wpc_index = 0;
    uint64 wpc_arg_stmt_index = 0;
    uint64 wpc_arg_op_index = 0;
    uint64 wpc_arg_count=0;
    uint64 wpc_arg_register = 0; // destination register for argument
    uint64 wpc_arg_reg_index = 0; // source register for argument
code
    // The operation's right index points to a statement list that contains the arguments
    emit_string(file_handle, "\t; procedure call\n");
    emit_push_occupied_registers();
    wpc_arg_stmt_index = operations[op_index].right_index;
    wpc_arg_count = 0;
    while wpc_arg_stmt_index != NONE do
        wpc_arg_op_index = statements[wpc_arg_stmt_index].op_index;
        
        // Generate ASM code
        write_expression(file_handle, wpc_arg_op_index);

        // Get register that contains the argument
        wpc_arg_reg_index = pop_register();

        // Move result to argument register or stack
        if CALLING_CONVENTION == WINDOWS then
            if wpc_arg_count < 4 then
                wpc_arg_register = get_windows_argument_register(wpc_arg_count);
                emit_string(file_handle, "\tmov ");
                emit_string(file_handle, reg_names[wpc_arg_reg_index]);
                emit_string(file_handle, ", ");
                emit_string(file_handle, reg_names[wpc_arg_register]);
                emit_string(file_handle, "\n");
            else
                emit_string(file_handle, "\tpush ");
                emit_string(file_handle, reg_names[wpc_arg_reg_index]);
                emit_string(file_handle, "\n");
            end
        else if CALLING_CONVENTION == LINUX then
            print_string("Not implemented\n");
            exit(1);
        else 
            print_string("Unknown calling convention\n");
            exit(1);
        end end

        wpc_arg_stmt_index = statements[wpc_arg_stmt_index].next_index;
        wpc_arg_count = wpc_arg_count + 1;
    end

    emit_string(file_handle, "\tcall proc_");
    wpc_index = operations[op_index].left_index;
    emit_nstring(file_handle, procedures[wpc_index].name, procedures[wpc_index].name_length);
    emit_string(file_handle, "\n");
    emit_pop_occupied_registers(file_handle);
    emit_string(file_handle, "\t; -- end procedure call --\n");

    if procedures[wpc_index].return_type != NONE then
        get_register(OPERATION_RETURN);
    end
end

proc write_return(uint64 file_handle, uint64 op_index, uint64 proc_index)
vars
    uint64 wr_reg = 0;
    uint64 wr_index = 0;
code
    if operations[op_index].left_index != NONE then
        wr_index = operations[op_index].left_index;
        print_string("write_return: left type ");
        print_number(operations[wr_index].type);
        print_string("\n");
        if operations[wr_index].type == OPERATION_VALUE then
            write_op_value(file_handle, wr_index, OPERATION_VALUE);
        else if operations[wr_index].type == OPERATION_ADD or operations[wr_index].type == OPERATION_SUBTRACT then
            write_op_addition(file_handle, wr_index);
        else if 
            operations[wr_index].type == OPERATION_MULTIPLY or 
            operations[wr_index].type == OPERATION_DIVIDE or
            operations[wr_index].type == OPERATION_MODULO
        then
            write_op_multiplication(file_handle, wr_index);
        else if operations[wr_index].type == OPERATION_UNARY_LOGICAL_NOT then
            write_unary_logical_not(file_handle, wr_index);
        else if operations[wr_index].type == OPERATION_UNARY_MINUS then
            write_op_unary_minus(file_handle, wr_index);
        else if operations[wr_index].type == OPERATION_LEFT_SHIFT or operations[wr_index].type == OPERATION_RIGHT_SHIFT then
            write_op_shift(file_handle, wr_index);
        else 
            print_string("write_return: Unsupported left type ");
            str_number = to_string(operations[wr_index].type);
            print_nstring(str_number, &buffer + buffer_size - str_number);
            print_string("\n");
            exit(1);
        end end end end end end 

        wr_reg = pop_register();
        emit_string(file_handle, "\tmov rax, ");
        emit_string(file_handle, reg_names[wr_reg]);
        emit_string(file_handle, "\n");
    end

    emit_string(file_handle, "\t; return early\n");
    emit_string(file_handle, "\tmov rsp, rbp\n");
    emit_string(file_handle, "\tpop rbp\n");
    emit_string(file_handle, "\tret\n");
end

uint64 ws_statement_index = 0;
proc write_statement(uint64 file_handle, uint64 statement_index, uint64 proc_index)
vars
    uint64 ws_op_index = 0;
    uint64 ws_left_index = 0;
    uint64 ws_right_index = 0;
code
    debug_string("; writing statement ");
    str_number = to_string(statement_index);
    debug_nstring(str_number, &buffer + buffer_size - str_number);
    debug_string("\n");
    ws_op_index = statements[statement_index].op_index;

    emit_string(file_handle, "; statement index: ");
    str_number = to_string(ws_statement_index);
    emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
    emit_string(file_handle, "\n");

    if operations[ws_op_index].type == OPERATION_ASSIGNMENT then
        write_assignment(file_handle, ws_op_index);
    else if operations[ws_op_index].type == OPERATION_ASSERT then
        write_assert(file_handle, ws_op_index);
    else if operations[ws_op_index].type == OPERATION_IF then
        write_if_statement(file_handle, ws_op_index);
    else if operations[ws_op_index].type == OPERATION_PROCEDURE_CALL then
        write_procedure_call(file_handle, ws_op_index);
    else if operations[ws_op_index].type == OPERATION_RETURN then
        write_return(file_handle, ws_op_index, proc_index);
    else
        print_string("write_statement: Unsupported operation type ");
        print_number(operations[ws_op_index].type);
        print_string("\n");
    end end end end end

    ws_statement_index++;
end

proc write_procedure_declaration(uint64 file_handle, uint64 procedure_index)
vars
    uint64 wp_i = 0;
    uint64 wp_variable_index = 0;
    uint64 wp_statement_index = 0;
code
    debug_string("; writing procedure\n");
    emit_string(file_handle, "proc_");
    emit_nstring(file_handle, procedures[procedure_index].name, procedures[procedure_index].name_length);
    emit_string(file_handle, ":\n");
    emit_string(file_handle, "\tpush rbp\n");
    emit_string(file_handle, "\tmov rbp, rsp\n");

    // Copy arguments to stack
    if CALLING_CONVENTION == WINDOWS then
        emit_string(file_handle, "; copy arguments to stack\n");
        emit_string(file_handle, "\tmov rcx, [rbp + 16]\n");
        emit_string(file_handle, "\tmov rdx, [rbp + 24]\n");
        emit_string(file_handle, "\tmov r8, [rbp + 32]\n");
        emit_string(file_handle, "\tmov r9, [rbp + 40]\n");
    else if CALLING_CONVENTION == LINUX then
        print_string("Not implemented\n");
        exit(1);
    else 
        print_string("Unknown calling convention\n");
        exit(1);
    end end

    if procedures[procedure_index].variable_count != 0 then
        emit_string(file_handle, "\tsub rsp, ");
        str_number = to_string(procedures[procedure_index].variable_count * 8);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, " ; ");
        str_number = to_string(procedures[procedure_index].variable_count);
        emit_nstring(file_handle, str_number, &buffer + buffer_size - str_number);
        emit_string(file_handle, " local vars\n");

        wp_i = 0;
        wp_variable_index = procedures[procedure_index].first_variable_index;
        while wp_i < procedures[procedure_index].variable_count do
            write_var_init(file_handle, wp_variable_index);
            wp_variable_index = variables[wp_variable_index].next_variable_index;
            wp_i++;
        end
    end

    wp_i = 0;
    wp_statement_index = procedures[procedure_index].first_statement_index;
    while wp_i < procedures[procedure_index].statement_count do
        write_statement(file_handle, wp_statement_index, procedure_index);
        wp_statement_index = statements[wp_statement_index].next_index;
        wp_i++;
    end

    emit_string(file_handle, "\tmov rsp, rbp\n");
    emit_string(file_handle, "\tpop rbp\n");
    emit_string(file_handle, "\tret\n");
    emit_string(file_handle, "; end proc_");
    emit_nstring(file_handle, procedures[procedure_index].name, procedures[procedure_index].name_length);
    emit_string(file_handle, "\n\n");
end

proc write_program(uint64 file_handle)
vars
    uint64 wp_i = 0;
code
    if find_procedure("main", 4) == NOT_FOUND then
        print_string("No main procedure found\n");
        exit(1);
    end

    write_header(file_handle);

    debug_string("Writing program\n");
    wp_i = 0;
    while wp_i < procedure_count do
        ws_statement_index = 0;
        write_procedure_declaration(file_handle, wp_i);
        wp_i++;
    end
end

output_file_handle = CreateFileA("v3.asm", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
write_program(output_file_handle);