 `
%include "inc/std.inc"
; %define DEBUG 0

%define SOURCE_CODE_SIZE 1024*1024
%define TINY_BUFFER_SIZE 32
%define SMALL_BUFFER_SIZE 64
%define MED_BUFFER_SIZE 256
%define OPERATOR_BUFFER_SIZE 16

%macro _reset_counters_ 0
    ; r8 - offset in source code, token start
    ; r9 - token length
    ; rdi - source code pointer
    add r8, r9
    inc r8
    inc rdi
    xor r9, r9

    cmp r8, [dwBytesRead]
    jge .source_code_parsed

    jmp .read_token_loop
%endmacro

%define CompareTokenWith(c) _CompareTokenWith_ c
%macro _CompareTokenWith_ 1
    multipush rdi, rsi, rcx, r10
    strcmp(r10, %1, %1.length)
    multipop rdi, rsi, rcx, r10
%endmacro

%define OperatorEquals           1
%define OperatorNotEquals        2
%define OperatorLess             3
%define OperatorLessOrEqual      4
%define OperatorGreater          5
%define OperatorGreaterOrEqual   6
%define OperatorAssignment       7
%define OperatorPlus             8
%define OperatorMinus            9
%define OperatorMultiply        10
%define OperatorDivide          11
%define OperatorModulo          12

; Reserve 4 bits for operator type
%define OperandStringLiteral     0 + (1 << 4)
%define OperandAsmLiteral        1 + (1 << 4)
%define OperandLiteral           2 + (1 << 4)
%define OperandInteger           3 + (1 << 4)

; Reserve 4 bits for operand type
%define KeywordIf                0 + (1 << (4 + 4))
%define KeywordThen              1 + (1 << (4 + 4))
%define KeywordElse              2 + (1 << (4 + 4))
%define KeywordEnd               3 + (1 << (4 + 4))
%define KeywordWhile             4 + (1 << (4 + 4))
%define KeywordDo                5 + (1 << (4 + 4))
%define KeywordContinue          6 + (1 << (4 + 4))
%define KeywordBreak             7 + (1 << (4 + 4))
%define KeywordDefineNumberVar   8 + (1 << (4 + 4))

; todo - revisit this
%define defOperatorEquals         word OperatorEquals
%define defOperatorNotEquals      word OperatorNotEquals
%define defOperatorLess           word OperatorLess
%define defOperatorLessOrEqual    word OperatorLessOrEqual
%define defOperatorGreater        word OperatorGreater
%define defOperatorGreaterOrEqual word OperatorGreaterOrEqual
%define defOperatorAssignment     word OperatorAssignment
%define defOperatorPlus           word OperatorPlus
%define defOperatorMinus          word OperatorMinus
%define defOperatorMultiply       word OperatorMultiply
%define defOperatorDivide         word OperatorDivide
%define defOperatorModulo         word OperatorModulo

%define defOperandStringLiteral   word OperandStringLiteral
%define defOperandAsmLiteral      word OperandAsmLiteral
%define defOperandLiteral         word OperandLiteral
%define defOperandInteger         word OperandInteger

%define defKeywordIf              word KeywordIf
%define defKeywordThen            word KeywordThen
%define defKeywordElse            word KeywordElse
%define defKeywordEnd             word KeywordEnd
%define defKeywordWhile           word KeywordWhile
%define defKeywordDo              word KeywordDo
%define defKeywordContinue        word KeywordContinue
%define defKeywordBreak           word KeywordBreak
%define defKeywordDefineNumberVar word KeywordDefineNumberVar

%define TOKEN_TYPE_SIZE 2

struc Token
    .TokenType:    resw 1 ; if you change this, also update TOKEN_TYPE_SIZE
    .TokenStart:   resq 1
    .TokenLength:  resq 1
    .size equ $ - .TokenType
endstruc

struc Block
    .TokenIndex   resd 1
    .BlockId   resw 1
    .TokenType resw 1
    .size equ $ - .TokenIndex
endstruc

struc IR
    .OpType:    resw 1
    .OpSubType: resw 1
    .Line:      resw 1
    .Column:    resw 1
    .Value:     resq 1
    .size equ $ - .OpType
endstruc

%define MAX_TOKEN_COUNT 1024 * 16

%define BLOCK_ITEM_SIZE 8
section .bss
    szSourceCode resb SOURCE_CODE_SIZE
    pBufferTiny resb TINY_BUFFER_SIZE
    ptrBuffer64 resb SMALL_BUFFER_SIZE
    ptr2Buffer64 resb SMALL_BUFFER_SIZE
    ptr3Buffer64 resb SMALL_BUFFER_SIZE
    ptrBuffer256 resb MED_BUFFER_SIZE
    blockStack resb 256 * Block.size ; todo - revisit this
    blockCount resq 1
    lpProcessInformation resb 24
    lpStartupInfo resb 104
    tokenList resq MAX_TOKEN_COUNT * Token.size
    dwTokenCount resd 1
    bProcessingIfCondition resq 1
    arrIR resq MAX_TOKEN_COUNT * IR.size
    arrIRCount resq 1

    hndSourceFile resq 1
    hndDestFile resq 1
    dwBytesRead resd 1
    dwBytesWritten resd 1
    szSourceFile resb 256
    szDestFile resb 256
    szFilenameWithoutExtension resb 256
    lpExitCode resq 1

%define CONST_STRING_COUNT 1024
%define CONST_STRING_CAPACITY 1024*256 

    ; constant string literals
    ; allow for 1024 constant string literal pointers
    pStringListPointers resq CONST_STRING_COUNT 
    dwStringCount resq 1
    ; pointer to a buffer that holds the string literals
    ; all strings are NULL terminated
    ; to index this, use 'pStringListPointers'
    pStringList resb CONST_STRING_CAPACITY
    ; this points to the next available byte in the string list
    pStringListEnd resq 1

section .data
    tokenIndex dq 0
    chAsmStart equ 0x60
    chDoubleQuote equ 0x22
    wScopedBlockCurrentId dw 0
    argCount dq 0

    ; asm output 
    cStrAsmHeader db "bits 64", 0xd, 0xa
                  db "default rel", 0xd, 0xa, 0xd, 0xa, 0
    cStrAsmHeader.length equ $ - cStrAsmHeader - 1
    cStrReadOnlySectionHeader db 0xd, 0xa, "section .rodata", 0xd, 0xa, 0
    cStrReadOnlySectionHeader.length equ $ - cStrReadOnlySectionHeader - 1

section .text
    global _start
    extern CreateFileA
    extern ReadFile
    extern WriteFile
    extern CloseHandle
    extern DeleteFileA
    extern GetLastError
    extern GetCommandLineA
    extern CreateProcessA
    extern WaitForSingleObject
    extern GetExitCodeProcess

_start:
    sub rsp, 32
    call GetCommandLineA
    add rsp, 32

    mov qword [argCount], 0

    ; get length of command line
    mov rdi, rax
    mov rax, ' '
    xor rcx, rcx
    xor r8, r8

.arg_loop:    
    cmp byte [rdi], 0
    je .arg_loop_end
    cmp byte [rdi], al
    je .arg_loop_found_space
    inc rdi
    inc r8
    jmp .arg_loop

.arg_loop_found_space:`
if r8 == 0 then `
    inc rdi
    jmp .arg_loop`
end `

.if_first_arg:
    cmp byte [argCount], 0
    jne .endif_first_arg
.then_first_arg:
    inc qword [argCount]
    inc rdi
    xor r8, r8
    push rdi
    jmp .arg_loop
.endif_first_arg:    

.arg_loop_end:
    pop rdi
.if_trim:
    cmp byte [rdi], ' '
    jne .endif_trim
.then_trim:
    inc rdi
.endif_trim:    

    multipush rax, rcx, rdi, rsi
    mov r14, rdi
    strlen(rdi)
    mov r13, rax

    push r14
    memcpy(szSourceFile, r14, r13)
    pop r14
    push r14
    memcpy(szDestFile, r14, r13)
    pop r14
    strcpy(szFilenameWithoutExtension, szSourceFile, r13)
    
    mov r14, szSourceFile
    add r14, r13
    memcpy(r14, szStrataFileExtension, szStrataFileExtension.length)

    mov r14, szDestFile
    add r14, r13
    memcpy(r14, szAsmFileExtension, szAsmFileExtension.length)

    multipop rax, rcx, rdi, rsi
    
    InitStandardOutput()

    ; print input and output file names
    printf(`"[\#27[92mINFO\#27[0m] Input file '%s'\r\n"`, szSourceFile)
    printf(`"[\#27[92mINFO\#27[0m] Output file '%s'\r\n"`, szDestFile)

    ; Preparing the parameters for CreateFileA to open a file for reading
    mov rcx, szSourceFile                       ; First parameter: Pointer to the filename (LPCSTR)
    mov rdx, GENERIC_READ                       ; Second parameter: Access to the file (DWORD), for reading use GENERIC_READ
    mov r8, 1                                   ; Third parameter: File sharing mode (DWORD)
    mov r9, 0                                   ; Fourth parameter: Pointer to security attributes (LPSECURITY_ATTRIBUTES)
    sub rsp, 4*8 + 3*8                          ; Shadow space for 4 register parameters + 3 additional stack parameters
    mov [rsp+4*8], dword 3                      ; Fifth parameter: Action to take on files that exist or do not exist (DWORD)
    mov [rsp+5*8], dword FILE_ATTRIBUTE_NORMAL  ; Sixth parameter: File attributes and flags (DWORD)
    mov [rsp+6*8], dword 0                      ; Seventh parameter: Handle to a template file (HANDLE)
    call CreateFileA
    add rsp, 4*8 + 3*8

    ; check if the file handle is valid`
    if rax < 0 then `
        call GetLastError
        printf(`"[\#27[91mERROR\#27[0m] Error opening file '%s'. Error code: %d\r\n"`, szSourceFile, rax)
        ExitProcess(1)`
    end `

    ; file opened
    mov [hndSourceFile], rax

    ; Preparing the parameters for ReadFile
    mov rcx, [hndSourceFile]      ; Handle to the file (HANDLE)
    mov rdx, szSourceCode        ; Pointer to the buffer that receives the data read from the file (LPVOID)
    mov r8, dword SOURCE_CODE_SIZE   ; Number of bytes to be read from the file (DWORD)
    mov r9, dwBytesRead         ; Pointer to the variable that receives the number of bytes read (LPDWORD)
    sub rsp, 32
    push 0
    call ReadFile

    ; check if the function succeeded`
    if rax == 0 then `
        call GetLastError
        printf(`"[\#27[91mERROR\#27[0m] Error reading file '%s'. Error code: %d\r\n"`, rax)
        ExitProcess(1)`
    end `

    ; Preparing the parameters for CreateFileA to open a file for writing
    mov rcx, szDestFile                         ; Pointer to the filename (LPCSTR)
    mov rdx, GENERIC_WRITE                      ; Access to the file (DWORD), for reading use GENERIC_READ
    mov r8, 2                                   ; File sharing mode (DWORD)
    mov r9, 0                                   ; Pointer to security attributes (LPSECURITY_ATTRIBUTES)
    sub rsp, 4*8 + 3*8                          ; 4 register parameters + 3 additional stack parameters
    mov [rsp+4*8], dword 2                      ; Action to take on files that exist or do not exist (DWORD)
    mov [rsp+5*8], dword FILE_ATTRIBUTE_NORMAL  ; File attributes and flags (DWORD)
    mov [rsp+6*8], dword 0                      ; Handle to a template file (HANDLE)
    call CreateFileA
    add rsp, 4*8 + 3*8

    ; check if the function succeeded`
    if rax < 0 then `
        call GetLastError
        printf(`"[\#27[91mERROR\#27[0m] Error opening file '%s'. Error code: %d\r\n"`, szDestFile, rax)
        ExitProcess(1)`
    end `

    mov [hndDestFile], rax

    printf(`"[\#27[92mINFO\#27[0m] Compiling file '%s'...\r\n"`, szSourceFile)

    ; initialize string count
    mov rax, 0
    mov [dwStringCount], rax

    ; initialize string list end pointer
    mov rax, pStringList
    mov [pStringListEnd], rax

;-----------------------------------source code parsing----------------------------------
.start_parsing_source_code:
    ; reset offset
    xor r8, r8          ; token start
    xor r9, r9          ; token length
    mov rdi, szSourceCode

.read_token_loop:
    cmp byte [rdi], 0
    je .source_code_end
    cmp byte [rdi], 0x20
    je .token_found
    cmp byte [rdi], 0xd
    je .token_found
    cmp byte [rdi], 0xa
    je .token_found
    cmp byte [rdi], 0x9
    je .token_found
    cmp byte [rdi], chAsmStart
    je .asm_literal_start
    cmp byte [rdi], chDoubleQuote
    je .string_literal_start
    inc r9
    inc rdi
    jmp .read_token_loop

.source_code_end:
    cmp r9, 0
    je .source_code_parsed

.token_found:
    ; is token length 0?`
    if r9 == 0 then `
        inc rdi
        inc r8
        jmp .read_token_loop`
    end `

.print_token:
    mov r10, szSourceCode
    add r10, r8

    push rbp
    mov rbp, rsp
    sub rsp, 8 ; reserve space on the stack for the token type
    mov [rbp], word 0 ; initialize token type to 0`

if CompareTokenWith(szKeywordIf) then `
    mov [rbp], word KeywordIf`
else if CompareTokenWith(szKeywordThen) then `
    mov [rbp], word KeywordThen`
else if CompareTokenWith(szKeywordElse) then `
    mov [rbp], word KeywordElse`
else if CompareTokenWith(szKeywordEnd) then `
    mov [rbp], word KeywordEnd`
else if CompareTokenWith(szKeywordWhile) then `
    mov [rbp], word KeywordWhile`
else if CompareTokenWith(szKeywordDo) then `
    mov [rbp], word KeywordDo`
else if CompareTokenWith(szKeywordContinue) then `
    mov [rbp], word KeywordContinue`
else if CompareTokenWith(szKeywordBreak) then `
    mov [rbp], word KeywordBreak`
else if CompareTokenWith(szKeywordNumber) then `
    mov [rbp], word KeywordDefineNumberVar`
else if CompareTokenWith(szOperatorEquals) then `
    mov [rbp], word OperatorEquals`
else if CompareTokenWith(szOperatorNotEquals) then `
    mov [rbp], word OperatorNotEquals`
else if CompareTokenWith(szOperatorLessOrEqual) then `
    mov [rbp], word OperatorLessOrEqual`
else if CompareTokenWith(szOperatorLess) then `
    mov [rbp], word OperatorLess`
else if CompareTokenWith(szOperatorGreaterOrEqual) then `
    mov [rbp], word OperatorGreaterOrEqual`
else if CompareTokenWith(szOperatorGreater) then `
    mov [rbp], word OperatorGreater`
else if CompareTokenWith(szOperatorAssignment) then `
    mov [rbp], word OperatorAssignment`
else if CompareTokenWith(szOperatorPlus) then `
    mov [rbp], word OperatorPlus`
else if CompareTokenWith(szOperatorMinus) then `
    mov [rbp], word OperatorMinus`
else if CompareTokenWith(szOperatorMultiply) then `
    mov [rbp], word OperatorMultiply`
else if CompareTokenWith(szOperatorDivide) then `
    mov [rbp], word OperatorDivide`
else if CompareTokenWith(szOperatorModulo) then `
    mov [rbp], word OperatorModulo`
else `
    ; check if token is a number
    PushCallerSavedRegs()
    strcpy(ptrBuffer64, r10, r9)
    mov rcx, ptrBuffer64
    call atoi`

    if rdx != 0 then `
        mov [rbp], word OperandInteger`
    else `
        ; otherwise, it's a literal
        mov [rbp], word OperandLiteral`
    end `
    PopCallerSavedRegs()`
end end end end end end end end end end end end end end
end end end end end end end `

    ; test if token type is 0
    push rax
    mov ax, word [rbp]
    cmp rax, 0
    pop rax
    jne .endif_token_type_is_not_zero

    ; todo - test atoi thoroughly

.endif_token_type_is_not_zero:
    ; create a token
    ; r8 - offset in source code, token start
    ; r9 - token length
    multipush rax, rbx, rcx, rdx, r15
    mov rbx, tokenList         ; load pointer to list
    mov eax, [dwTokenCount]    ; load token count
    mov rdx, Token.size        ; and size
    mul rdx                    ; calculate offset
    add rbx, rax               ; add offset to pointer
    mov rax, [rbp]    ; token type
    and rax, 0xffff
    mov [rbx + Token.TokenType], word ax ; token type
    mov [rbx + Token.TokenStart], r8 ; token start
    mov [rbx + Token.TokenLength], r9 ; token length
    inc dword [dwTokenCount]
    multipop rax, rbx, rcx, rdx, r15

    multipush rax, rdx, r15
    array_ith(IR, arrIR, [arrIRCount], r15)
    mov rax, [rbp]    ; token type
    and rax, 0xffff
    mov [r15 + IR.OpType], rax
    multipop rax, rdx, r15

    pop rbp
    add rsp, 8 ; restore stack pointer

    ; advance token start and reset token length
    _reset_counters_

.asm_literal_start:
    ; iterate until we find another '0x40'
    inc rdi
    push rdi
    xor r14, r14 ; store length of asm code

.asm_literal_loop:
    cmp byte [rdi], chAsmStart
    je .asm_literal_end
    inc r14
    inc rdi
    jmp .asm_literal_loop

.asm_literal_end:
    inc rdi ; move offset past trailing '0x40'
    pop r10 ; restore start of asm code from rdi to r10
    add r8, r14
    add r8, 2 

    multipush rax, rbx, rcx, rdx, r10, r14
    dec r10
    push r11
    mov r11, szSourceCode
    sub r10, r11
    pop r11
    add r14, 1
    mov rbx, tokenList         ; load pointer to list
    mov eax, [dwTokenCount]    ; load token count
    mov rdx, Token.size        ; and size
    mul rdx                    ; calculate offset
    add rbx, rax               ; add offset to pointer
    mov [rbx + Token.TokenType], word OperandAsmLiteral ; token type
    mov [rbx + Token.TokenStart], r10 ; token start
    mov [rbx + Token.TokenLength], r14 ; token start
    inc dword [dwTokenCount]
    multipop rax, rbx, rcx, rdx, r10, r14

    jmp .read_token_loop

.string_literal_start:
    inc rdi
    push rdi
    xor r14, r14 ; store length of string literal

.string_literal_loop:
    cmp byte [rdi], chDoubleQuote
    je .string_literal_end
    inc r14
    inc rdi
    jmp .string_literal_loop

.string_literal_end:
    inc rdi ; move offset past trailing '0x22'
    pop r10 ; restore start of string literal from rdi to r10
    add r8, r14
    add r8, 2 

    ; add token to token list
    multipush rax, rbx, rcx, rdx, r10, r14
    dec r10
    push r11
    mov r11, szSourceCode
    sub r10, r11
    pop r11
    add r14, 2
    mov rbx, tokenList         ; load pointer to list
    mov eax, [dwTokenCount]    ; load token count
    mov rdx, Token.size        ; and size
    mul rdx                    ; calculate offset
    add rbx, rax               ; add offset to pointer
    mov [rbx + Token.TokenType], word OperandStringLiteral ; token type
    mov [rbx + Token.TokenStart], r10 ; token start
    mov [rbx + Token.TokenLength], r14 ; token start
    inc dword [dwTokenCount]
    multipop rax, rbx, rcx, rdx, r10, r14

    jmp .read_token_loop
;-----------------------------------source code parsing----------------------------------

.source_code_parsed:
    mov r15d, dword [dwTokenCount]
    printf(`"[\#27[92mINFO\#27[0m] Found %d tokens.\r\n"`, r15)
    mov r14, 0
    mov r13, tokenList

%define NextToken() nextToken
%macro nextToken 0
    add rdx, Token.size ; jump to next token
    mov rbx, [tokenIndex]
    inc rbx
    mov [tokenIndex], rbx
    jmp .while_counter_less_than_token_count
%endmacro

%define SkipTokens(n) skip_tokens n
%macro skip_tokens 1
    multipush rax, rdx
    mov rax, Token.size
    mov rdx, %1
    mul rdx
    pop rdx
    add rdx, rax
    pop rax
    mov rbx, [tokenIndex]
    add rbx, %1
    mov [tokenIndex], rbx
%endmacro

%define PushBlockToken(tokenType, scopeId) pushBlockToken tokenType, scopeId
%macro pushBlockToken 2
    multipush rax, rbx, rdx
    mov rbx, blockStack
    mov rax, [blockCount]
    mov rdx, Block.size 
    mul rdx
    add rbx, rax                          ; rbx points to just after the top of the stack
    mov rax, [tokenIndex]
    mov [rbx + Block.TokenIndex], rax
    ; this is a bug, current scope needs to be passed as arg
    mov rax, %2
    mov [rbx + Block.BlockId], rax
    mov [rbx + Block.TokenType], word %1  ; push token type
    inc qword [blockCount]                ; increment block count
    multipop rax, rbx, rdx
%endmacro

%define PopBlockToken() popBlockToken
%macro popBlockToken 0
    multipush rbx, rdx
    mov rbx, blockStack
    dec qword [blockCount]   ; decrement block count
    mov rax, [blockCount]
    mov rdx, Block.size 
    mul rdx
    add rax, rbx             ; rbx points to top of the stack
    multipop rbx, rdx
%endmacro

%define PeekBlockToken() peekBlockToken
%macro peekBlockToken 0
    multipush rbx, rdx
    mov rbx, blockStack
    mov rax, [blockCount]
    mov rdx, Block.size 
    mul rdx
    add rax, rbx
    sub rax, Block.size ; rbx points to top of the stack
    multipop rbx, rdx
%endmacro

; this will only decrement the block count
%define QuickPopBlockToken() dec qword [blockCount]

%ifdef DEBUG    
    push rbx
    mov ebx, dword [dwTokenCount]
    printf(`"[DEBUG] Found %d tokens.\r\n"`, rbx)
    pop rbx
%endif

; ---------------------- START OF ASM OUTPUT ----------------------
    ; write asm header
    WriteFile([hndDestFile], cStrAsmHeader, cStrAsmHeader.length, dwBytesWritten)

    ; iterate over tokens
    push rbp
    mov rbp, rsp
    sub rsp, 0x10 ; reserve space on the stack for the token index

    xor rbx, rbx ; counter
    mov rdx, tokenList
    
    ; initialize counters
    mov r10, 0
    mov [wScopedBlockCurrentId], r10

%define currentToken.Type word [rdx + Token.TokenType]
%define currentToken.Start dword [rdx + Token.TokenStart]
%define currentToken.Length dword [rdx + Token.TokenLength]

.while_counter_less_than_token_count:
    mov rbx, [tokenIndex]
    cmp ebx, [dwTokenCount]
    jge .end_counter_less_than_token_count
    mov r14w, currentToken.Type
    ; printf(`"[DEBUG] Current token type: %x\r\n"`, r14)
%ifdef DEBUG    
    PushCallerSavedRegs()
    printf(`"[DEBUG] Current token index: %d\r\n"`, rbx)
    PopCallerSavedRegs()
%endif`
    if currentToken.Type == defKeywordThen then `   
        push r15    
        xor r15, r15
        mov [bProcessingIfCondition], r15
        pop r15`
    end
    
    if currentToken.Type == defKeywordDo then `   
        push r15    
        xor r15, r15
        mov [bProcessingIfCondition], r15
        pop r15`
    end
     `

    cmp qword [bProcessingIfCondition], 0
    je .continue_processing
    NextToken()

.continue_processing:
`
    if currentToken.Type == defOperandAsmLiteral then `
        PushCallerSavedRegs()
  
        ; write asm code
        mov r10d, currentToken.Start
        mov r11, szSourceCode
        add r10, r11
        inc r10 ; skip leading '0x40'
        mov r11d, currentToken.Length
        dec r11 ; skip trailing '0x40'

        WriteFile([hndDestFile], r10, r11, dwBytesWritten)

        PopCallerSavedRegs()
        NextToken()`
    end 

    ` ; keyword 'if'`
    if currentToken.Type == defKeywordIf then `
        PushCallerSavedRegs()
        sprintf(ptrBuffer64, `"\r\n.if_%d:\r\n"`, [wScopedBlockCurrentId])
        WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)

        PushBlockToken(defKeywordIf, [wScopedBlockCurrentId])
        
        inc word [wScopedBlockCurrentId]
        push r15
        mov r15, 1
        mov [bProcessingIfCondition], r15
        pop r15
        PopCallerSavedRegs()
        NextToken()`
    end 

    `; keyword 'then'`
    if currentToken.Type == defKeywordThen then `
        PushCallerSavedRegs()
        PeekBlockToken()
        mov rbx, [rax + Block.TokenType]

        %ifdef DEBUG
            printf(`"[DEBUG] .if_token_is_then_0 - rbx %x\r\n"`, rbx)
        %endif `

        if bx != KeywordIf then `
            printf(`"[\#27[91mERROR\#27[0m] Keyword 'then' is not after 'if'\r\n"`, szSourceFile)
            jmp .exit`
        end `
        
        push rax ; rax stores pointer to block struct

        ; get number of tokens in if condition
        mov r10d, [tokenIndex] ; current token index
        mov r11d, dword [rax + Block.TokenIndex] ; if token index
        inc r11d ; skip 'if' token
        sub r10d, r11d ; r10d stores number of tokens in if condition
        `
        if r10d != 3 then 
            if r10d != 1 then `
                printf(`"[\#27[91mERROR\#27[0m] Unsupported 'if' condition. Found %d tokens\r\n"`, r10)
                jmp .exit`
            end
        end 

        if r10d == 3 then `
            mov rcx, r11 ; rcx stores token index of first token of if condition
            mov dx, word [rax + Block.BlockId]
            and rdx, 0xffff
            PushCallerSavedRegs()
            call compile_condition_3
            PopCallerSavedRegs()`
        else if r10d == 1 then `
            mov rcx, r11 ; rcx stores token index of first token of if condition
            mov dx, word [rax + Block.BlockId]
            and rdx, 0xffff
            PushCallerSavedRegs()
            call compile_condition_1
            PopCallerSavedRegs()`
        end end `
    
        pop rax ; rax stores pointer to block struct
        
        mov bx, word [rax + Block.BlockId]
        and rbx, 0xffff
        sprintf(ptrBuffer64, `";then_%d:\r\n"`, rbx)
        WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)
        ; bx stores block id
        mov cx, bx
        PushBlockToken(KeywordThen, rcx)

        push r15    
        xor r15, r15
        mov [bProcessingIfCondition], r15
        pop r15

        PopCallerSavedRegs()
        NextToken()`
    end

    `; keyword 'else'`
    if currentToken.Type == defKeywordElse then `
        PushCallerSavedRegs()

        PeekBlockToken()
        push rax
        mov rbx, [rax + Block.TokenType]`
        if bx != KeywordThen then `
            printf(`"[\#27[91mERROR\#27[0m] Keyword 'else' is not after 'then'\r\n"`, szSourceFile)
            jmp .exit`
        end `
        
        pop rax
        mov bx, word [rax + Block.BlockId]
        and rbx, 0xffff 
        sprintf(ptrBuffer64, `"\r\n\tjmp .end_%d\r\n.else_%d:\r\n"`, rbx, rbx)
        WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)

        PopCallerSavedRegs()
        NextToken()`
    end 

    `; keyword 'end'`
    if currentToken.Type == defKeywordEnd then `
        PushCallerSavedRegs()

        PeekBlockToken()
        push rax
        mov rbx, [rax + Block.TokenType]`
        
        if bx != KeywordThen then 
            if bx != KeywordElse then 
                if bx != KeywordDo then `
                    printf(`"[\#27[91mERROR\#27[0m] Keyw ord 'end' is not after 'then', 'else' or 'do'\r\n"`, szSourceFile)
                    jmp .exit
                    `
                end
            end
        end 
        
        if bx == KeywordDo then `
            mov bx, word [rax + Block.BlockId]
            and rbx, 0xffff 
            sprintf(ptrBuffer64, `"\r\n    jmp .while_%d\r\n    ; end while_%d"`, rbx, rbx)
            WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)`
        end `
        
        pop rax
        mov bx, word [rax + Block.BlockId]
        and rbx, 0xffff 
        sprintf(ptrBuffer64, `"\r\n.end_%d:\r\n"`, rbx)
        WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)

        QuickPopBlockToken() ; pop 'then' or 'do'
        QuickPopBlockToken() ; pop 'if' or 'while'

        PopCallerSavedRegs()
        NextToken()`
    end 

    `; keyword 'while'`
    if currentToken.Type == defKeywordWhile then `
        PushCallerSavedRegs()
        sprintf(ptrBuffer64, `"\r\n.while_%d:\r\n"`, [wScopedBlockCurrentId])
        WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)

        PushBlockToken(defKeywordWhile, [wScopedBlockCurrentId])
        
        push r15    
        mov r15, 1
        mov [bProcessingIfCondition], r15
        pop r15

        inc word [wScopedBlockCurrentId]
        PopCallerSavedRegs()
        NextToken()`
    end

    `; keyword 'do'`
    if currentToken.Type == defKeywordDo then `
        PushCallerSavedRegs()
        PeekBlockToken()
        mov rbx, [rax + Block.TokenType]

        %ifdef DEBUG
            printf(`"[DEBUG] .if_token_is_then_0 - rbx %x\r\n"`, rbx)
        %endif `

        if bx != KeywordWhile then `
            printf(`"[\#27[91mERROR\#27[0m] Keyword 'do' is not after 'while'\r\n"`, szSourceFile)
            jmp .exit`
        end `
        
        push rax ; rax stores pointer to block struct

        ; get number of tokens in if condition
        mov r10d, [tokenIndex] ; current token index
        mov r11d, dword [rax + Block.TokenIndex] ; if token index
        inc r11d ; skip 'if' token
        sub r10d, r11d ; r10d stores number of tokens in if condition
        `
        if r10d != 3 then 
            if r10d != 1 then `
                printf(`"[\#27[91mERROR\#27[0m] Unsupported 'while' condition. Found %d tokens\r\n"`, r10)
                jmp .exit`
            end
        end 

        if r10d == 3 then `
            mov rcx, r11 ; rcx stores token index of first token of if condition
            mov dx, word [rax + Block.BlockId]
            and rdx, 0xffff
            PushCallerSavedRegs()
            call compile_condition_3
            PopCallerSavedRegs()`
        else if r10d == 1 then `
            mov rcx, r11 ; rcx stores token index of first token of if condition
            mov dx, word [rax + Block.BlockId]
            and rdx, 0xffff
            PushCallerSavedRegs()
            call compile_condition_1
            PopCallerSavedRegs()`
        end end `

    
        pop rax ; rax stores pointer to block struct
        
        mov bx, word [rax + Block.BlockId]
        and rbx, 0xffff
        sprintf(ptrBuffer64, `";do_%d:\r\n"`, rbx)
        WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)
        ; bx stores block id
        mov cx, bx
        PushBlockToken(KeywordDo, rcx)

        push r15    
        xor r15, r15
        mov [bProcessingIfCondition], r15
        pop r15

        PopCallerSavedRegs()
        NextToken()`
    end

    `; keyword 'continue'`
    if currentToken.Type == defKeywordContinue then `
        PushCallerSavedRegs()

        ; find the nearest 'while' block
        multipush r15, rax, rdx
        mov rbx, [blockCount]
        mov rax, rbx
        mov rdx, Block.size
        mul rdx
        mov r15, blockStack
        add r15, rax
        multipop rax, rdx`

        while rbx > 0 do `
            dec rbx
            sub r15, Block.size
            mov r10w, word [r15 + Block.TokenType]`

            if r10 == KeywordWhile then `
                mov r10w, [r15 + Block.BlockId]
                and r10, 0xffff
                sprintf(ptrBuffer64, `"\r\n    jmp .while_%d\r\n"`, r10)
                WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)`
            end 
        end `

        pop r15

        PopCallerSavedRegs()
        NextToken()`
    end 

    `; keyword 'break'`
    if currentToken.Type == defKeywordBreak then `
        PushCallerSavedRegs()

        ; find the nearest 'while' block
        multipush r15, rax, rdx
        mov rbx, [blockCount]
        mov rax, rbx
        mov rdx, Block.size
        mul rdx
        mov r15, blockStack
        add r15, rax
        multipop rax, rdx`

        while rbx > 0 do `
            dec rbx
            sub r15, Block.size
            mov r10w, word [r15 + Block.TokenType]`

            if r10 == KeywordWhile then `
                mov r10w, [r15 + Block.BlockId]
                and r10, 0xffff
                sprintf(ptrBuffer64, `"\r\n    jmp .end_%d\r\n"`, r10)
                WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)`
            end 
        end `

        pop r15

        PopCallerSavedRegs()
        NextToken()`
    end 

    ` ; keyword 'num'`
    if currentToken.Type == defKeywordDefineNumberVar then `
        PushCallerSavedRegs()

        ; look ahead for identifier
        multipush rax, rbx, r13, r14, r15
        mov rax, rbx
        inc rax
        mov rdx, Token.size
        mul rdx
        mov rbx, tokenList
        add rbx, rax
        
        ; get identifier
        mov r12w, word [rbx + Token.TokenType]
        mov r14w, word [rbx + Token.TokenStart]
        mov r15w, word [rbx + Token.TokenLength]
        mov r13, szSourceCode
        add r13, r14`

        if r12w != defOperandLiteral then `
            printf(`"[\#27[91mERROR\#27[0m] Expected identifier after 'num'\r\n"`)
            jmp .exit`
        end `

        strcpy(ptrBuffer64, r13, r15)
        
        ; check if assignment operator is next
        add rbx, Token.size
        mov r12w, word [rbx + Token.TokenType]`
        
        if r12w != defOperatorAssignment then `
            printf(`"[\#27[91mERROR\#27[0m] Expected assignment operator after 'num'\r\n"`)
            jmp .exit`
        end `

        ; get value
        add rbx, Token.size

        mov r14w, word [rbx + Token.TokenStart]
        mov r15w, word [rbx + Token.TokenLength]
        mov r13, szSourceCode
        add r13, r14
        strcpy(ptr2Buffer64, r13, r15)

        multipop rax, rbx, r13, r14, r15
        sub rbx, Token.size

        ; todo - write them at the top of asm file
        ; write variable declaration
        sprintf(ptrBuffer256, `"\r\nsection .data\r\n\t%s dq %s\r\nsection .text\r\n"`, ptrBuffer64, ptr2Buffer64)
        WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)

        PopCallerSavedRegs()
        SkipTokens(3)
        NextToken()`
    end 

      `; literal `
    if currentToken.Type == defOperandLiteral then `
        PushCallerSavedRegs()

        ; look ahead for assignment operator
        multipush rax, rbx, r13, r14, r15
        mov rax, rbx
        mov rdx, Token.size
        mul rdx
        mov rbx, tokenList
        add rbx, rax

        mov r14w, word [rbx + Token.TokenStart]
        mov r15w, word [rbx + Token.TokenLength]
        mov r13, szSourceCode
        add r13, r14
        strcpy(ptrBuffer64, r13, r15) ; literal name

        add rbx, Token.size
        mov r12w, word [rbx + Token.TokenType]`

        if r12w != defOperatorAssignment then `
            printf(`"[\#27[91mERROR\#27[0m] Expected assignment operator after literal '%s'\r\n"`, ptrBuffer64)
            jmp .exit`
        end `

        add rbx, Token.size
        mov r12w, word [rbx + Token.TokenType]`

        if r12w != defOperandLiteral then 
            if r12w != defOperandInteger then `
                printf(`"[\#27[91mERROR\#27[0m] Expected literal or integer after assignment\r\n"`)
                jmp .exit`
            end
        end `

        mov r14w, word [rbx + Token.TokenStart]
        mov r15w, word [rbx + Token.TokenLength]
        mov r13, szSourceCode
        add r13, r14
        strcpy(ptr2Buffer64, r13, r15) ; literal name`
        
        if r12w == defOperandInteger then `
            sprintf(ptr3Buffer64, `"\r\n\tmov rax, %s\r\n"`, ptr2Buffer64)
            WriteFile([hndDestFile], ptr3Buffer64, rax, dwBytesWritten)`
        else if r12w == defOperandLiteral then `
            sprintf(ptr3Buffer64, `"\r\n\tmov rax, [%s]\r\n"`, ptr2Buffer64)
            WriteFile([hndDestFile], ptr3Buffer64, rax, dwBytesWritten)`
        end end `
        

        add rbx, Token.size
        mov r12w, word [rbx + Token.TokenType]`

        if r12w == defOperatorPlus then `
            sprintf(ptr3Buffer64, `"\tadd rax, rcx\r\n\tmov [%s], rax\r\n"`, ptrBuffer64)`
        else if r12w == defOperatorMinus then `
            sprintf(ptr3Buffer64, `"\tsub rax, rcx\r\n\tmov [%s], rax\r\n"`, ptrBuffer64)`
        else if r12w == defOperatorMultiply then `
            sprintf(ptr3Buffer64, `"\tmul rcx\r\n\tmov [%s], rax\r\n"`, ptrBuffer64)`
        else if r12w == defOperatorDivide then `
            sprintf(ptr3Buffer64, `"\txor rdx, rdx\r\n\tdiv rcx\r\n\tmov [%s], rax\r\n"`, ptrBuffer64)`
        else if r12w == defOperatorModulo then `
            sprintf(ptr3Buffer64, `"\txor rdx, rdx\r\n\tdiv rcx\r\n\tmov [%s], rdx\r\n"`, ptrBuffer64)`
        else `
            printf(`"[\#27[91mERROR\#27[0m] Expected arithmetic operator\r\n"`)
            jmp .exit`
        end end end end end `

        add rbx, Token.size
        mov r12w, word [rbx + Token.TokenType]`

        if r12w != defOperandLiteral then 
            if r12w != defOperandInteger then `
                printf(`"[\#27[91mERROR\#27[0m] Expected literal or integer after operator\r\n"`)
                jmp .exit`
            end
        end `

        mov r14w, word [rbx + Token.TokenStart]
        mov r15w, word [rbx + Token.TokenLength]
        mov r13, szSourceCode
        add r13, r14
        strcpy(ptr2Buffer64, r13, r15) ; literal name

        ; mov r14, [%2]
        ; mov r15, [%3]
        ; add r14, r15
        ; mov [%1], r14
        ; for some reason, i can't push three params`
        
        if r12w == defOperandInteger then `
            sprintf(ptrBuffer256, `"\tmov rcx, %s\r\n"`, ptr2Buffer64)`
        else if r12w == defOperandLiteral then `
            sprintf(ptrBuffer256, `"\tmov rcx, [%s]\r\n"`, ptr2Buffer64)`
        end end `        
        WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)
        sprintf(ptrBuffer256, `"%s"`, ptr3Buffer64)
        WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)
        
        multipop rax, rbx, r13, r14, r15

        PopCallerSavedRegs()
        SkipTokens(4)
        NextToken()`
    end 

    if currentToken.Type == defOperandStringLiteral then `
        ; todo - optimize strings by removing duplicate strings
        PushCallerSavedRegs()

        push rdx
        sprintf(ptrBuffer64, `"roStr_%d"`, [dwStringCount])
        WriteFile([hndDestFile], ptrBuffer64, rax, dwBytesWritten)
        pop rdx

        mov ecx, currentToken.Start
        mov edx, currentToken.Length
        call push_string_literal

        PopCallerSavedRegs()

        NextToken()`
    end `

    mov r10w, currentToken.Type
    mov r11d, currentToken.Start
    mov r12d, currentToken.Length

%ifdef DEBUG
    printf(`"[DEBUG] Token type %x; start: %d; length: %d\r\n"`, r10, r11, r12)
%endif

    push rax
    mov rax, szSourceCode
    add r11, rax
    strcpy(ptrBuffer64, r11, r12)

    ; printf(`"[WARN] Unknown token '%s'\r\n"`, ptrBuffer64)
    pop rax

    NextToken()
.end_counter_less_than_token_count:

%undef currentToken.Type
%undef currentToken.Start
%undef currentToken.Length

    call write_string_list

    pop rbp

    mov rcx, [hndDestFile]
    call CloseHandle

    printf(`"[\#27[92mINFO\#27[0m] Done compiling.\r\n"`, szSourceFile)

    jmp .assemble_object_file

.exit:
    ExitProcess(0)
    
.assemble_object_file:
    sprintf(ptrBuffer256, `"nasm.exe -f win64 -g %s.asm -o %s.o -w+all -w+error"`, szFilenameWithoutExtension, szFilenameWithoutExtension)
    printf(`"[\#27[92mINFO\#27[0m] Assembling using 'nasm':\r\n\t%s\r\n"`, ptrBuffer256)

    memset(lpProcessInformation, 0, 24)
    memset(lpStartupInfo, 0, 104)

    mov rax, STARTUPINFOA.size
    mov [lpStartupInfo], rax

    mov rax, lpProcessInformation
    mov rbx, lpStartupInfo
    mov [rbx], dword 104
    and rsp, 0xfffffffffffffff0
    push     rax                        ; lpProcessInformation   
    push     rbx                        ; lpStartupInfo  
    push     NULL                       ; lpCurrentDirectory
    push     NULL                       ; lpEnvironment
    push     0x00000000                 ; dwCreationFlags
    push     0x00000001                 ; bInheritHandles
    sub rsp, 0x20
    mov r9,  NULL                       ; lpThreadAttributes
    mov r8,  NULL                       ; lpProcessAttributes
    mov rdx, ptrBuffer256                       ; lpCommandLine
    mov rcx, NULL
    call CreateProcessA
    add rsp, 0x20 + 7 * 0x8 `

    if rax == 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Assembling failed."`)
        ExitProcess(1)`
    end `

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , 0xFFFFFFFF
    call WaitForSingleObject

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , lpExitCode
    call GetExitCodeProcess 
    
    ; printf(`"[DEBUG] Exit code: %d.\r\n"`, [lpExitCode])
    mov rax, [lpExitCode]
    `

    if rax != 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Assembling failed."`)
        ExitProcess(1)`
    end `

    sprintf(ptrBuffer256, `"ld -e _start %s.o -o %s.exe -lkernel32 -lWs2_32 -Llib"`, szFilenameWithoutExtension, szFilenameWithoutExtension)
    printf(`"[\#27[92mINFO\#27[0m] Linking using 'ld':\r\n\t%s\r\n"`, ptrBuffer256)
    
    memset(lpProcessInformation, 0, 24)
    memset(lpStartupInfo, 0, 104)

    mov rax, STARTUPINFOA.size
    mov [lpStartupInfo], rax

    mov rax, lpProcessInformation
    mov rbx, lpStartupInfo
    mov [rbx], dword 104
    and rsp, 0xfffffffffffffff0
    push     rax                        ; lpProcessInformation   
    push     rbx                        ; lpStartupInfo  
    push     NULL                       ; lpCurrentDirectory
    push     NULL                       ; lpEnvironment
    push     0x00000000                 ; dwCreationFlags
    push     0x00000001                 ; bInheritHandles
    sub rsp, 0x20
    mov r9,  NULL                       ; lpThreadAttributes
    mov r8,  NULL                       ; lpProcessAttributes
    mov rdx, ptrBuffer256                       ; lpCommandLine
    mov rcx, NULL
    call CreateProcessA
    add rsp, 0x20 + 7 * 0x8`

    if rax == 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Linking failed."`)
        ExitProcess(1)`
    end `

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , 0xFFFFFFFF
    call WaitForSingleObject

    mov rcx , [lpProcessInformation + PROCESS_INFORMATION.hProcess]
    mov rdx , lpExitCode
    call GetExitCodeProcess 
    mov rax, [lpExitCode]
    `

    if rax != 0 then `
        printf(`"[\#27[91mERROR\#27[0m] Linking failed."`)
        ExitProcess(1)`
    end `

    ; delete object file
%ifdef DEBUG
    printf(`"[DEBUG] Deleting object file.\r\n"`)
%endif

    sprintf(ptrBuffer256, `"%s.o"`, szFilenameWithoutExtension)
    mov rcx, ptrBuffer256
    call DeleteFileA`

    if rax == 0 then `
        printf(`"[WARN] Deleting object file failed.\r\n"`)`
    end `

    printf(`"[\#27[92mINFO\#27[0m] Generated %s.exe\r\n"`, szFilenameWithoutExtension, szFilenameWithoutExtension)
    jmp .exit

; this routine will save a string literal to the string list
; rcx holds token start, rdx holds token length
push_string_literal:
    PushCalleeSavedRegs()

    mov r15, szSourceCode
    add r15, rcx
    mov r14, rdx

    ; todo - check if string literal already exists

    ; load next available string list pointer into rax
    mov rax, [dwStringCount]`

    if rax >= CONST_STRING_COUNT then `
        printf(`"[\#27[91mERROR\#27[0m]: String list full. Max strings allowed: %d\r\n"`, CONST_STRING_COUNT)
        ExitProcess(1)`
    end `

    mov rdx, qword 8 ; size of pointer
    mul rdx
    mov rdx, pStringListPointers
    add rax, rdx

    ; store pointer to string in pointer list
    mov rbx, [pStringListEnd]
    mov [rax], rbx 
    
    ; increment pointer count
    mov rcx, [dwStringCount]
    inc rcx
    mov [dwStringCount], rcx

    ; copy string literal to string list
    strcpy(rbx, r15, r14)

    ; advance string list end pointer
    mov rax, [pStringListEnd]
    add rax, r14
    inc rax ; null terminator
    mov [pStringListEnd], rax
.end:
    PopCalleeSavedRegs()
    ret

; this routine writes constant string literals to file
; they will be stored in the readonly section (rodata)
write_string_list:
    PushCalleeSavedRegs()

    mov r13, [dwStringCount]
    dec r13 
    mov rax, r13
    mov rdx, qword 8 ; size of pointer
    mul rdx
    ; rax hold offset
    mov rdx, pStringListPointers
    add rax, rdx 
    mov r15, rax ; r15 holds pointer to last string literal

    WriteFile([hndDestFile], cStrReadOnlySectionHeader, cStrReadOnlySectionHeader.length, dwBytesWritten)

.while_not_less_than_0:
    cmp r13, 0
    jl .end_not_less_than_0
.do_not_less_than_0:   
    mov r14, [r15]

    sprintf(ptrBuffer256, `"    roStr_%d db %s, 0\r\n"`, r13, r14)
    WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)

    dec r13
    sub r15, qword 8 ; move back to previous string literal
    jmp .while_not_less_than_0
.end_not_less_than_0:

.end:
    PopCalleeSavedRegs()
    ret

compile_condition_1:
    push rbp
    mov rbp, rsp
    sub rsp, 0x10 ; reserve space on the stack for the token index
    mov [rbp], rcx ; store token index on the stack
    mov [rbp - 0x8], rdx ; store scope id on the stack
    PushCalleeSavedRegs()

    ; get first operand
    mov rax, rcx
    mov rdx, Token.size
    mul rdx
    mov rcx, tokenList
    add rcx, rax
    mov rbx, rcx

    mov r10, szSourceCode
    mov r11, [rbx + Token.TokenStart]
    mov r12, [rbx + Token.TokenLength]
    add r10, r11
    strcpy(ptrBuffer64, r10, r12)

    sprintf(ptrBuffer256, `"    %s\r\n"`, ptrBuffer64)

    ; write comparison
    WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)
    
    multipush r10, r13, r14
    mov r13d, dword [dwTokenCount]
    mov r14, [rbp] ; token index points to the first operand
    add r14, 1`
    
    while r14 <= r13 do `
        ; lacking an 'or', I have to do this for now
        mov r10w, word [rbx + Token.TokenType]`
        if r10w == defKeywordElse then `
            jmp .found_matching_keyword`
        end

        if r10w == defKeywordEnd then `
            jmp .found_matching_keyword`
        end `
        
        inc r14
        add rbx, Token.size`
    end `
    printf(`"[\#27[91mERROR\#27[0m] Expected 'then' or 'else' after if condition\r\n"`)
    ExitProcess(1)

.found_matching_keyword:    
    mov r13, [rbp - 0x8] ; r13 stores scope id`
    
    if r10w == defKeywordElse then `
        sprintf(ptrBuffer64, `".else_%d"`, r13)`
    else `    
        sprintf(ptrBuffer64, `".end_%d"`, r13)`
    end `

    multipop r10, r13, r14

    mov r13, [rbp - 0x8] ; r13 stores scope id
    sprintf(ptrBuffer256, `"    jne %s\r\n"`, ptrBuffer64)

    WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)

.end:
    PopCalleeSavedRegs()
    add rsp, 0x10
    pop rbp
    mov rax, 0
    ret     

; this routine will compile simple if conditions
; the *MUST* be in the form of:
;   <operand> <operator> <operand>
; it will simply write this asm code:
;   cmp <operand>, <operand>
;   !<operator> <label>
; rcx must hold the token index of the first token of the if condition
; rdx must hold the scope id of the current scope
compile_condition_3:
    push rbp
    mov rbp, rsp
    sub rsp, 0x10 ; reserve space on the stack for the token index
    mov [rbp], rcx ; store token index on the stack
    mov [rbp - 0x8], rdx ; store scope id on the stack
    PushCalleeSavedRegs()

    ; get first operand
    mov rax, rcx
    mov rdx, Token.size
    mul rdx
    mov rcx, tokenList
    add rcx, rax
    mov rbx, rcx

    mov r10, szSourceCode
    mov r11, [rbx + Token.TokenStart]
    mov r12, [rbx + Token.TokenLength]
    add r10, r11
    strcpy(ptrBuffer64, r10, r12)

    add rbx, Token.size * 2 ; advance to second operand
    mov r10, szSourceCode
    mov r11, [rbx + Token.TokenStart]
    mov r12, [rbx + Token.TokenLength]
    add r10, r11
    strcpy(ptr2Buffer64, r10, r12)

    sprintf(ptrBuffer256, `"    cmp %s, %s\r\n"`, ptrBuffer64, ptr2Buffer64)

    ; write comparison
    WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)
   
    ; write operator
    sub rbx, Token.size ; move back to operator
    mov r10, [rbx - Token.TokenType]
    and r10, 0xffff

    multipush r10, r13, r14
    mov r13d, dword [dwTokenCount]
    mov r14, [rbp] ; token index points to the first operand
    add r14, 2`
    
    while r14 <= r13 do `
        ; lacking an 'or', I have to do this for now
        mov r10w, word [rbx + Token.TokenType]`
        if r10w == defKeywordElse then `
            jmp .found_matching_keyword`
        end

        if r10w == defKeywordEnd then `
            jmp .found_matching_keyword`
        end `
        
        inc r14
        add rbx, Token.size`
    end `
    printf(`"[\#27[91mERROR\#27[0m] Expected 'then' or 'else' after if condition\r\n"`)
    ExitProcess(1)

.found_matching_keyword:    

    mov r13, [rbp - 0x8] ; r13 stores scope id`
    
    if r10w == defKeywordElse then `
        sprintf(ptrBuffer64, `".else_%d"`, r13)`
    else `    
        sprintf(ptrBuffer64, `".end_%d"`, r13)`
    end `

    multipop r10, r13, r14
    `
    if r10 == OperatorEquals then `
        sprintf(ptrBuffer256, `"\tjne %s\r\n"`, ptrBuffer64)`
    else if r10 == OperatorNotEquals then `
        sprintf(ptrBuffer256, `"\tje %s\r\n"`, ptrBuffer64)`
    else if r10 == OperatorLess then `
        sprintf(ptrBuffer256, `"\tjge %s\r\n"`, ptrBuffer64)`
    else if r10 == OperatorLessOrEqual then `
        sprintf(ptrBuffer256, `"\tjg %s\r\n"`, ptrBuffer64)`
    else if r10 == OperatorGreater then `
        sprintf(ptrBuffer256, `"\tjle %s\r\n"`, ptrBuffer64)`
    else if r10 == OperatorGreaterOrEqual then `
        sprintf(ptrBuffer256, `"\tjl %s\r\n"`, ptrBuffer64)`
    else `
        printf(`"[\#27[91mERROR\#27[0m] Unsupported operator %x\r\n"`, r10)
        ExitProcess(1)`
    end end end end end end `

    WriteFile([hndDestFile], ptrBuffer256, rax, dwBytesWritten)

.end:
    PopCalleeSavedRegs()
    add rsp, 0x10
    pop rbp
    ; mov rax, 0
    ret

section .data
    szStrataFileExtension db ".strata"
    szStrataFileExtension.length equ $ - szStrataFileExtension
    szAsmFileExtension db ".asm"
    szAsmFileExtension.length equ $ - szAsmFileExtension
    szTab db "    "
    szTab.length equ $ - szTab
    szAsmDataStringType db " db "
    szAsmDataStringType.length equ $ - szAsmDataStringType
    szAsmDataStringLengthType db " equ $ - "
    szAsmDataStringLengthType.length equ $ - szAsmDataStringLengthType
    szAsmDataStringSuffix db ".length"
    szAsmDataStringSuffix.length equ $ - szAsmDataStringSuffix
    szKeywordIf db "if"
    szKeywordIf.length equ $ - szKeywordIf
    szKeywordThen db "then"
    szKeywordThen.length equ $ - szKeywordThen
    szKeywordElse db "else"
    szKeywordElse.length equ $ - szKeywordElse
    szKeywordEnd db "end"
    szKeywordEnd.length equ $ - szKeywordEnd
    szKeywordWhile db "while"
    szKeywordWhile.length equ $ - szKeywordWhile
    szKeywordDo db "do"
    szKeywordDo.length equ $ - szKeywordDo
    szKeywordContinue db "continue"
    szKeywordContinue.length equ $ - szKeywordContinue
    szKeywordBreak db "break"
    szKeywordBreak.length equ $ - szKeywordBreak
    szKeywordNumber db "num"
    szKeywordNumber.length equ $ - szKeywordNumber
    szOperatorEquals db "=="
    szOperatorEquals.length equ $ - szOperatorEquals
    szOperatorNotEquals db "!="
    szOperatorNotEquals.length equ $ - szOperatorNotEquals
    szOperatorLess db "<"
    szOperatorLess.length equ $ - szOperatorLess
    szOperatorLessOrEqual db "<="
    szOperatorLessOrEqual.length equ $ - szOperatorLessOrEqual
    szOperatorGreater db ">"
    szOperatorGreater.length equ $ - szOperatorGreater
    szOperatorGreaterOrEqual db ">="
    szOperatorGreaterOrEqual.length equ $ - szOperatorGreaterOrEqual
    szOperatorAssignment db "="
    szOperatorAssignment.length equ $ - szOperatorAssignment
    szOperatorPlus db "+"
    szOperatorPlus.length equ $ - szOperatorPlus
    szOperatorMinus db "-"
    szOperatorMinus.length equ $ - szOperatorMinus
    szOperatorMultiply db "*"
    szOperatorMultiply.length equ $ - szOperatorMultiply
    szOperatorDivide db "/"
    szOperatorDivide.length equ $ - szOperatorDivide
    szOperatorModulo db "%"
    szOperatorModulo.length equ $ - szOperatorModulo
`